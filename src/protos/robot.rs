// This file is generated. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

#[derive(PartialEq,Clone,Default)]
pub struct getAccelerometerData {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for getAccelerometerData {}

impl getAccelerometerData {
    pub fn new() -> getAccelerometerData {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static getAccelerometerData {
        static mut instance: ::protobuf::lazy::Lazy<getAccelerometerData> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const getAccelerometerData,
        };
        unsafe {
            instance.get(getAccelerometerData::new)
        }
    }
}

impl ::protobuf::Message for getAccelerometerData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for getAccelerometerData {
    fn new() -> getAccelerometerData {
        getAccelerometerData::new()
    }

    fn descriptor_static(_: ::std::option::Option<getAccelerometerData>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<getAccelerometerData>(
                    "getAccelerometerData",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for getAccelerometerData {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for getAccelerometerData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for getAccelerometerData {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct getAccelerometerData_In {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for getAccelerometerData_In {}

impl getAccelerometerData_In {
    pub fn new() -> getAccelerometerData_In {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static getAccelerometerData_In {
        static mut instance: ::protobuf::lazy::Lazy<getAccelerometerData_In> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const getAccelerometerData_In,
        };
        unsafe {
            instance.get(getAccelerometerData_In::new)
        }
    }
}

impl ::protobuf::Message for getAccelerometerData_In {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for getAccelerometerData_In {
    fn new() -> getAccelerometerData_In {
        getAccelerometerData_In::new()
    }

    fn descriptor_static(_: ::std::option::Option<getAccelerometerData_In>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<getAccelerometerData_In>(
                    "getAccelerometerData_In",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for getAccelerometerData_In {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for getAccelerometerData_In {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for getAccelerometerData_In {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct getAccelerometerData_Out {
    // message fields
    x: ::std::option::Option<f32>,
    y: ::std::option::Option<f32>,
    z: ::std::option::Option<f32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for getAccelerometerData_Out {}

impl getAccelerometerData_Out {
    pub fn new() -> getAccelerometerData_Out {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static getAccelerometerData_Out {
        static mut instance: ::protobuf::lazy::Lazy<getAccelerometerData_Out> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const getAccelerometerData_Out,
        };
        unsafe {
            instance.get(getAccelerometerData_Out::new)
        }
    }

    // optional float x = 1;

    pub fn clear_x(&mut self) {
        self.x = ::std::option::Option::None;
    }

    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: f32) {
        self.x = ::std::option::Option::Some(v);
    }

    pub fn get_x(&self) -> f32 {
        self.x.unwrap_or(0.)
    }

    fn get_x_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.x
    }

    fn mut_x_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.x
    }

    // optional float y = 2;

    pub fn clear_y(&mut self) {
        self.y = ::std::option::Option::None;
    }

    pub fn has_y(&self) -> bool {
        self.y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: f32) {
        self.y = ::std::option::Option::Some(v);
    }

    pub fn get_y(&self) -> f32 {
        self.y.unwrap_or(0.)
    }

    fn get_y_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.y
    }

    fn mut_y_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.y
    }

    // optional float z = 3;

    pub fn clear_z(&mut self) {
        self.z = ::std::option::Option::None;
    }

    pub fn has_z(&self) -> bool {
        self.z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_z(&mut self, v: f32) {
        self.z = ::std::option::Option::Some(v);
    }

    pub fn get_z(&self) -> f32 {
        self.z.unwrap_or(0.)
    }

    fn get_z_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.z
    }

    fn mut_z_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.z
    }
}

impl ::protobuf::Message for getAccelerometerData_Out {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.x = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.y = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.z = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.x {
            my_size += 5;
        }
        if let Some(v) = self.y {
            my_size += 5;
        }
        if let Some(v) = self.z {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.x {
            os.write_float(1, v)?;
        }
        if let Some(v) = self.y {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.z {
            os.write_float(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for getAccelerometerData_Out {
    fn new() -> getAccelerometerData_Out {
        getAccelerometerData_Out::new()
    }

    fn descriptor_static(_: ::std::option::Option<getAccelerometerData_Out>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "x",
                    getAccelerometerData_Out::get_x_for_reflect,
                    getAccelerometerData_Out::mut_x_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "y",
                    getAccelerometerData_Out::get_y_for_reflect,
                    getAccelerometerData_Out::mut_y_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "z",
                    getAccelerometerData_Out::get_z_for_reflect,
                    getAccelerometerData_Out::mut_z_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<getAccelerometerData_Out>(
                    "getAccelerometerData_Out",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for getAccelerometerData_Out {
    fn clear(&mut self) {
        self.clear_x();
        self.clear_y();
        self.clear_z();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for getAccelerometerData_Out {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for getAccelerometerData_Out {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct getBatteryVoltage {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for getBatteryVoltage {}

impl getBatteryVoltage {
    pub fn new() -> getBatteryVoltage {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static getBatteryVoltage {
        static mut instance: ::protobuf::lazy::Lazy<getBatteryVoltage> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const getBatteryVoltage,
        };
        unsafe {
            instance.get(getBatteryVoltage::new)
        }
    }
}

impl ::protobuf::Message for getBatteryVoltage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for getBatteryVoltage {
    fn new() -> getBatteryVoltage {
        getBatteryVoltage::new()
    }

    fn descriptor_static(_: ::std::option::Option<getBatteryVoltage>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<getBatteryVoltage>(
                    "getBatteryVoltage",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for getBatteryVoltage {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for getBatteryVoltage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for getBatteryVoltage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct getBatteryVoltage_In {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for getBatteryVoltage_In {}

impl getBatteryVoltage_In {
    pub fn new() -> getBatteryVoltage_In {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static getBatteryVoltage_In {
        static mut instance: ::protobuf::lazy::Lazy<getBatteryVoltage_In> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const getBatteryVoltage_In,
        };
        unsafe {
            instance.get(getBatteryVoltage_In::new)
        }
    }
}

impl ::protobuf::Message for getBatteryVoltage_In {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for getBatteryVoltage_In {
    fn new() -> getBatteryVoltage_In {
        getBatteryVoltage_In::new()
    }

    fn descriptor_static(_: ::std::option::Option<getBatteryVoltage_In>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<getBatteryVoltage_In>(
                    "getBatteryVoltage_In",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for getBatteryVoltage_In {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for getBatteryVoltage_In {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for getBatteryVoltage_In {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct getBatteryVoltage_Out {
    // message fields
    v: ::std::option::Option<f32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for getBatteryVoltage_Out {}

impl getBatteryVoltage_Out {
    pub fn new() -> getBatteryVoltage_Out {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static getBatteryVoltage_Out {
        static mut instance: ::protobuf::lazy::Lazy<getBatteryVoltage_Out> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const getBatteryVoltage_Out,
        };
        unsafe {
            instance.get(getBatteryVoltage_Out::new)
        }
    }

    // optional float v = 1;

    pub fn clear_v(&mut self) {
        self.v = ::std::option::Option::None;
    }

    pub fn has_v(&self) -> bool {
        self.v.is_some()
    }

    // Param is passed by value, moved
    pub fn set_v(&mut self, v: f32) {
        self.v = ::std::option::Option::Some(v);
    }

    pub fn get_v(&self) -> f32 {
        self.v.unwrap_or(0.)
    }

    fn get_v_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.v
    }

    fn mut_v_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.v
    }
}

impl ::protobuf::Message for getBatteryVoltage_Out {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.v = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.v {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.v {
            os.write_float(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for getBatteryVoltage_Out {
    fn new() -> getBatteryVoltage_Out {
        getBatteryVoltage_Out::new()
    }

    fn descriptor_static(_: ::std::option::Option<getBatteryVoltage_Out>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "v",
                    getBatteryVoltage_Out::get_v_for_reflect,
                    getBatteryVoltage_Out::mut_v_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<getBatteryVoltage_Out>(
                    "getBatteryVoltage_Out",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for getBatteryVoltage_Out {
    fn clear(&mut self) {
        self.clear_v();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for getBatteryVoltage_Out {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for getBatteryVoltage_Out {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct getAdcRaw {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for getAdcRaw {}

impl getAdcRaw {
    pub fn new() -> getAdcRaw {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static getAdcRaw {
        static mut instance: ::protobuf::lazy::Lazy<getAdcRaw> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const getAdcRaw,
        };
        unsafe {
            instance.get(getAdcRaw::new)
        }
    }
}

impl ::protobuf::Message for getAdcRaw {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for getAdcRaw {
    fn new() -> getAdcRaw {
        getAdcRaw::new()
    }

    fn descriptor_static(_: ::std::option::Option<getAdcRaw>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<getAdcRaw>(
                    "getAdcRaw",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for getAdcRaw {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for getAdcRaw {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for getAdcRaw {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct getAdcRaw_In {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for getAdcRaw_In {}

impl getAdcRaw_In {
    pub fn new() -> getAdcRaw_In {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static getAdcRaw_In {
        static mut instance: ::protobuf::lazy::Lazy<getAdcRaw_In> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const getAdcRaw_In,
        };
        unsafe {
            instance.get(getAdcRaw_In::new)
        }
    }
}

impl ::protobuf::Message for getAdcRaw_In {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for getAdcRaw_In {
    fn new() -> getAdcRaw_In {
        getAdcRaw_In::new()
    }

    fn descriptor_static(_: ::std::option::Option<getAdcRaw_In>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<getAdcRaw_In>(
                    "getAdcRaw_In",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for getAdcRaw_In {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for getAdcRaw_In {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for getAdcRaw_In {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct getAdcRaw_Out {
    // message fields
    values: ::std::vec::Vec<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for getAdcRaw_Out {}

impl getAdcRaw_Out {
    pub fn new() -> getAdcRaw_Out {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static getAdcRaw_Out {
        static mut instance: ::protobuf::lazy::Lazy<getAdcRaw_Out> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const getAdcRaw_Out,
        };
        unsafe {
            instance.get(getAdcRaw_Out::new)
        }
    }

    // repeated uint32 values = 1;

    pub fn clear_values(&mut self) {
        self.values.clear();
    }

    // Param is passed by value, moved
    pub fn set_values(&mut self, v: ::std::vec::Vec<u32>) {
        self.values = v;
    }

    // Mutable pointer to the field.
    pub fn mut_values(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.values
    }

    // Take field
    pub fn take_values(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.values, ::std::vec::Vec::new())
    }

    pub fn get_values(&self) -> &[u32] {
        &self.values
    }

    fn get_values_for_reflect(&self) -> &::std::vec::Vec<u32> {
        &self.values
    }

    fn mut_values_for_reflect(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.values
    }
}

impl ::protobuf::Message for getAdcRaw_Out {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.values)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.values.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_size(1, &self.values);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.values.is_empty() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_varint_data_size(&self.values))?;
            for v in &self.values {
                os.write_uint32_no_tag(*v)?;
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for getAdcRaw_Out {
    fn new() -> getAdcRaw_Out {
        getAdcRaw_Out::new()
    }

    fn descriptor_static(_: ::std::option::Option<getAdcRaw_Out>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "values",
                    getAdcRaw_Out::get_values_for_reflect,
                    getAdcRaw_Out::mut_values_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<getAdcRaw_Out>(
                    "getAdcRaw_Out",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for getAdcRaw_Out {
    fn clear(&mut self) {
        self.clear_values();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for getAdcRaw_Out {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for getAdcRaw_Out {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct getButtonState {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for getButtonState {}

impl getButtonState {
    pub fn new() -> getButtonState {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static getButtonState {
        static mut instance: ::protobuf::lazy::Lazy<getButtonState> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const getButtonState,
        };
        unsafe {
            instance.get(getButtonState::new)
        }
    }
}

impl ::protobuf::Message for getButtonState {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for getButtonState {
    fn new() -> getButtonState {
        getButtonState::new()
    }

    fn descriptor_static(_: ::std::option::Option<getButtonState>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<getButtonState>(
                    "getButtonState",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for getButtonState {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for getButtonState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for getButtonState {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct getButtonState_In {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for getButtonState_In {}

impl getButtonState_In {
    pub fn new() -> getButtonState_In {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static getButtonState_In {
        static mut instance: ::protobuf::lazy::Lazy<getButtonState_In> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const getButtonState_In,
        };
        unsafe {
            instance.get(getButtonState_In::new)
        }
    }
}

impl ::protobuf::Message for getButtonState_In {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for getButtonState_In {
    fn new() -> getButtonState_In {
        getButtonState_In::new()
    }

    fn descriptor_static(_: ::std::option::Option<getButtonState_In>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<getButtonState_In>(
                    "getButtonState_In",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for getButtonState_In {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for getButtonState_In {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for getButtonState_In {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct getButtonState_Out {
    // message fields
    mask: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for getButtonState_Out {}

impl getButtonState_Out {
    pub fn new() -> getButtonState_Out {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static getButtonState_Out {
        static mut instance: ::protobuf::lazy::Lazy<getButtonState_Out> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const getButtonState_Out,
        };
        unsafe {
            instance.get(getButtonState_Out::new)
        }
    }

    // optional uint32 mask = 1;

    pub fn clear_mask(&mut self) {
        self.mask = ::std::option::Option::None;
    }

    pub fn has_mask(&self) -> bool {
        self.mask.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mask(&mut self, v: u32) {
        self.mask = ::std::option::Option::Some(v);
    }

    pub fn get_mask(&self) -> u32 {
        self.mask.unwrap_or(0)
    }

    fn get_mask_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.mask
    }

    fn mut_mask_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.mask
    }
}

impl ::protobuf::Message for getButtonState_Out {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.mask = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.mask {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.mask {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for getButtonState_Out {
    fn new() -> getButtonState_Out {
        getButtonState_Out::new()
    }

    fn descriptor_static(_: ::std::option::Option<getButtonState_Out>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "mask",
                    getButtonState_Out::get_mask_for_reflect,
                    getButtonState_Out::mut_mask_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<getButtonState_Out>(
                    "getButtonState_Out",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for getButtonState_Out {
    fn clear(&mut self) {
        self.clear_mask();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for getButtonState_Out {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for getButtonState_Out {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct getBuzzerFrequency {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for getBuzzerFrequency {}

impl getBuzzerFrequency {
    pub fn new() -> getBuzzerFrequency {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static getBuzzerFrequency {
        static mut instance: ::protobuf::lazy::Lazy<getBuzzerFrequency> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const getBuzzerFrequency,
        };
        unsafe {
            instance.get(getBuzzerFrequency::new)
        }
    }
}

impl ::protobuf::Message for getBuzzerFrequency {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for getBuzzerFrequency {
    fn new() -> getBuzzerFrequency {
        getBuzzerFrequency::new()
    }

    fn descriptor_static(_: ::std::option::Option<getBuzzerFrequency>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<getBuzzerFrequency>(
                    "getBuzzerFrequency",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for getBuzzerFrequency {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for getBuzzerFrequency {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for getBuzzerFrequency {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct getBuzzerFrequency_In {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for getBuzzerFrequency_In {}

impl getBuzzerFrequency_In {
    pub fn new() -> getBuzzerFrequency_In {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static getBuzzerFrequency_In {
        static mut instance: ::protobuf::lazy::Lazy<getBuzzerFrequency_In> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const getBuzzerFrequency_In,
        };
        unsafe {
            instance.get(getBuzzerFrequency_In::new)
        }
    }
}

impl ::protobuf::Message for getBuzzerFrequency_In {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for getBuzzerFrequency_In {
    fn new() -> getBuzzerFrequency_In {
        getBuzzerFrequency_In::new()
    }

    fn descriptor_static(_: ::std::option::Option<getBuzzerFrequency_In>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<getBuzzerFrequency_In>(
                    "getBuzzerFrequency_In",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for getBuzzerFrequency_In {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for getBuzzerFrequency_In {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for getBuzzerFrequency_In {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct getBuzzerFrequency_Out {
    // message fields
    value: ::std::option::Option<f32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for getBuzzerFrequency_Out {}

impl getBuzzerFrequency_Out {
    pub fn new() -> getBuzzerFrequency_Out {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static getBuzzerFrequency_Out {
        static mut instance: ::protobuf::lazy::Lazy<getBuzzerFrequency_Out> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const getBuzzerFrequency_Out,
        };
        unsafe {
            instance.get(getBuzzerFrequency_Out::new)
        }
    }

    // optional float value = 1;

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: f32) {
        self.value = ::std::option::Option::Some(v);
    }

    pub fn get_value(&self) -> f32 {
        self.value.unwrap_or(0.)
    }

    fn get_value_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.value
    }

    fn mut_value_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.value
    }
}

impl ::protobuf::Message for getBuzzerFrequency_Out {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.value = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.value {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.value {
            os.write_float(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for getBuzzerFrequency_Out {
    fn new() -> getBuzzerFrequency_Out {
        getBuzzerFrequency_Out::new()
    }

    fn descriptor_static(_: ::std::option::Option<getBuzzerFrequency_Out>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "value",
                    getBuzzerFrequency_Out::get_value_for_reflect,
                    getBuzzerFrequency_Out::mut_value_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<getBuzzerFrequency_Out>(
                    "getBuzzerFrequency_Out",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for getBuzzerFrequency_Out {
    fn clear(&mut self) {
        self.clear_value();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for getBuzzerFrequency_Out {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for getBuzzerFrequency_Out {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct getEncoderValues {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for getEncoderValues {}

impl getEncoderValues {
    pub fn new() -> getEncoderValues {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static getEncoderValues {
        static mut instance: ::protobuf::lazy::Lazy<getEncoderValues> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const getEncoderValues,
        };
        unsafe {
            instance.get(getEncoderValues::new)
        }
    }
}

impl ::protobuf::Message for getEncoderValues {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for getEncoderValues {
    fn new() -> getEncoderValues {
        getEncoderValues::new()
    }

    fn descriptor_static(_: ::std::option::Option<getEncoderValues>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<getEncoderValues>(
                    "getEncoderValues",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for getEncoderValues {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for getEncoderValues {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for getEncoderValues {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct getEncoderValues_In {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for getEncoderValues_In {}

impl getEncoderValues_In {
    pub fn new() -> getEncoderValues_In {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static getEncoderValues_In {
        static mut instance: ::protobuf::lazy::Lazy<getEncoderValues_In> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const getEncoderValues_In,
        };
        unsafe {
            instance.get(getEncoderValues_In::new)
        }
    }
}

impl ::protobuf::Message for getEncoderValues_In {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for getEncoderValues_In {
    fn new() -> getEncoderValues_In {
        getEncoderValues_In::new()
    }

    fn descriptor_static(_: ::std::option::Option<getEncoderValues_In>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<getEncoderValues_In>(
                    "getEncoderValues_In",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for getEncoderValues_In {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for getEncoderValues_In {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for getEncoderValues_In {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct getEncoderValues_Out {
    // message fields
    timestamp: ::std::option::Option<u32>,
    values: ::std::vec::Vec<f32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for getEncoderValues_Out {}

impl getEncoderValues_Out {
    pub fn new() -> getEncoderValues_Out {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static getEncoderValues_Out {
        static mut instance: ::protobuf::lazy::Lazy<getEncoderValues_Out> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const getEncoderValues_Out,
        };
        unsafe {
            instance.get(getEncoderValues_Out::new)
        }
    }

    // optional uint32 timestamp = 1;

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    pub fn get_timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }

    fn get_timestamp_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.timestamp
    }

    fn mut_timestamp_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.timestamp
    }

    // repeated float values = 2;

    pub fn clear_values(&mut self) {
        self.values.clear();
    }

    // Param is passed by value, moved
    pub fn set_values(&mut self, v: ::std::vec::Vec<f32>) {
        self.values = v;
    }

    // Mutable pointer to the field.
    pub fn mut_values(&mut self) -> &mut ::std::vec::Vec<f32> {
        &mut self.values
    }

    // Take field
    pub fn take_values(&mut self) -> ::std::vec::Vec<f32> {
        ::std::mem::replace(&mut self.values, ::std::vec::Vec::new())
    }

    pub fn get_values(&self) -> &[f32] {
        &self.values
    }

    fn get_values_for_reflect(&self) -> &::std::vec::Vec<f32> {
        &self.values
    }

    fn mut_values_for_reflect(&mut self) -> &mut ::std::vec::Vec<f32> {
        &mut self.values
    }
}

impl ::protobuf::Message for getEncoderValues_Out {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.timestamp = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_float_into(wire_type, is, &mut self.values)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.values.is_empty() {
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(self.values.len() as u32) + (self.values.len() * 4) as u32;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.timestamp {
            os.write_uint32(1, v)?;
        }
        if !self.values.is_empty() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32((self.values.len() * 4) as u32)?;
            for v in &self.values {
                os.write_float_no_tag(*v)?;
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for getEncoderValues_Out {
    fn new() -> getEncoderValues_Out {
        getEncoderValues_Out::new()
    }

    fn descriptor_static(_: ::std::option::Option<getEncoderValues_Out>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "timestamp",
                    getEncoderValues_Out::get_timestamp_for_reflect,
                    getEncoderValues_Out::mut_timestamp_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "values",
                    getEncoderValues_Out::get_values_for_reflect,
                    getEncoderValues_Out::mut_values_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<getEncoderValues_Out>(
                    "getEncoderValues_Out",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for getEncoderValues_Out {
    fn clear(&mut self) {
        self.clear_timestamp();
        self.clear_values();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for getEncoderValues_Out {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for getEncoderValues_Out {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct getFirmwareVersionString {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for getFirmwareVersionString {}

impl getFirmwareVersionString {
    pub fn new() -> getFirmwareVersionString {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static getFirmwareVersionString {
        static mut instance: ::protobuf::lazy::Lazy<getFirmwareVersionString> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const getFirmwareVersionString,
        };
        unsafe {
            instance.get(getFirmwareVersionString::new)
        }
    }
}

impl ::protobuf::Message for getFirmwareVersionString {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for getFirmwareVersionString {
    fn new() -> getFirmwareVersionString {
        getFirmwareVersionString::new()
    }

    fn descriptor_static(_: ::std::option::Option<getFirmwareVersionString>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<getFirmwareVersionString>(
                    "getFirmwareVersionString",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for getFirmwareVersionString {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for getFirmwareVersionString {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for getFirmwareVersionString {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct getFirmwareVersionString_In {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for getFirmwareVersionString_In {}

impl getFirmwareVersionString_In {
    pub fn new() -> getFirmwareVersionString_In {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static getFirmwareVersionString_In {
        static mut instance: ::protobuf::lazy::Lazy<getFirmwareVersionString_In> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const getFirmwareVersionString_In,
        };
        unsafe {
            instance.get(getFirmwareVersionString_In::new)
        }
    }
}

impl ::protobuf::Message for getFirmwareVersionString_In {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for getFirmwareVersionString_In {
    fn new() -> getFirmwareVersionString_In {
        getFirmwareVersionString_In::new()
    }

    fn descriptor_static(_: ::std::option::Option<getFirmwareVersionString_In>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<getFirmwareVersionString_In>(
                    "getFirmwareVersionString_In",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for getFirmwareVersionString_In {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for getFirmwareVersionString_In {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for getFirmwareVersionString_In {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct getFirmwareVersionString_Out {
    // message fields
    value: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for getFirmwareVersionString_Out {}

impl getFirmwareVersionString_Out {
    pub fn new() -> getFirmwareVersionString_Out {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static getFirmwareVersionString_Out {
        static mut instance: ::protobuf::lazy::Lazy<getFirmwareVersionString_Out> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const getFirmwareVersionString_Out,
        };
        unsafe {
            instance.get(getFirmwareVersionString_Out::new)
        }
    }

    // optional string value = 1;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_value_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.value
    }

    fn mut_value_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.value
    }
}

impl ::protobuf::Message for getFirmwareVersionString_Out {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.value.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for getFirmwareVersionString_Out {
    fn new() -> getFirmwareVersionString_Out {
        getFirmwareVersionString_Out::new()
    }

    fn descriptor_static(_: ::std::option::Option<getFirmwareVersionString_Out>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "value",
                    getFirmwareVersionString_Out::get_value_for_reflect,
                    getFirmwareVersionString_Out::mut_value_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<getFirmwareVersionString_Out>(
                    "getFirmwareVersionString_Out",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for getFirmwareVersionString_Out {
    fn clear(&mut self) {
        self.clear_value();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for getFirmwareVersionString_Out {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for getFirmwareVersionString_Out {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct getFormFactor {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for getFormFactor {}

impl getFormFactor {
    pub fn new() -> getFormFactor {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static getFormFactor {
        static mut instance: ::protobuf::lazy::Lazy<getFormFactor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const getFormFactor,
        };
        unsafe {
            instance.get(getFormFactor::new)
        }
    }
}

impl ::protobuf::Message for getFormFactor {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for getFormFactor {
    fn new() -> getFormFactor {
        getFormFactor::new()
    }

    fn descriptor_static(_: ::std::option::Option<getFormFactor>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<getFormFactor>(
                    "getFormFactor",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for getFormFactor {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for getFormFactor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for getFormFactor {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct getFormFactor_In {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for getFormFactor_In {}

impl getFormFactor_In {
    pub fn new() -> getFormFactor_In {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static getFormFactor_In {
        static mut instance: ::protobuf::lazy::Lazy<getFormFactor_In> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const getFormFactor_In,
        };
        unsafe {
            instance.get(getFormFactor_In::new)
        }
    }
}

impl ::protobuf::Message for getFormFactor_In {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for getFormFactor_In {
    fn new() -> getFormFactor_In {
        getFormFactor_In::new()
    }

    fn descriptor_static(_: ::std::option::Option<getFormFactor_In>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<getFormFactor_In>(
                    "getFormFactor_In",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for getFormFactor_In {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for getFormFactor_In {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for getFormFactor_In {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct getFormFactor_Out {
    // message fields
    value: ::std::option::Option<FormFactor>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for getFormFactor_Out {}

impl getFormFactor_Out {
    pub fn new() -> getFormFactor_Out {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static getFormFactor_Out {
        static mut instance: ::protobuf::lazy::Lazy<getFormFactor_Out> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const getFormFactor_Out,
        };
        unsafe {
            instance.get(getFormFactor_Out::new)
        }
    }

    // optional .linkbot.robot.FormFactor value = 1;

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: FormFactor) {
        self.value = ::std::option::Option::Some(v);
    }

    pub fn get_value(&self) -> FormFactor {
        self.value.unwrap_or(FormFactor::I)
    }

    fn get_value_for_reflect(&self) -> &::std::option::Option<FormFactor> {
        &self.value
    }

    fn mut_value_for_reflect(&mut self) -> &mut ::std::option::Option<FormFactor> {
        &mut self.value
    }
}

impl ::protobuf::Message for getFormFactor_Out {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.value = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.value {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.value {
            os.write_enum(1, v.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for getFormFactor_Out {
    fn new() -> getFormFactor_Out {
        getFormFactor_Out::new()
    }

    fn descriptor_static(_: ::std::option::Option<getFormFactor_Out>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<FormFactor>>(
                    "value",
                    getFormFactor_Out::get_value_for_reflect,
                    getFormFactor_Out::mut_value_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<getFormFactor_Out>(
                    "getFormFactor_Out",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for getFormFactor_Out {
    fn clear(&mut self) {
        self.clear_value();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for getFormFactor_Out {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for getFormFactor_Out {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct getJointStates {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for getJointStates {}

impl getJointStates {
    pub fn new() -> getJointStates {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static getJointStates {
        static mut instance: ::protobuf::lazy::Lazy<getJointStates> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const getJointStates,
        };
        unsafe {
            instance.get(getJointStates::new)
        }
    }
}

impl ::protobuf::Message for getJointStates {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for getJointStates {
    fn new() -> getJointStates {
        getJointStates::new()
    }

    fn descriptor_static(_: ::std::option::Option<getJointStates>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<getJointStates>(
                    "getJointStates",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for getJointStates {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for getJointStates {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for getJointStates {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct getJointStates_In {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for getJointStates_In {}

impl getJointStates_In {
    pub fn new() -> getJointStates_In {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static getJointStates_In {
        static mut instance: ::protobuf::lazy::Lazy<getJointStates_In> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const getJointStates_In,
        };
        unsafe {
            instance.get(getJointStates_In::new)
        }
    }
}

impl ::protobuf::Message for getJointStates_In {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for getJointStates_In {
    fn new() -> getJointStates_In {
        getJointStates_In::new()
    }

    fn descriptor_static(_: ::std::option::Option<getJointStates_In>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<getJointStates_In>(
                    "getJointStates_In",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for getJointStates_In {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for getJointStates_In {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for getJointStates_In {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct getJointStates_Out {
    // message fields
    timestamp: ::std::option::Option<u32>,
    values: ::std::vec::Vec<JointState>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for getJointStates_Out {}

impl getJointStates_Out {
    pub fn new() -> getJointStates_Out {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static getJointStates_Out {
        static mut instance: ::protobuf::lazy::Lazy<getJointStates_Out> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const getJointStates_Out,
        };
        unsafe {
            instance.get(getJointStates_Out::new)
        }
    }

    // optional uint32 timestamp = 1;

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    pub fn get_timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }

    fn get_timestamp_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.timestamp
    }

    fn mut_timestamp_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.timestamp
    }

    // repeated .linkbot.robot.JointState values = 2;

    pub fn clear_values(&mut self) {
        self.values.clear();
    }

    // Param is passed by value, moved
    pub fn set_values(&mut self, v: ::std::vec::Vec<JointState>) {
        self.values = v;
    }

    // Mutable pointer to the field.
    pub fn mut_values(&mut self) -> &mut ::std::vec::Vec<JointState> {
        &mut self.values
    }

    // Take field
    pub fn take_values(&mut self) -> ::std::vec::Vec<JointState> {
        ::std::mem::replace(&mut self.values, ::std::vec::Vec::new())
    }

    pub fn get_values(&self) -> &[JointState] {
        &self.values
    }

    fn get_values_for_reflect(&self) -> &::std::vec::Vec<JointState> {
        &self.values
    }

    fn mut_values_for_reflect(&mut self) -> &mut ::std::vec::Vec<JointState> {
        &mut self.values
    }
}

impl ::protobuf::Message for getJointStates_Out {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.timestamp = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_enum_into(wire_type, is, &mut self.values)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.values.is_empty() {
            my_size += ::protobuf::rt::vec_packed_enum_size(2, &self.values);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.timestamp {
            os.write_uint32(1, v)?;
        }
        if !self.values.is_empty() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_enum_data_size(&self.values))?;
            for v in &self.values {
                os.write_enum_no_tag(v.value())?;
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for getJointStates_Out {
    fn new() -> getJointStates_Out {
        getJointStates_Out::new()
    }

    fn descriptor_static(_: ::std::option::Option<getJointStates_Out>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "timestamp",
                    getJointStates_Out::get_timestamp_for_reflect,
                    getJointStates_Out::mut_timestamp_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeEnum<JointState>>(
                    "values",
                    getJointStates_Out::get_values_for_reflect,
                    getJointStates_Out::mut_values_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<getJointStates_Out>(
                    "getJointStates_Out",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for getJointStates_Out {
    fn clear(&mut self) {
        self.clear_timestamp();
        self.clear_values();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for getJointStates_Out {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for getJointStates_Out {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct getLedColor {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for getLedColor {}

impl getLedColor {
    pub fn new() -> getLedColor {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static getLedColor {
        static mut instance: ::protobuf::lazy::Lazy<getLedColor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const getLedColor,
        };
        unsafe {
            instance.get(getLedColor::new)
        }
    }
}

impl ::protobuf::Message for getLedColor {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for getLedColor {
    fn new() -> getLedColor {
        getLedColor::new()
    }

    fn descriptor_static(_: ::std::option::Option<getLedColor>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<getLedColor>(
                    "getLedColor",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for getLedColor {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for getLedColor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for getLedColor {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct getLedColor_In {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for getLedColor_In {}

impl getLedColor_In {
    pub fn new() -> getLedColor_In {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static getLedColor_In {
        static mut instance: ::protobuf::lazy::Lazy<getLedColor_In> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const getLedColor_In,
        };
        unsafe {
            instance.get(getLedColor_In::new)
        }
    }
}

impl ::protobuf::Message for getLedColor_In {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for getLedColor_In {
    fn new() -> getLedColor_In {
        getLedColor_In::new()
    }

    fn descriptor_static(_: ::std::option::Option<getLedColor_In>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<getLedColor_In>(
                    "getLedColor_In",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for getLedColor_In {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for getLedColor_In {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for getLedColor_In {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct getLedColor_Out {
    // message fields
    value: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for getLedColor_Out {}

impl getLedColor_Out {
    pub fn new() -> getLedColor_Out {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static getLedColor_Out {
        static mut instance: ::protobuf::lazy::Lazy<getLedColor_Out> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const getLedColor_Out,
        };
        unsafe {
            instance.get(getLedColor_Out::new)
        }
    }

    // optional uint32 value = 1;

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: u32) {
        self.value = ::std::option::Option::Some(v);
    }

    pub fn get_value(&self) -> u32 {
        self.value.unwrap_or(0)
    }

    fn get_value_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.value
    }

    fn mut_value_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.value
    }
}

impl ::protobuf::Message for getLedColor_Out {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.value = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.value {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.value {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for getLedColor_Out {
    fn new() -> getLedColor_Out {
        getLedColor_Out::new()
    }

    fn descriptor_static(_: ::std::option::Option<getLedColor_Out>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "value",
                    getLedColor_Out::get_value_for_reflect,
                    getLedColor_Out::mut_value_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<getLedColor_Out>(
                    "getLedColor_Out",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for getLedColor_Out {
    fn clear(&mut self) {
        self.clear_value();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for getLedColor_Out {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for getLedColor_Out {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct getMotorControllerOmega {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for getMotorControllerOmega {}

impl getMotorControllerOmega {
    pub fn new() -> getMotorControllerOmega {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static getMotorControllerOmega {
        static mut instance: ::protobuf::lazy::Lazy<getMotorControllerOmega> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const getMotorControllerOmega,
        };
        unsafe {
            instance.get(getMotorControllerOmega::new)
        }
    }
}

impl ::protobuf::Message for getMotorControllerOmega {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for getMotorControllerOmega {
    fn new() -> getMotorControllerOmega {
        getMotorControllerOmega::new()
    }

    fn descriptor_static(_: ::std::option::Option<getMotorControllerOmega>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<getMotorControllerOmega>(
                    "getMotorControllerOmega",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for getMotorControllerOmega {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for getMotorControllerOmega {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for getMotorControllerOmega {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct getMotorControllerOmega_In {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for getMotorControllerOmega_In {}

impl getMotorControllerOmega_In {
    pub fn new() -> getMotorControllerOmega_In {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static getMotorControllerOmega_In {
        static mut instance: ::protobuf::lazy::Lazy<getMotorControllerOmega_In> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const getMotorControllerOmega_In,
        };
        unsafe {
            instance.get(getMotorControllerOmega_In::new)
        }
    }
}

impl ::protobuf::Message for getMotorControllerOmega_In {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for getMotorControllerOmega_In {
    fn new() -> getMotorControllerOmega_In {
        getMotorControllerOmega_In::new()
    }

    fn descriptor_static(_: ::std::option::Option<getMotorControllerOmega_In>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<getMotorControllerOmega_In>(
                    "getMotorControllerOmega_In",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for getMotorControllerOmega_In {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for getMotorControllerOmega_In {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for getMotorControllerOmega_In {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct getMotorControllerOmega_Out {
    // message fields
    values: ::std::vec::Vec<f32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for getMotorControllerOmega_Out {}

impl getMotorControllerOmega_Out {
    pub fn new() -> getMotorControllerOmega_Out {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static getMotorControllerOmega_Out {
        static mut instance: ::protobuf::lazy::Lazy<getMotorControllerOmega_Out> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const getMotorControllerOmega_Out,
        };
        unsafe {
            instance.get(getMotorControllerOmega_Out::new)
        }
    }

    // repeated float values = 1;

    pub fn clear_values(&mut self) {
        self.values.clear();
    }

    // Param is passed by value, moved
    pub fn set_values(&mut self, v: ::std::vec::Vec<f32>) {
        self.values = v;
    }

    // Mutable pointer to the field.
    pub fn mut_values(&mut self) -> &mut ::std::vec::Vec<f32> {
        &mut self.values
    }

    // Take field
    pub fn take_values(&mut self) -> ::std::vec::Vec<f32> {
        ::std::mem::replace(&mut self.values, ::std::vec::Vec::new())
    }

    pub fn get_values(&self) -> &[f32] {
        &self.values
    }

    fn get_values_for_reflect(&self) -> &::std::vec::Vec<f32> {
        &self.values
    }

    fn mut_values_for_reflect(&mut self) -> &mut ::std::vec::Vec<f32> {
        &mut self.values
    }
}

impl ::protobuf::Message for getMotorControllerOmega_Out {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_float_into(wire_type, is, &mut self.values)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.values.is_empty() {
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(self.values.len() as u32) + (self.values.len() * 4) as u32;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.values.is_empty() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32((self.values.len() * 4) as u32)?;
            for v in &self.values {
                os.write_float_no_tag(*v)?;
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for getMotorControllerOmega_Out {
    fn new() -> getMotorControllerOmega_Out {
        getMotorControllerOmega_Out::new()
    }

    fn descriptor_static(_: ::std::option::Option<getMotorControllerOmega_Out>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "values",
                    getMotorControllerOmega_Out::get_values_for_reflect,
                    getMotorControllerOmega_Out::mut_values_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<getMotorControllerOmega_Out>(
                    "getMotorControllerOmega_Out",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for getMotorControllerOmega_Out {
    fn clear(&mut self) {
        self.clear_values();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for getMotorControllerOmega_Out {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for getMotorControllerOmega_Out {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct getMotorControllerAlphaI {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for getMotorControllerAlphaI {}

impl getMotorControllerAlphaI {
    pub fn new() -> getMotorControllerAlphaI {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static getMotorControllerAlphaI {
        static mut instance: ::protobuf::lazy::Lazy<getMotorControllerAlphaI> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const getMotorControllerAlphaI,
        };
        unsafe {
            instance.get(getMotorControllerAlphaI::new)
        }
    }
}

impl ::protobuf::Message for getMotorControllerAlphaI {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for getMotorControllerAlphaI {
    fn new() -> getMotorControllerAlphaI {
        getMotorControllerAlphaI::new()
    }

    fn descriptor_static(_: ::std::option::Option<getMotorControllerAlphaI>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<getMotorControllerAlphaI>(
                    "getMotorControllerAlphaI",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for getMotorControllerAlphaI {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for getMotorControllerAlphaI {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for getMotorControllerAlphaI {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct getMotorControllerAlphaI_In {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for getMotorControllerAlphaI_In {}

impl getMotorControllerAlphaI_In {
    pub fn new() -> getMotorControllerAlphaI_In {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static getMotorControllerAlphaI_In {
        static mut instance: ::protobuf::lazy::Lazy<getMotorControllerAlphaI_In> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const getMotorControllerAlphaI_In,
        };
        unsafe {
            instance.get(getMotorControllerAlphaI_In::new)
        }
    }
}

impl ::protobuf::Message for getMotorControllerAlphaI_In {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for getMotorControllerAlphaI_In {
    fn new() -> getMotorControllerAlphaI_In {
        getMotorControllerAlphaI_In::new()
    }

    fn descriptor_static(_: ::std::option::Option<getMotorControllerAlphaI_In>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<getMotorControllerAlphaI_In>(
                    "getMotorControllerAlphaI_In",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for getMotorControllerAlphaI_In {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for getMotorControllerAlphaI_In {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for getMotorControllerAlphaI_In {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct getMotorControllerAlphaI_Out {
    // message fields
    values: ::std::vec::Vec<f32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for getMotorControllerAlphaI_Out {}

impl getMotorControllerAlphaI_Out {
    pub fn new() -> getMotorControllerAlphaI_Out {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static getMotorControllerAlphaI_Out {
        static mut instance: ::protobuf::lazy::Lazy<getMotorControllerAlphaI_Out> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const getMotorControllerAlphaI_Out,
        };
        unsafe {
            instance.get(getMotorControllerAlphaI_Out::new)
        }
    }

    // repeated float values = 1;

    pub fn clear_values(&mut self) {
        self.values.clear();
    }

    // Param is passed by value, moved
    pub fn set_values(&mut self, v: ::std::vec::Vec<f32>) {
        self.values = v;
    }

    // Mutable pointer to the field.
    pub fn mut_values(&mut self) -> &mut ::std::vec::Vec<f32> {
        &mut self.values
    }

    // Take field
    pub fn take_values(&mut self) -> ::std::vec::Vec<f32> {
        ::std::mem::replace(&mut self.values, ::std::vec::Vec::new())
    }

    pub fn get_values(&self) -> &[f32] {
        &self.values
    }

    fn get_values_for_reflect(&self) -> &::std::vec::Vec<f32> {
        &self.values
    }

    fn mut_values_for_reflect(&mut self) -> &mut ::std::vec::Vec<f32> {
        &mut self.values
    }
}

impl ::protobuf::Message for getMotorControllerAlphaI_Out {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_float_into(wire_type, is, &mut self.values)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.values.is_empty() {
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(self.values.len() as u32) + (self.values.len() * 4) as u32;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.values.is_empty() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32((self.values.len() * 4) as u32)?;
            for v in &self.values {
                os.write_float_no_tag(*v)?;
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for getMotorControllerAlphaI_Out {
    fn new() -> getMotorControllerAlphaI_Out {
        getMotorControllerAlphaI_Out::new()
    }

    fn descriptor_static(_: ::std::option::Option<getMotorControllerAlphaI_Out>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "values",
                    getMotorControllerAlphaI_Out::get_values_for_reflect,
                    getMotorControllerAlphaI_Out::mut_values_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<getMotorControllerAlphaI_Out>(
                    "getMotorControllerAlphaI_Out",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for getMotorControllerAlphaI_Out {
    fn clear(&mut self) {
        self.clear_values();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for getMotorControllerAlphaI_Out {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for getMotorControllerAlphaI_Out {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct getMotorControllerAlphaF {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for getMotorControllerAlphaF {}

impl getMotorControllerAlphaF {
    pub fn new() -> getMotorControllerAlphaF {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static getMotorControllerAlphaF {
        static mut instance: ::protobuf::lazy::Lazy<getMotorControllerAlphaF> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const getMotorControllerAlphaF,
        };
        unsafe {
            instance.get(getMotorControllerAlphaF::new)
        }
    }
}

impl ::protobuf::Message for getMotorControllerAlphaF {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for getMotorControllerAlphaF {
    fn new() -> getMotorControllerAlphaF {
        getMotorControllerAlphaF::new()
    }

    fn descriptor_static(_: ::std::option::Option<getMotorControllerAlphaF>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<getMotorControllerAlphaF>(
                    "getMotorControllerAlphaF",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for getMotorControllerAlphaF {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for getMotorControllerAlphaF {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for getMotorControllerAlphaF {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct getMotorControllerAlphaF_In {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for getMotorControllerAlphaF_In {}

impl getMotorControllerAlphaF_In {
    pub fn new() -> getMotorControllerAlphaF_In {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static getMotorControllerAlphaF_In {
        static mut instance: ::protobuf::lazy::Lazy<getMotorControllerAlphaF_In> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const getMotorControllerAlphaF_In,
        };
        unsafe {
            instance.get(getMotorControllerAlphaF_In::new)
        }
    }
}

impl ::protobuf::Message for getMotorControllerAlphaF_In {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for getMotorControllerAlphaF_In {
    fn new() -> getMotorControllerAlphaF_In {
        getMotorControllerAlphaF_In::new()
    }

    fn descriptor_static(_: ::std::option::Option<getMotorControllerAlphaF_In>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<getMotorControllerAlphaF_In>(
                    "getMotorControllerAlphaF_In",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for getMotorControllerAlphaF_In {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for getMotorControllerAlphaF_In {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for getMotorControllerAlphaF_In {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct getMotorControllerAlphaF_Out {
    // message fields
    values: ::std::vec::Vec<f32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for getMotorControllerAlphaF_Out {}

impl getMotorControllerAlphaF_Out {
    pub fn new() -> getMotorControllerAlphaF_Out {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static getMotorControllerAlphaF_Out {
        static mut instance: ::protobuf::lazy::Lazy<getMotorControllerAlphaF_Out> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const getMotorControllerAlphaF_Out,
        };
        unsafe {
            instance.get(getMotorControllerAlphaF_Out::new)
        }
    }

    // repeated float values = 1;

    pub fn clear_values(&mut self) {
        self.values.clear();
    }

    // Param is passed by value, moved
    pub fn set_values(&mut self, v: ::std::vec::Vec<f32>) {
        self.values = v;
    }

    // Mutable pointer to the field.
    pub fn mut_values(&mut self) -> &mut ::std::vec::Vec<f32> {
        &mut self.values
    }

    // Take field
    pub fn take_values(&mut self) -> ::std::vec::Vec<f32> {
        ::std::mem::replace(&mut self.values, ::std::vec::Vec::new())
    }

    pub fn get_values(&self) -> &[f32] {
        &self.values
    }

    fn get_values_for_reflect(&self) -> &::std::vec::Vec<f32> {
        &self.values
    }

    fn mut_values_for_reflect(&mut self) -> &mut ::std::vec::Vec<f32> {
        &mut self.values
    }
}

impl ::protobuf::Message for getMotorControllerAlphaF_Out {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_float_into(wire_type, is, &mut self.values)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.values.is_empty() {
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(self.values.len() as u32) + (self.values.len() * 4) as u32;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.values.is_empty() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32((self.values.len() * 4) as u32)?;
            for v in &self.values {
                os.write_float_no_tag(*v)?;
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for getMotorControllerAlphaF_Out {
    fn new() -> getMotorControllerAlphaF_Out {
        getMotorControllerAlphaF_Out::new()
    }

    fn descriptor_static(_: ::std::option::Option<getMotorControllerAlphaF_Out>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "values",
                    getMotorControllerAlphaF_Out::get_values_for_reflect,
                    getMotorControllerAlphaF_Out::mut_values_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<getMotorControllerAlphaF_Out>(
                    "getMotorControllerAlphaF_Out",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for getMotorControllerAlphaF_Out {
    fn clear(&mut self) {
        self.clear_values();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for getMotorControllerAlphaF_Out {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for getMotorControllerAlphaF_Out {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct getMotorControllerProportionalGain {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for getMotorControllerProportionalGain {}

impl getMotorControllerProportionalGain {
    pub fn new() -> getMotorControllerProportionalGain {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static getMotorControllerProportionalGain {
        static mut instance: ::protobuf::lazy::Lazy<getMotorControllerProportionalGain> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const getMotorControllerProportionalGain,
        };
        unsafe {
            instance.get(getMotorControllerProportionalGain::new)
        }
    }
}

impl ::protobuf::Message for getMotorControllerProportionalGain {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for getMotorControllerProportionalGain {
    fn new() -> getMotorControllerProportionalGain {
        getMotorControllerProportionalGain::new()
    }

    fn descriptor_static(_: ::std::option::Option<getMotorControllerProportionalGain>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<getMotorControllerProportionalGain>(
                    "getMotorControllerProportionalGain",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for getMotorControllerProportionalGain {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for getMotorControllerProportionalGain {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for getMotorControllerProportionalGain {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct getMotorControllerProportionalGain_In {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for getMotorControllerProportionalGain_In {}

impl getMotorControllerProportionalGain_In {
    pub fn new() -> getMotorControllerProportionalGain_In {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static getMotorControllerProportionalGain_In {
        static mut instance: ::protobuf::lazy::Lazy<getMotorControllerProportionalGain_In> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const getMotorControllerProportionalGain_In,
        };
        unsafe {
            instance.get(getMotorControllerProportionalGain_In::new)
        }
    }
}

impl ::protobuf::Message for getMotorControllerProportionalGain_In {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for getMotorControllerProportionalGain_In {
    fn new() -> getMotorControllerProportionalGain_In {
        getMotorControllerProportionalGain_In::new()
    }

    fn descriptor_static(_: ::std::option::Option<getMotorControllerProportionalGain_In>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<getMotorControllerProportionalGain_In>(
                    "getMotorControllerProportionalGain_In",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for getMotorControllerProportionalGain_In {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for getMotorControllerProportionalGain_In {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for getMotorControllerProportionalGain_In {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct getMotorControllerProportionalGain_Out {
    // message fields
    values: ::std::vec::Vec<f32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for getMotorControllerProportionalGain_Out {}

impl getMotorControllerProportionalGain_Out {
    pub fn new() -> getMotorControllerProportionalGain_Out {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static getMotorControllerProportionalGain_Out {
        static mut instance: ::protobuf::lazy::Lazy<getMotorControllerProportionalGain_Out> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const getMotorControllerProportionalGain_Out,
        };
        unsafe {
            instance.get(getMotorControllerProportionalGain_Out::new)
        }
    }

    // repeated float values = 1;

    pub fn clear_values(&mut self) {
        self.values.clear();
    }

    // Param is passed by value, moved
    pub fn set_values(&mut self, v: ::std::vec::Vec<f32>) {
        self.values = v;
    }

    // Mutable pointer to the field.
    pub fn mut_values(&mut self) -> &mut ::std::vec::Vec<f32> {
        &mut self.values
    }

    // Take field
    pub fn take_values(&mut self) -> ::std::vec::Vec<f32> {
        ::std::mem::replace(&mut self.values, ::std::vec::Vec::new())
    }

    pub fn get_values(&self) -> &[f32] {
        &self.values
    }

    fn get_values_for_reflect(&self) -> &::std::vec::Vec<f32> {
        &self.values
    }

    fn mut_values_for_reflect(&mut self) -> &mut ::std::vec::Vec<f32> {
        &mut self.values
    }
}

impl ::protobuf::Message for getMotorControllerProportionalGain_Out {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_float_into(wire_type, is, &mut self.values)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.values.is_empty() {
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(self.values.len() as u32) + (self.values.len() * 4) as u32;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.values.is_empty() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32((self.values.len() * 4) as u32)?;
            for v in &self.values {
                os.write_float_no_tag(*v)?;
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for getMotorControllerProportionalGain_Out {
    fn new() -> getMotorControllerProportionalGain_Out {
        getMotorControllerProportionalGain_Out::new()
    }

    fn descriptor_static(_: ::std::option::Option<getMotorControllerProportionalGain_Out>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "values",
                    getMotorControllerProportionalGain_Out::get_values_for_reflect,
                    getMotorControllerProportionalGain_Out::mut_values_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<getMotorControllerProportionalGain_Out>(
                    "getMotorControllerProportionalGain_Out",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for getMotorControllerProportionalGain_Out {
    fn clear(&mut self) {
        self.clear_values();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for getMotorControllerProportionalGain_Out {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for getMotorControllerProportionalGain_Out {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct getMotorControllerIntegratorGain {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for getMotorControllerIntegratorGain {}

impl getMotorControllerIntegratorGain {
    pub fn new() -> getMotorControllerIntegratorGain {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static getMotorControllerIntegratorGain {
        static mut instance: ::protobuf::lazy::Lazy<getMotorControllerIntegratorGain> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const getMotorControllerIntegratorGain,
        };
        unsafe {
            instance.get(getMotorControllerIntegratorGain::new)
        }
    }
}

impl ::protobuf::Message for getMotorControllerIntegratorGain {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for getMotorControllerIntegratorGain {
    fn new() -> getMotorControllerIntegratorGain {
        getMotorControllerIntegratorGain::new()
    }

    fn descriptor_static(_: ::std::option::Option<getMotorControllerIntegratorGain>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<getMotorControllerIntegratorGain>(
                    "getMotorControllerIntegratorGain",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for getMotorControllerIntegratorGain {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for getMotorControllerIntegratorGain {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for getMotorControllerIntegratorGain {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct getMotorControllerIntegratorGain_In {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for getMotorControllerIntegratorGain_In {}

impl getMotorControllerIntegratorGain_In {
    pub fn new() -> getMotorControllerIntegratorGain_In {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static getMotorControllerIntegratorGain_In {
        static mut instance: ::protobuf::lazy::Lazy<getMotorControllerIntegratorGain_In> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const getMotorControllerIntegratorGain_In,
        };
        unsafe {
            instance.get(getMotorControllerIntegratorGain_In::new)
        }
    }
}

impl ::protobuf::Message for getMotorControllerIntegratorGain_In {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for getMotorControllerIntegratorGain_In {
    fn new() -> getMotorControllerIntegratorGain_In {
        getMotorControllerIntegratorGain_In::new()
    }

    fn descriptor_static(_: ::std::option::Option<getMotorControllerIntegratorGain_In>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<getMotorControllerIntegratorGain_In>(
                    "getMotorControllerIntegratorGain_In",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for getMotorControllerIntegratorGain_In {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for getMotorControllerIntegratorGain_In {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for getMotorControllerIntegratorGain_In {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct getMotorControllerIntegratorGain_Out {
    // message fields
    values: ::std::vec::Vec<f32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for getMotorControllerIntegratorGain_Out {}

impl getMotorControllerIntegratorGain_Out {
    pub fn new() -> getMotorControllerIntegratorGain_Out {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static getMotorControllerIntegratorGain_Out {
        static mut instance: ::protobuf::lazy::Lazy<getMotorControllerIntegratorGain_Out> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const getMotorControllerIntegratorGain_Out,
        };
        unsafe {
            instance.get(getMotorControllerIntegratorGain_Out::new)
        }
    }

    // repeated float values = 1;

    pub fn clear_values(&mut self) {
        self.values.clear();
    }

    // Param is passed by value, moved
    pub fn set_values(&mut self, v: ::std::vec::Vec<f32>) {
        self.values = v;
    }

    // Mutable pointer to the field.
    pub fn mut_values(&mut self) -> &mut ::std::vec::Vec<f32> {
        &mut self.values
    }

    // Take field
    pub fn take_values(&mut self) -> ::std::vec::Vec<f32> {
        ::std::mem::replace(&mut self.values, ::std::vec::Vec::new())
    }

    pub fn get_values(&self) -> &[f32] {
        &self.values
    }

    fn get_values_for_reflect(&self) -> &::std::vec::Vec<f32> {
        &self.values
    }

    fn mut_values_for_reflect(&mut self) -> &mut ::std::vec::Vec<f32> {
        &mut self.values
    }
}

impl ::protobuf::Message for getMotorControllerIntegratorGain_Out {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_float_into(wire_type, is, &mut self.values)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.values.is_empty() {
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(self.values.len() as u32) + (self.values.len() * 4) as u32;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.values.is_empty() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32((self.values.len() * 4) as u32)?;
            for v in &self.values {
                os.write_float_no_tag(*v)?;
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for getMotorControllerIntegratorGain_Out {
    fn new() -> getMotorControllerIntegratorGain_Out {
        getMotorControllerIntegratorGain_Out::new()
    }

    fn descriptor_static(_: ::std::option::Option<getMotorControllerIntegratorGain_Out>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "values",
                    getMotorControllerIntegratorGain_Out::get_values_for_reflect,
                    getMotorControllerIntegratorGain_Out::mut_values_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<getMotorControllerIntegratorGain_Out>(
                    "getMotorControllerIntegratorGain_Out",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for getMotorControllerIntegratorGain_Out {
    fn clear(&mut self) {
        self.clear_values();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for getMotorControllerIntegratorGain_Out {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for getMotorControllerIntegratorGain_Out {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct getMotorControllerDerivativeGain {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for getMotorControllerDerivativeGain {}

impl getMotorControllerDerivativeGain {
    pub fn new() -> getMotorControllerDerivativeGain {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static getMotorControllerDerivativeGain {
        static mut instance: ::protobuf::lazy::Lazy<getMotorControllerDerivativeGain> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const getMotorControllerDerivativeGain,
        };
        unsafe {
            instance.get(getMotorControllerDerivativeGain::new)
        }
    }
}

impl ::protobuf::Message for getMotorControllerDerivativeGain {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for getMotorControllerDerivativeGain {
    fn new() -> getMotorControllerDerivativeGain {
        getMotorControllerDerivativeGain::new()
    }

    fn descriptor_static(_: ::std::option::Option<getMotorControllerDerivativeGain>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<getMotorControllerDerivativeGain>(
                    "getMotorControllerDerivativeGain",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for getMotorControllerDerivativeGain {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for getMotorControllerDerivativeGain {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for getMotorControllerDerivativeGain {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct getMotorControllerDerivativeGain_In {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for getMotorControllerDerivativeGain_In {}

impl getMotorControllerDerivativeGain_In {
    pub fn new() -> getMotorControllerDerivativeGain_In {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static getMotorControllerDerivativeGain_In {
        static mut instance: ::protobuf::lazy::Lazy<getMotorControllerDerivativeGain_In> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const getMotorControllerDerivativeGain_In,
        };
        unsafe {
            instance.get(getMotorControllerDerivativeGain_In::new)
        }
    }
}

impl ::protobuf::Message for getMotorControllerDerivativeGain_In {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for getMotorControllerDerivativeGain_In {
    fn new() -> getMotorControllerDerivativeGain_In {
        getMotorControllerDerivativeGain_In::new()
    }

    fn descriptor_static(_: ::std::option::Option<getMotorControllerDerivativeGain_In>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<getMotorControllerDerivativeGain_In>(
                    "getMotorControllerDerivativeGain_In",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for getMotorControllerDerivativeGain_In {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for getMotorControllerDerivativeGain_In {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for getMotorControllerDerivativeGain_In {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct getMotorControllerDerivativeGain_Out {
    // message fields
    values: ::std::vec::Vec<f32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for getMotorControllerDerivativeGain_Out {}

impl getMotorControllerDerivativeGain_Out {
    pub fn new() -> getMotorControllerDerivativeGain_Out {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static getMotorControllerDerivativeGain_Out {
        static mut instance: ::protobuf::lazy::Lazy<getMotorControllerDerivativeGain_Out> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const getMotorControllerDerivativeGain_Out,
        };
        unsafe {
            instance.get(getMotorControllerDerivativeGain_Out::new)
        }
    }

    // repeated float values = 1;

    pub fn clear_values(&mut self) {
        self.values.clear();
    }

    // Param is passed by value, moved
    pub fn set_values(&mut self, v: ::std::vec::Vec<f32>) {
        self.values = v;
    }

    // Mutable pointer to the field.
    pub fn mut_values(&mut self) -> &mut ::std::vec::Vec<f32> {
        &mut self.values
    }

    // Take field
    pub fn take_values(&mut self) -> ::std::vec::Vec<f32> {
        ::std::mem::replace(&mut self.values, ::std::vec::Vec::new())
    }

    pub fn get_values(&self) -> &[f32] {
        &self.values
    }

    fn get_values_for_reflect(&self) -> &::std::vec::Vec<f32> {
        &self.values
    }

    fn mut_values_for_reflect(&mut self) -> &mut ::std::vec::Vec<f32> {
        &mut self.values
    }
}

impl ::protobuf::Message for getMotorControllerDerivativeGain_Out {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_float_into(wire_type, is, &mut self.values)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.values.is_empty() {
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(self.values.len() as u32) + (self.values.len() * 4) as u32;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.values.is_empty() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32((self.values.len() * 4) as u32)?;
            for v in &self.values {
                os.write_float_no_tag(*v)?;
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for getMotorControllerDerivativeGain_Out {
    fn new() -> getMotorControllerDerivativeGain_Out {
        getMotorControllerDerivativeGain_Out::new()
    }

    fn descriptor_static(_: ::std::option::Option<getMotorControllerDerivativeGain_Out>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "values",
                    getMotorControllerDerivativeGain_Out::get_values_for_reflect,
                    getMotorControllerDerivativeGain_Out::mut_values_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<getMotorControllerDerivativeGain_Out>(
                    "getMotorControllerDerivativeGain_Out",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for getMotorControllerDerivativeGain_Out {
    fn clear(&mut self) {
        self.clear_values();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for getMotorControllerDerivativeGain_Out {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for getMotorControllerDerivativeGain_Out {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct getMotorControllerSafetyThreshold {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for getMotorControllerSafetyThreshold {}

impl getMotorControllerSafetyThreshold {
    pub fn new() -> getMotorControllerSafetyThreshold {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static getMotorControllerSafetyThreshold {
        static mut instance: ::protobuf::lazy::Lazy<getMotorControllerSafetyThreshold> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const getMotorControllerSafetyThreshold,
        };
        unsafe {
            instance.get(getMotorControllerSafetyThreshold::new)
        }
    }
}

impl ::protobuf::Message for getMotorControllerSafetyThreshold {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for getMotorControllerSafetyThreshold {
    fn new() -> getMotorControllerSafetyThreshold {
        getMotorControllerSafetyThreshold::new()
    }

    fn descriptor_static(_: ::std::option::Option<getMotorControllerSafetyThreshold>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<getMotorControllerSafetyThreshold>(
                    "getMotorControllerSafetyThreshold",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for getMotorControllerSafetyThreshold {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for getMotorControllerSafetyThreshold {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for getMotorControllerSafetyThreshold {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct getMotorControllerSafetyThreshold_In {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for getMotorControllerSafetyThreshold_In {}

impl getMotorControllerSafetyThreshold_In {
    pub fn new() -> getMotorControllerSafetyThreshold_In {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static getMotorControllerSafetyThreshold_In {
        static mut instance: ::protobuf::lazy::Lazy<getMotorControllerSafetyThreshold_In> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const getMotorControllerSafetyThreshold_In,
        };
        unsafe {
            instance.get(getMotorControllerSafetyThreshold_In::new)
        }
    }
}

impl ::protobuf::Message for getMotorControllerSafetyThreshold_In {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for getMotorControllerSafetyThreshold_In {
    fn new() -> getMotorControllerSafetyThreshold_In {
        getMotorControllerSafetyThreshold_In::new()
    }

    fn descriptor_static(_: ::std::option::Option<getMotorControllerSafetyThreshold_In>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<getMotorControllerSafetyThreshold_In>(
                    "getMotorControllerSafetyThreshold_In",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for getMotorControllerSafetyThreshold_In {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for getMotorControllerSafetyThreshold_In {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for getMotorControllerSafetyThreshold_In {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct getMotorControllerSafetyThreshold_Out {
    // message fields
    values: ::std::vec::Vec<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for getMotorControllerSafetyThreshold_Out {}

impl getMotorControllerSafetyThreshold_Out {
    pub fn new() -> getMotorControllerSafetyThreshold_Out {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static getMotorControllerSafetyThreshold_Out {
        static mut instance: ::protobuf::lazy::Lazy<getMotorControllerSafetyThreshold_Out> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const getMotorControllerSafetyThreshold_Out,
        };
        unsafe {
            instance.get(getMotorControllerSafetyThreshold_Out::new)
        }
    }

    // repeated uint32 values = 1;

    pub fn clear_values(&mut self) {
        self.values.clear();
    }

    // Param is passed by value, moved
    pub fn set_values(&mut self, v: ::std::vec::Vec<u32>) {
        self.values = v;
    }

    // Mutable pointer to the field.
    pub fn mut_values(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.values
    }

    // Take field
    pub fn take_values(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.values, ::std::vec::Vec::new())
    }

    pub fn get_values(&self) -> &[u32] {
        &self.values
    }

    fn get_values_for_reflect(&self) -> &::std::vec::Vec<u32> {
        &self.values
    }

    fn mut_values_for_reflect(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.values
    }
}

impl ::protobuf::Message for getMotorControllerSafetyThreshold_Out {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.values)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.values.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_size(1, &self.values);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.values.is_empty() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_varint_data_size(&self.values))?;
            for v in &self.values {
                os.write_uint32_no_tag(*v)?;
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for getMotorControllerSafetyThreshold_Out {
    fn new() -> getMotorControllerSafetyThreshold_Out {
        getMotorControllerSafetyThreshold_Out::new()
    }

    fn descriptor_static(_: ::std::option::Option<getMotorControllerSafetyThreshold_Out>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "values",
                    getMotorControllerSafetyThreshold_Out::get_values_for_reflect,
                    getMotorControllerSafetyThreshold_Out::mut_values_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<getMotorControllerSafetyThreshold_Out>(
                    "getMotorControllerSafetyThreshold_Out",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for getMotorControllerSafetyThreshold_Out {
    fn clear(&mut self) {
        self.clear_values();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for getMotorControllerSafetyThreshold_Out {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for getMotorControllerSafetyThreshold_Out {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct getMotorControllerSafetyAngle {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for getMotorControllerSafetyAngle {}

impl getMotorControllerSafetyAngle {
    pub fn new() -> getMotorControllerSafetyAngle {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static getMotorControllerSafetyAngle {
        static mut instance: ::protobuf::lazy::Lazy<getMotorControllerSafetyAngle> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const getMotorControllerSafetyAngle,
        };
        unsafe {
            instance.get(getMotorControllerSafetyAngle::new)
        }
    }
}

impl ::protobuf::Message for getMotorControllerSafetyAngle {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for getMotorControllerSafetyAngle {
    fn new() -> getMotorControllerSafetyAngle {
        getMotorControllerSafetyAngle::new()
    }

    fn descriptor_static(_: ::std::option::Option<getMotorControllerSafetyAngle>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<getMotorControllerSafetyAngle>(
                    "getMotorControllerSafetyAngle",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for getMotorControllerSafetyAngle {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for getMotorControllerSafetyAngle {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for getMotorControllerSafetyAngle {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct getMotorControllerSafetyAngle_In {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for getMotorControllerSafetyAngle_In {}

impl getMotorControllerSafetyAngle_In {
    pub fn new() -> getMotorControllerSafetyAngle_In {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static getMotorControllerSafetyAngle_In {
        static mut instance: ::protobuf::lazy::Lazy<getMotorControllerSafetyAngle_In> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const getMotorControllerSafetyAngle_In,
        };
        unsafe {
            instance.get(getMotorControllerSafetyAngle_In::new)
        }
    }
}

impl ::protobuf::Message for getMotorControllerSafetyAngle_In {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for getMotorControllerSafetyAngle_In {
    fn new() -> getMotorControllerSafetyAngle_In {
        getMotorControllerSafetyAngle_In::new()
    }

    fn descriptor_static(_: ::std::option::Option<getMotorControllerSafetyAngle_In>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<getMotorControllerSafetyAngle_In>(
                    "getMotorControllerSafetyAngle_In",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for getMotorControllerSafetyAngle_In {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for getMotorControllerSafetyAngle_In {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for getMotorControllerSafetyAngle_In {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct getMotorControllerSafetyAngle_Out {
    // message fields
    values: ::std::vec::Vec<f32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for getMotorControllerSafetyAngle_Out {}

impl getMotorControllerSafetyAngle_Out {
    pub fn new() -> getMotorControllerSafetyAngle_Out {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static getMotorControllerSafetyAngle_Out {
        static mut instance: ::protobuf::lazy::Lazy<getMotorControllerSafetyAngle_Out> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const getMotorControllerSafetyAngle_Out,
        };
        unsafe {
            instance.get(getMotorControllerSafetyAngle_Out::new)
        }
    }

    // repeated float values = 1;

    pub fn clear_values(&mut self) {
        self.values.clear();
    }

    // Param is passed by value, moved
    pub fn set_values(&mut self, v: ::std::vec::Vec<f32>) {
        self.values = v;
    }

    // Mutable pointer to the field.
    pub fn mut_values(&mut self) -> &mut ::std::vec::Vec<f32> {
        &mut self.values
    }

    // Take field
    pub fn take_values(&mut self) -> ::std::vec::Vec<f32> {
        ::std::mem::replace(&mut self.values, ::std::vec::Vec::new())
    }

    pub fn get_values(&self) -> &[f32] {
        &self.values
    }

    fn get_values_for_reflect(&self) -> &::std::vec::Vec<f32> {
        &self.values
    }

    fn mut_values_for_reflect(&mut self) -> &mut ::std::vec::Vec<f32> {
        &mut self.values
    }
}

impl ::protobuf::Message for getMotorControllerSafetyAngle_Out {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_float_into(wire_type, is, &mut self.values)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.values.is_empty() {
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(self.values.len() as u32) + (self.values.len() * 4) as u32;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.values.is_empty() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32((self.values.len() * 4) as u32)?;
            for v in &self.values {
                os.write_float_no_tag(*v)?;
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for getMotorControllerSafetyAngle_Out {
    fn new() -> getMotorControllerSafetyAngle_Out {
        getMotorControllerSafetyAngle_Out::new()
    }

    fn descriptor_static(_: ::std::option::Option<getMotorControllerSafetyAngle_Out>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "values",
                    getMotorControllerSafetyAngle_Out::get_values_for_reflect,
                    getMotorControllerSafetyAngle_Out::mut_values_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<getMotorControllerSafetyAngle_Out>(
                    "getMotorControllerSafetyAngle_Out",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for getMotorControllerSafetyAngle_Out {
    fn clear(&mut self) {
        self.clear_values();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for getMotorControllerSafetyAngle_Out {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for getMotorControllerSafetyAngle_Out {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct setMotorControllerOmega {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for setMotorControllerOmega {}

impl setMotorControllerOmega {
    pub fn new() -> setMotorControllerOmega {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static setMotorControllerOmega {
        static mut instance: ::protobuf::lazy::Lazy<setMotorControllerOmega> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const setMotorControllerOmega,
        };
        unsafe {
            instance.get(setMotorControllerOmega::new)
        }
    }
}

impl ::protobuf::Message for setMotorControllerOmega {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for setMotorControllerOmega {
    fn new() -> setMotorControllerOmega {
        setMotorControllerOmega::new()
    }

    fn descriptor_static(_: ::std::option::Option<setMotorControllerOmega>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<setMotorControllerOmega>(
                    "setMotorControllerOmega",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for setMotorControllerOmega {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for setMotorControllerOmega {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for setMotorControllerOmega {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct setMotorControllerOmega_In {
    // message fields
    mask: ::std::option::Option<u32>,
    values: ::std::vec::Vec<f32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for setMotorControllerOmega_In {}

impl setMotorControllerOmega_In {
    pub fn new() -> setMotorControllerOmega_In {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static setMotorControllerOmega_In {
        static mut instance: ::protobuf::lazy::Lazy<setMotorControllerOmega_In> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const setMotorControllerOmega_In,
        };
        unsafe {
            instance.get(setMotorControllerOmega_In::new)
        }
    }

    // optional uint32 mask = 1;

    pub fn clear_mask(&mut self) {
        self.mask = ::std::option::Option::None;
    }

    pub fn has_mask(&self) -> bool {
        self.mask.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mask(&mut self, v: u32) {
        self.mask = ::std::option::Option::Some(v);
    }

    pub fn get_mask(&self) -> u32 {
        self.mask.unwrap_or(0)
    }

    fn get_mask_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.mask
    }

    fn mut_mask_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.mask
    }

    // repeated float values = 2;

    pub fn clear_values(&mut self) {
        self.values.clear();
    }

    // Param is passed by value, moved
    pub fn set_values(&mut self, v: ::std::vec::Vec<f32>) {
        self.values = v;
    }

    // Mutable pointer to the field.
    pub fn mut_values(&mut self) -> &mut ::std::vec::Vec<f32> {
        &mut self.values
    }

    // Take field
    pub fn take_values(&mut self) -> ::std::vec::Vec<f32> {
        ::std::mem::replace(&mut self.values, ::std::vec::Vec::new())
    }

    pub fn get_values(&self) -> &[f32] {
        &self.values
    }

    fn get_values_for_reflect(&self) -> &::std::vec::Vec<f32> {
        &self.values
    }

    fn mut_values_for_reflect(&mut self) -> &mut ::std::vec::Vec<f32> {
        &mut self.values
    }
}

impl ::protobuf::Message for setMotorControllerOmega_In {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.mask = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_float_into(wire_type, is, &mut self.values)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.mask {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.values.is_empty() {
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(self.values.len() as u32) + (self.values.len() * 4) as u32;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.mask {
            os.write_uint32(1, v)?;
        }
        if !self.values.is_empty() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32((self.values.len() * 4) as u32)?;
            for v in &self.values {
                os.write_float_no_tag(*v)?;
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for setMotorControllerOmega_In {
    fn new() -> setMotorControllerOmega_In {
        setMotorControllerOmega_In::new()
    }

    fn descriptor_static(_: ::std::option::Option<setMotorControllerOmega_In>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "mask",
                    setMotorControllerOmega_In::get_mask_for_reflect,
                    setMotorControllerOmega_In::mut_mask_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "values",
                    setMotorControllerOmega_In::get_values_for_reflect,
                    setMotorControllerOmega_In::mut_values_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<setMotorControllerOmega_In>(
                    "setMotorControllerOmega_In",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for setMotorControllerOmega_In {
    fn clear(&mut self) {
        self.clear_mask();
        self.clear_values();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for setMotorControllerOmega_In {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for setMotorControllerOmega_In {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct setMotorControllerOmega_Out {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for setMotorControllerOmega_Out {}

impl setMotorControllerOmega_Out {
    pub fn new() -> setMotorControllerOmega_Out {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static setMotorControllerOmega_Out {
        static mut instance: ::protobuf::lazy::Lazy<setMotorControllerOmega_Out> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const setMotorControllerOmega_Out,
        };
        unsafe {
            instance.get(setMotorControllerOmega_Out::new)
        }
    }
}

impl ::protobuf::Message for setMotorControllerOmega_Out {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for setMotorControllerOmega_Out {
    fn new() -> setMotorControllerOmega_Out {
        setMotorControllerOmega_Out::new()
    }

    fn descriptor_static(_: ::std::option::Option<setMotorControllerOmega_Out>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<setMotorControllerOmega_Out>(
                    "setMotorControllerOmega_Out",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for setMotorControllerOmega_Out {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for setMotorControllerOmega_Out {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for setMotorControllerOmega_Out {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct setMotorControllerAlphaI {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for setMotorControllerAlphaI {}

impl setMotorControllerAlphaI {
    pub fn new() -> setMotorControllerAlphaI {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static setMotorControllerAlphaI {
        static mut instance: ::protobuf::lazy::Lazy<setMotorControllerAlphaI> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const setMotorControllerAlphaI,
        };
        unsafe {
            instance.get(setMotorControllerAlphaI::new)
        }
    }
}

impl ::protobuf::Message for setMotorControllerAlphaI {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for setMotorControllerAlphaI {
    fn new() -> setMotorControllerAlphaI {
        setMotorControllerAlphaI::new()
    }

    fn descriptor_static(_: ::std::option::Option<setMotorControllerAlphaI>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<setMotorControllerAlphaI>(
                    "setMotorControllerAlphaI",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for setMotorControllerAlphaI {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for setMotorControllerAlphaI {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for setMotorControllerAlphaI {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct setMotorControllerAlphaI_In {
    // message fields
    mask: ::std::option::Option<u32>,
    values: ::std::vec::Vec<f32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for setMotorControllerAlphaI_In {}

impl setMotorControllerAlphaI_In {
    pub fn new() -> setMotorControllerAlphaI_In {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static setMotorControllerAlphaI_In {
        static mut instance: ::protobuf::lazy::Lazy<setMotorControllerAlphaI_In> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const setMotorControllerAlphaI_In,
        };
        unsafe {
            instance.get(setMotorControllerAlphaI_In::new)
        }
    }

    // optional uint32 mask = 1;

    pub fn clear_mask(&mut self) {
        self.mask = ::std::option::Option::None;
    }

    pub fn has_mask(&self) -> bool {
        self.mask.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mask(&mut self, v: u32) {
        self.mask = ::std::option::Option::Some(v);
    }

    pub fn get_mask(&self) -> u32 {
        self.mask.unwrap_or(0)
    }

    fn get_mask_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.mask
    }

    fn mut_mask_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.mask
    }

    // repeated float values = 2;

    pub fn clear_values(&mut self) {
        self.values.clear();
    }

    // Param is passed by value, moved
    pub fn set_values(&mut self, v: ::std::vec::Vec<f32>) {
        self.values = v;
    }

    // Mutable pointer to the field.
    pub fn mut_values(&mut self) -> &mut ::std::vec::Vec<f32> {
        &mut self.values
    }

    // Take field
    pub fn take_values(&mut self) -> ::std::vec::Vec<f32> {
        ::std::mem::replace(&mut self.values, ::std::vec::Vec::new())
    }

    pub fn get_values(&self) -> &[f32] {
        &self.values
    }

    fn get_values_for_reflect(&self) -> &::std::vec::Vec<f32> {
        &self.values
    }

    fn mut_values_for_reflect(&mut self) -> &mut ::std::vec::Vec<f32> {
        &mut self.values
    }
}

impl ::protobuf::Message for setMotorControllerAlphaI_In {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.mask = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_float_into(wire_type, is, &mut self.values)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.mask {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.values.is_empty() {
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(self.values.len() as u32) + (self.values.len() * 4) as u32;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.mask {
            os.write_uint32(1, v)?;
        }
        if !self.values.is_empty() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32((self.values.len() * 4) as u32)?;
            for v in &self.values {
                os.write_float_no_tag(*v)?;
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for setMotorControllerAlphaI_In {
    fn new() -> setMotorControllerAlphaI_In {
        setMotorControllerAlphaI_In::new()
    }

    fn descriptor_static(_: ::std::option::Option<setMotorControllerAlphaI_In>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "mask",
                    setMotorControllerAlphaI_In::get_mask_for_reflect,
                    setMotorControllerAlphaI_In::mut_mask_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "values",
                    setMotorControllerAlphaI_In::get_values_for_reflect,
                    setMotorControllerAlphaI_In::mut_values_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<setMotorControllerAlphaI_In>(
                    "setMotorControllerAlphaI_In",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for setMotorControllerAlphaI_In {
    fn clear(&mut self) {
        self.clear_mask();
        self.clear_values();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for setMotorControllerAlphaI_In {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for setMotorControllerAlphaI_In {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct setMotorControllerAlphaI_Out {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for setMotorControllerAlphaI_Out {}

impl setMotorControllerAlphaI_Out {
    pub fn new() -> setMotorControllerAlphaI_Out {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static setMotorControllerAlphaI_Out {
        static mut instance: ::protobuf::lazy::Lazy<setMotorControllerAlphaI_Out> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const setMotorControllerAlphaI_Out,
        };
        unsafe {
            instance.get(setMotorControllerAlphaI_Out::new)
        }
    }
}

impl ::protobuf::Message for setMotorControllerAlphaI_Out {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for setMotorControllerAlphaI_Out {
    fn new() -> setMotorControllerAlphaI_Out {
        setMotorControllerAlphaI_Out::new()
    }

    fn descriptor_static(_: ::std::option::Option<setMotorControllerAlphaI_Out>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<setMotorControllerAlphaI_Out>(
                    "setMotorControllerAlphaI_Out",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for setMotorControllerAlphaI_Out {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for setMotorControllerAlphaI_Out {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for setMotorControllerAlphaI_Out {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct setMotorControllerAlphaF {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for setMotorControllerAlphaF {}

impl setMotorControllerAlphaF {
    pub fn new() -> setMotorControllerAlphaF {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static setMotorControllerAlphaF {
        static mut instance: ::protobuf::lazy::Lazy<setMotorControllerAlphaF> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const setMotorControllerAlphaF,
        };
        unsafe {
            instance.get(setMotorControllerAlphaF::new)
        }
    }
}

impl ::protobuf::Message for setMotorControllerAlphaF {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for setMotorControllerAlphaF {
    fn new() -> setMotorControllerAlphaF {
        setMotorControllerAlphaF::new()
    }

    fn descriptor_static(_: ::std::option::Option<setMotorControllerAlphaF>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<setMotorControllerAlphaF>(
                    "setMotorControllerAlphaF",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for setMotorControllerAlphaF {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for setMotorControllerAlphaF {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for setMotorControllerAlphaF {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct setMotorControllerAlphaF_In {
    // message fields
    mask: ::std::option::Option<u32>,
    values: ::std::vec::Vec<f32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for setMotorControllerAlphaF_In {}

impl setMotorControllerAlphaF_In {
    pub fn new() -> setMotorControllerAlphaF_In {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static setMotorControllerAlphaF_In {
        static mut instance: ::protobuf::lazy::Lazy<setMotorControllerAlphaF_In> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const setMotorControllerAlphaF_In,
        };
        unsafe {
            instance.get(setMotorControllerAlphaF_In::new)
        }
    }

    // optional uint32 mask = 1;

    pub fn clear_mask(&mut self) {
        self.mask = ::std::option::Option::None;
    }

    pub fn has_mask(&self) -> bool {
        self.mask.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mask(&mut self, v: u32) {
        self.mask = ::std::option::Option::Some(v);
    }

    pub fn get_mask(&self) -> u32 {
        self.mask.unwrap_or(0)
    }

    fn get_mask_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.mask
    }

    fn mut_mask_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.mask
    }

    // repeated float values = 2;

    pub fn clear_values(&mut self) {
        self.values.clear();
    }

    // Param is passed by value, moved
    pub fn set_values(&mut self, v: ::std::vec::Vec<f32>) {
        self.values = v;
    }

    // Mutable pointer to the field.
    pub fn mut_values(&mut self) -> &mut ::std::vec::Vec<f32> {
        &mut self.values
    }

    // Take field
    pub fn take_values(&mut self) -> ::std::vec::Vec<f32> {
        ::std::mem::replace(&mut self.values, ::std::vec::Vec::new())
    }

    pub fn get_values(&self) -> &[f32] {
        &self.values
    }

    fn get_values_for_reflect(&self) -> &::std::vec::Vec<f32> {
        &self.values
    }

    fn mut_values_for_reflect(&mut self) -> &mut ::std::vec::Vec<f32> {
        &mut self.values
    }
}

impl ::protobuf::Message for setMotorControllerAlphaF_In {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.mask = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_float_into(wire_type, is, &mut self.values)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.mask {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.values.is_empty() {
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(self.values.len() as u32) + (self.values.len() * 4) as u32;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.mask {
            os.write_uint32(1, v)?;
        }
        if !self.values.is_empty() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32((self.values.len() * 4) as u32)?;
            for v in &self.values {
                os.write_float_no_tag(*v)?;
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for setMotorControllerAlphaF_In {
    fn new() -> setMotorControllerAlphaF_In {
        setMotorControllerAlphaF_In::new()
    }

    fn descriptor_static(_: ::std::option::Option<setMotorControllerAlphaF_In>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "mask",
                    setMotorControllerAlphaF_In::get_mask_for_reflect,
                    setMotorControllerAlphaF_In::mut_mask_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "values",
                    setMotorControllerAlphaF_In::get_values_for_reflect,
                    setMotorControllerAlphaF_In::mut_values_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<setMotorControllerAlphaF_In>(
                    "setMotorControllerAlphaF_In",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for setMotorControllerAlphaF_In {
    fn clear(&mut self) {
        self.clear_mask();
        self.clear_values();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for setMotorControllerAlphaF_In {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for setMotorControllerAlphaF_In {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct setMotorControllerAlphaF_Out {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for setMotorControllerAlphaF_Out {}

impl setMotorControllerAlphaF_Out {
    pub fn new() -> setMotorControllerAlphaF_Out {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static setMotorControllerAlphaF_Out {
        static mut instance: ::protobuf::lazy::Lazy<setMotorControllerAlphaF_Out> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const setMotorControllerAlphaF_Out,
        };
        unsafe {
            instance.get(setMotorControllerAlphaF_Out::new)
        }
    }
}

impl ::protobuf::Message for setMotorControllerAlphaF_Out {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for setMotorControllerAlphaF_Out {
    fn new() -> setMotorControllerAlphaF_Out {
        setMotorControllerAlphaF_Out::new()
    }

    fn descriptor_static(_: ::std::option::Option<setMotorControllerAlphaF_Out>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<setMotorControllerAlphaF_Out>(
                    "setMotorControllerAlphaF_Out",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for setMotorControllerAlphaF_Out {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for setMotorControllerAlphaF_Out {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for setMotorControllerAlphaF_Out {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct setMotorControllerProportionalGain {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for setMotorControllerProportionalGain {}

impl setMotorControllerProportionalGain {
    pub fn new() -> setMotorControllerProportionalGain {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static setMotorControllerProportionalGain {
        static mut instance: ::protobuf::lazy::Lazy<setMotorControllerProportionalGain> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const setMotorControllerProportionalGain,
        };
        unsafe {
            instance.get(setMotorControllerProportionalGain::new)
        }
    }
}

impl ::protobuf::Message for setMotorControllerProportionalGain {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for setMotorControllerProportionalGain {
    fn new() -> setMotorControllerProportionalGain {
        setMotorControllerProportionalGain::new()
    }

    fn descriptor_static(_: ::std::option::Option<setMotorControllerProportionalGain>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<setMotorControllerProportionalGain>(
                    "setMotorControllerProportionalGain",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for setMotorControllerProportionalGain {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for setMotorControllerProportionalGain {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for setMotorControllerProportionalGain {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct setMotorControllerProportionalGain_In {
    // message fields
    mask: ::std::option::Option<u32>,
    values: ::std::vec::Vec<f32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for setMotorControllerProportionalGain_In {}

impl setMotorControllerProportionalGain_In {
    pub fn new() -> setMotorControllerProportionalGain_In {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static setMotorControllerProportionalGain_In {
        static mut instance: ::protobuf::lazy::Lazy<setMotorControllerProportionalGain_In> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const setMotorControllerProportionalGain_In,
        };
        unsafe {
            instance.get(setMotorControllerProportionalGain_In::new)
        }
    }

    // optional uint32 mask = 1;

    pub fn clear_mask(&mut self) {
        self.mask = ::std::option::Option::None;
    }

    pub fn has_mask(&self) -> bool {
        self.mask.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mask(&mut self, v: u32) {
        self.mask = ::std::option::Option::Some(v);
    }

    pub fn get_mask(&self) -> u32 {
        self.mask.unwrap_or(0)
    }

    fn get_mask_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.mask
    }

    fn mut_mask_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.mask
    }

    // repeated float values = 2;

    pub fn clear_values(&mut self) {
        self.values.clear();
    }

    // Param is passed by value, moved
    pub fn set_values(&mut self, v: ::std::vec::Vec<f32>) {
        self.values = v;
    }

    // Mutable pointer to the field.
    pub fn mut_values(&mut self) -> &mut ::std::vec::Vec<f32> {
        &mut self.values
    }

    // Take field
    pub fn take_values(&mut self) -> ::std::vec::Vec<f32> {
        ::std::mem::replace(&mut self.values, ::std::vec::Vec::new())
    }

    pub fn get_values(&self) -> &[f32] {
        &self.values
    }

    fn get_values_for_reflect(&self) -> &::std::vec::Vec<f32> {
        &self.values
    }

    fn mut_values_for_reflect(&mut self) -> &mut ::std::vec::Vec<f32> {
        &mut self.values
    }
}

impl ::protobuf::Message for setMotorControllerProportionalGain_In {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.mask = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_float_into(wire_type, is, &mut self.values)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.mask {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.values.is_empty() {
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(self.values.len() as u32) + (self.values.len() * 4) as u32;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.mask {
            os.write_uint32(1, v)?;
        }
        if !self.values.is_empty() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32((self.values.len() * 4) as u32)?;
            for v in &self.values {
                os.write_float_no_tag(*v)?;
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for setMotorControllerProportionalGain_In {
    fn new() -> setMotorControllerProportionalGain_In {
        setMotorControllerProportionalGain_In::new()
    }

    fn descriptor_static(_: ::std::option::Option<setMotorControllerProportionalGain_In>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "mask",
                    setMotorControllerProportionalGain_In::get_mask_for_reflect,
                    setMotorControllerProportionalGain_In::mut_mask_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "values",
                    setMotorControllerProportionalGain_In::get_values_for_reflect,
                    setMotorControllerProportionalGain_In::mut_values_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<setMotorControllerProportionalGain_In>(
                    "setMotorControllerProportionalGain_In",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for setMotorControllerProportionalGain_In {
    fn clear(&mut self) {
        self.clear_mask();
        self.clear_values();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for setMotorControllerProportionalGain_In {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for setMotorControllerProportionalGain_In {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct setMotorControllerProportionalGain_Out {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for setMotorControllerProportionalGain_Out {}

impl setMotorControllerProportionalGain_Out {
    pub fn new() -> setMotorControllerProportionalGain_Out {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static setMotorControllerProportionalGain_Out {
        static mut instance: ::protobuf::lazy::Lazy<setMotorControllerProportionalGain_Out> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const setMotorControllerProportionalGain_Out,
        };
        unsafe {
            instance.get(setMotorControllerProportionalGain_Out::new)
        }
    }
}

impl ::protobuf::Message for setMotorControllerProportionalGain_Out {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for setMotorControllerProportionalGain_Out {
    fn new() -> setMotorControllerProportionalGain_Out {
        setMotorControllerProportionalGain_Out::new()
    }

    fn descriptor_static(_: ::std::option::Option<setMotorControllerProportionalGain_Out>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<setMotorControllerProportionalGain_Out>(
                    "setMotorControllerProportionalGain_Out",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for setMotorControllerProportionalGain_Out {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for setMotorControllerProportionalGain_Out {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for setMotorControllerProportionalGain_Out {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct setMotorControllerIntegratorGain {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for setMotorControllerIntegratorGain {}

impl setMotorControllerIntegratorGain {
    pub fn new() -> setMotorControllerIntegratorGain {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static setMotorControllerIntegratorGain {
        static mut instance: ::protobuf::lazy::Lazy<setMotorControllerIntegratorGain> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const setMotorControllerIntegratorGain,
        };
        unsafe {
            instance.get(setMotorControllerIntegratorGain::new)
        }
    }
}

impl ::protobuf::Message for setMotorControllerIntegratorGain {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for setMotorControllerIntegratorGain {
    fn new() -> setMotorControllerIntegratorGain {
        setMotorControllerIntegratorGain::new()
    }

    fn descriptor_static(_: ::std::option::Option<setMotorControllerIntegratorGain>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<setMotorControllerIntegratorGain>(
                    "setMotorControllerIntegratorGain",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for setMotorControllerIntegratorGain {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for setMotorControllerIntegratorGain {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for setMotorControllerIntegratorGain {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct setMotorControllerIntegratorGain_In {
    // message fields
    mask: ::std::option::Option<u32>,
    values: ::std::vec::Vec<f32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for setMotorControllerIntegratorGain_In {}

impl setMotorControllerIntegratorGain_In {
    pub fn new() -> setMotorControllerIntegratorGain_In {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static setMotorControllerIntegratorGain_In {
        static mut instance: ::protobuf::lazy::Lazy<setMotorControllerIntegratorGain_In> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const setMotorControllerIntegratorGain_In,
        };
        unsafe {
            instance.get(setMotorControllerIntegratorGain_In::new)
        }
    }

    // optional uint32 mask = 1;

    pub fn clear_mask(&mut self) {
        self.mask = ::std::option::Option::None;
    }

    pub fn has_mask(&self) -> bool {
        self.mask.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mask(&mut self, v: u32) {
        self.mask = ::std::option::Option::Some(v);
    }

    pub fn get_mask(&self) -> u32 {
        self.mask.unwrap_or(0)
    }

    fn get_mask_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.mask
    }

    fn mut_mask_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.mask
    }

    // repeated float values = 2;

    pub fn clear_values(&mut self) {
        self.values.clear();
    }

    // Param is passed by value, moved
    pub fn set_values(&mut self, v: ::std::vec::Vec<f32>) {
        self.values = v;
    }

    // Mutable pointer to the field.
    pub fn mut_values(&mut self) -> &mut ::std::vec::Vec<f32> {
        &mut self.values
    }

    // Take field
    pub fn take_values(&mut self) -> ::std::vec::Vec<f32> {
        ::std::mem::replace(&mut self.values, ::std::vec::Vec::new())
    }

    pub fn get_values(&self) -> &[f32] {
        &self.values
    }

    fn get_values_for_reflect(&self) -> &::std::vec::Vec<f32> {
        &self.values
    }

    fn mut_values_for_reflect(&mut self) -> &mut ::std::vec::Vec<f32> {
        &mut self.values
    }
}

impl ::protobuf::Message for setMotorControllerIntegratorGain_In {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.mask = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_float_into(wire_type, is, &mut self.values)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.mask {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.values.is_empty() {
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(self.values.len() as u32) + (self.values.len() * 4) as u32;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.mask {
            os.write_uint32(1, v)?;
        }
        if !self.values.is_empty() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32((self.values.len() * 4) as u32)?;
            for v in &self.values {
                os.write_float_no_tag(*v)?;
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for setMotorControllerIntegratorGain_In {
    fn new() -> setMotorControllerIntegratorGain_In {
        setMotorControllerIntegratorGain_In::new()
    }

    fn descriptor_static(_: ::std::option::Option<setMotorControllerIntegratorGain_In>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "mask",
                    setMotorControllerIntegratorGain_In::get_mask_for_reflect,
                    setMotorControllerIntegratorGain_In::mut_mask_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "values",
                    setMotorControllerIntegratorGain_In::get_values_for_reflect,
                    setMotorControllerIntegratorGain_In::mut_values_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<setMotorControllerIntegratorGain_In>(
                    "setMotorControllerIntegratorGain_In",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for setMotorControllerIntegratorGain_In {
    fn clear(&mut self) {
        self.clear_mask();
        self.clear_values();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for setMotorControllerIntegratorGain_In {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for setMotorControllerIntegratorGain_In {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct setMotorControllerIntegratorGain_Out {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for setMotorControllerIntegratorGain_Out {}

impl setMotorControllerIntegratorGain_Out {
    pub fn new() -> setMotorControllerIntegratorGain_Out {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static setMotorControllerIntegratorGain_Out {
        static mut instance: ::protobuf::lazy::Lazy<setMotorControllerIntegratorGain_Out> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const setMotorControllerIntegratorGain_Out,
        };
        unsafe {
            instance.get(setMotorControllerIntegratorGain_Out::new)
        }
    }
}

impl ::protobuf::Message for setMotorControllerIntegratorGain_Out {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for setMotorControllerIntegratorGain_Out {
    fn new() -> setMotorControllerIntegratorGain_Out {
        setMotorControllerIntegratorGain_Out::new()
    }

    fn descriptor_static(_: ::std::option::Option<setMotorControllerIntegratorGain_Out>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<setMotorControllerIntegratorGain_Out>(
                    "setMotorControllerIntegratorGain_Out",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for setMotorControllerIntegratorGain_Out {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for setMotorControllerIntegratorGain_Out {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for setMotorControllerIntegratorGain_Out {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct setMotorControllerDerivativeGain {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for setMotorControllerDerivativeGain {}

impl setMotorControllerDerivativeGain {
    pub fn new() -> setMotorControllerDerivativeGain {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static setMotorControllerDerivativeGain {
        static mut instance: ::protobuf::lazy::Lazy<setMotorControllerDerivativeGain> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const setMotorControllerDerivativeGain,
        };
        unsafe {
            instance.get(setMotorControllerDerivativeGain::new)
        }
    }
}

impl ::protobuf::Message for setMotorControllerDerivativeGain {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for setMotorControllerDerivativeGain {
    fn new() -> setMotorControllerDerivativeGain {
        setMotorControllerDerivativeGain::new()
    }

    fn descriptor_static(_: ::std::option::Option<setMotorControllerDerivativeGain>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<setMotorControllerDerivativeGain>(
                    "setMotorControllerDerivativeGain",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for setMotorControllerDerivativeGain {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for setMotorControllerDerivativeGain {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for setMotorControllerDerivativeGain {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct setMotorControllerDerivativeGain_In {
    // message fields
    mask: ::std::option::Option<u32>,
    values: ::std::vec::Vec<f32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for setMotorControllerDerivativeGain_In {}

impl setMotorControllerDerivativeGain_In {
    pub fn new() -> setMotorControllerDerivativeGain_In {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static setMotorControllerDerivativeGain_In {
        static mut instance: ::protobuf::lazy::Lazy<setMotorControllerDerivativeGain_In> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const setMotorControllerDerivativeGain_In,
        };
        unsafe {
            instance.get(setMotorControllerDerivativeGain_In::new)
        }
    }

    // optional uint32 mask = 1;

    pub fn clear_mask(&mut self) {
        self.mask = ::std::option::Option::None;
    }

    pub fn has_mask(&self) -> bool {
        self.mask.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mask(&mut self, v: u32) {
        self.mask = ::std::option::Option::Some(v);
    }

    pub fn get_mask(&self) -> u32 {
        self.mask.unwrap_or(0)
    }

    fn get_mask_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.mask
    }

    fn mut_mask_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.mask
    }

    // repeated float values = 2;

    pub fn clear_values(&mut self) {
        self.values.clear();
    }

    // Param is passed by value, moved
    pub fn set_values(&mut self, v: ::std::vec::Vec<f32>) {
        self.values = v;
    }

    // Mutable pointer to the field.
    pub fn mut_values(&mut self) -> &mut ::std::vec::Vec<f32> {
        &mut self.values
    }

    // Take field
    pub fn take_values(&mut self) -> ::std::vec::Vec<f32> {
        ::std::mem::replace(&mut self.values, ::std::vec::Vec::new())
    }

    pub fn get_values(&self) -> &[f32] {
        &self.values
    }

    fn get_values_for_reflect(&self) -> &::std::vec::Vec<f32> {
        &self.values
    }

    fn mut_values_for_reflect(&mut self) -> &mut ::std::vec::Vec<f32> {
        &mut self.values
    }
}

impl ::protobuf::Message for setMotorControllerDerivativeGain_In {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.mask = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_float_into(wire_type, is, &mut self.values)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.mask {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.values.is_empty() {
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(self.values.len() as u32) + (self.values.len() * 4) as u32;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.mask {
            os.write_uint32(1, v)?;
        }
        if !self.values.is_empty() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32((self.values.len() * 4) as u32)?;
            for v in &self.values {
                os.write_float_no_tag(*v)?;
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for setMotorControllerDerivativeGain_In {
    fn new() -> setMotorControllerDerivativeGain_In {
        setMotorControllerDerivativeGain_In::new()
    }

    fn descriptor_static(_: ::std::option::Option<setMotorControllerDerivativeGain_In>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "mask",
                    setMotorControllerDerivativeGain_In::get_mask_for_reflect,
                    setMotorControllerDerivativeGain_In::mut_mask_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "values",
                    setMotorControllerDerivativeGain_In::get_values_for_reflect,
                    setMotorControllerDerivativeGain_In::mut_values_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<setMotorControllerDerivativeGain_In>(
                    "setMotorControllerDerivativeGain_In",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for setMotorControllerDerivativeGain_In {
    fn clear(&mut self) {
        self.clear_mask();
        self.clear_values();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for setMotorControllerDerivativeGain_In {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for setMotorControllerDerivativeGain_In {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct setMotorControllerDerivativeGain_Out {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for setMotorControllerDerivativeGain_Out {}

impl setMotorControllerDerivativeGain_Out {
    pub fn new() -> setMotorControllerDerivativeGain_Out {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static setMotorControllerDerivativeGain_Out {
        static mut instance: ::protobuf::lazy::Lazy<setMotorControllerDerivativeGain_Out> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const setMotorControllerDerivativeGain_Out,
        };
        unsafe {
            instance.get(setMotorControllerDerivativeGain_Out::new)
        }
    }
}

impl ::protobuf::Message for setMotorControllerDerivativeGain_Out {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for setMotorControllerDerivativeGain_Out {
    fn new() -> setMotorControllerDerivativeGain_Out {
        setMotorControllerDerivativeGain_Out::new()
    }

    fn descriptor_static(_: ::std::option::Option<setMotorControllerDerivativeGain_Out>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<setMotorControllerDerivativeGain_Out>(
                    "setMotorControllerDerivativeGain_Out",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for setMotorControllerDerivativeGain_Out {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for setMotorControllerDerivativeGain_Out {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for setMotorControllerDerivativeGain_Out {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct setMotorControllerSafetyThreshold {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for setMotorControllerSafetyThreshold {}

impl setMotorControllerSafetyThreshold {
    pub fn new() -> setMotorControllerSafetyThreshold {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static setMotorControllerSafetyThreshold {
        static mut instance: ::protobuf::lazy::Lazy<setMotorControllerSafetyThreshold> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const setMotorControllerSafetyThreshold,
        };
        unsafe {
            instance.get(setMotorControllerSafetyThreshold::new)
        }
    }
}

impl ::protobuf::Message for setMotorControllerSafetyThreshold {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for setMotorControllerSafetyThreshold {
    fn new() -> setMotorControllerSafetyThreshold {
        setMotorControllerSafetyThreshold::new()
    }

    fn descriptor_static(_: ::std::option::Option<setMotorControllerSafetyThreshold>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<setMotorControllerSafetyThreshold>(
                    "setMotorControllerSafetyThreshold",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for setMotorControllerSafetyThreshold {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for setMotorControllerSafetyThreshold {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for setMotorControllerSafetyThreshold {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct setMotorControllerSafetyThreshold_In {
    // message fields
    mask: ::std::option::Option<u32>,
    values: ::std::vec::Vec<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for setMotorControllerSafetyThreshold_In {}

impl setMotorControllerSafetyThreshold_In {
    pub fn new() -> setMotorControllerSafetyThreshold_In {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static setMotorControllerSafetyThreshold_In {
        static mut instance: ::protobuf::lazy::Lazy<setMotorControllerSafetyThreshold_In> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const setMotorControllerSafetyThreshold_In,
        };
        unsafe {
            instance.get(setMotorControllerSafetyThreshold_In::new)
        }
    }

    // optional uint32 mask = 1;

    pub fn clear_mask(&mut self) {
        self.mask = ::std::option::Option::None;
    }

    pub fn has_mask(&self) -> bool {
        self.mask.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mask(&mut self, v: u32) {
        self.mask = ::std::option::Option::Some(v);
    }

    pub fn get_mask(&self) -> u32 {
        self.mask.unwrap_or(0)
    }

    fn get_mask_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.mask
    }

    fn mut_mask_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.mask
    }

    // repeated uint32 values = 2;

    pub fn clear_values(&mut self) {
        self.values.clear();
    }

    // Param is passed by value, moved
    pub fn set_values(&mut self, v: ::std::vec::Vec<u32>) {
        self.values = v;
    }

    // Mutable pointer to the field.
    pub fn mut_values(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.values
    }

    // Take field
    pub fn take_values(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.values, ::std::vec::Vec::new())
    }

    pub fn get_values(&self) -> &[u32] {
        &self.values
    }

    fn get_values_for_reflect(&self) -> &::std::vec::Vec<u32> {
        &self.values
    }

    fn mut_values_for_reflect(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.values
    }
}

impl ::protobuf::Message for setMotorControllerSafetyThreshold_In {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.mask = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.values)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.mask {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.values.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_size(2, &self.values);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.mask {
            os.write_uint32(1, v)?;
        }
        if !self.values.is_empty() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_varint_data_size(&self.values))?;
            for v in &self.values {
                os.write_uint32_no_tag(*v)?;
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for setMotorControllerSafetyThreshold_In {
    fn new() -> setMotorControllerSafetyThreshold_In {
        setMotorControllerSafetyThreshold_In::new()
    }

    fn descriptor_static(_: ::std::option::Option<setMotorControllerSafetyThreshold_In>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "mask",
                    setMotorControllerSafetyThreshold_In::get_mask_for_reflect,
                    setMotorControllerSafetyThreshold_In::mut_mask_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "values",
                    setMotorControllerSafetyThreshold_In::get_values_for_reflect,
                    setMotorControllerSafetyThreshold_In::mut_values_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<setMotorControllerSafetyThreshold_In>(
                    "setMotorControllerSafetyThreshold_In",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for setMotorControllerSafetyThreshold_In {
    fn clear(&mut self) {
        self.clear_mask();
        self.clear_values();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for setMotorControllerSafetyThreshold_In {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for setMotorControllerSafetyThreshold_In {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct setMotorControllerSafetyThreshold_Out {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for setMotorControllerSafetyThreshold_Out {}

impl setMotorControllerSafetyThreshold_Out {
    pub fn new() -> setMotorControllerSafetyThreshold_Out {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static setMotorControllerSafetyThreshold_Out {
        static mut instance: ::protobuf::lazy::Lazy<setMotorControllerSafetyThreshold_Out> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const setMotorControllerSafetyThreshold_Out,
        };
        unsafe {
            instance.get(setMotorControllerSafetyThreshold_Out::new)
        }
    }
}

impl ::protobuf::Message for setMotorControllerSafetyThreshold_Out {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for setMotorControllerSafetyThreshold_Out {
    fn new() -> setMotorControllerSafetyThreshold_Out {
        setMotorControllerSafetyThreshold_Out::new()
    }

    fn descriptor_static(_: ::std::option::Option<setMotorControllerSafetyThreshold_Out>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<setMotorControllerSafetyThreshold_Out>(
                    "setMotorControllerSafetyThreshold_Out",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for setMotorControllerSafetyThreshold_Out {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for setMotorControllerSafetyThreshold_Out {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for setMotorControllerSafetyThreshold_Out {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct setMotorControllerSafetyAngle {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for setMotorControllerSafetyAngle {}

impl setMotorControllerSafetyAngle {
    pub fn new() -> setMotorControllerSafetyAngle {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static setMotorControllerSafetyAngle {
        static mut instance: ::protobuf::lazy::Lazy<setMotorControllerSafetyAngle> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const setMotorControllerSafetyAngle,
        };
        unsafe {
            instance.get(setMotorControllerSafetyAngle::new)
        }
    }
}

impl ::protobuf::Message for setMotorControllerSafetyAngle {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for setMotorControllerSafetyAngle {
    fn new() -> setMotorControllerSafetyAngle {
        setMotorControllerSafetyAngle::new()
    }

    fn descriptor_static(_: ::std::option::Option<setMotorControllerSafetyAngle>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<setMotorControllerSafetyAngle>(
                    "setMotorControllerSafetyAngle",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for setMotorControllerSafetyAngle {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for setMotorControllerSafetyAngle {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for setMotorControllerSafetyAngle {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct setMotorControllerSafetyAngle_In {
    // message fields
    mask: ::std::option::Option<u32>,
    values: ::std::vec::Vec<f32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for setMotorControllerSafetyAngle_In {}

impl setMotorControllerSafetyAngle_In {
    pub fn new() -> setMotorControllerSafetyAngle_In {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static setMotorControllerSafetyAngle_In {
        static mut instance: ::protobuf::lazy::Lazy<setMotorControllerSafetyAngle_In> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const setMotorControllerSafetyAngle_In,
        };
        unsafe {
            instance.get(setMotorControllerSafetyAngle_In::new)
        }
    }

    // optional uint32 mask = 1;

    pub fn clear_mask(&mut self) {
        self.mask = ::std::option::Option::None;
    }

    pub fn has_mask(&self) -> bool {
        self.mask.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mask(&mut self, v: u32) {
        self.mask = ::std::option::Option::Some(v);
    }

    pub fn get_mask(&self) -> u32 {
        self.mask.unwrap_or(0)
    }

    fn get_mask_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.mask
    }

    fn mut_mask_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.mask
    }

    // repeated float values = 2;

    pub fn clear_values(&mut self) {
        self.values.clear();
    }

    // Param is passed by value, moved
    pub fn set_values(&mut self, v: ::std::vec::Vec<f32>) {
        self.values = v;
    }

    // Mutable pointer to the field.
    pub fn mut_values(&mut self) -> &mut ::std::vec::Vec<f32> {
        &mut self.values
    }

    // Take field
    pub fn take_values(&mut self) -> ::std::vec::Vec<f32> {
        ::std::mem::replace(&mut self.values, ::std::vec::Vec::new())
    }

    pub fn get_values(&self) -> &[f32] {
        &self.values
    }

    fn get_values_for_reflect(&self) -> &::std::vec::Vec<f32> {
        &self.values
    }

    fn mut_values_for_reflect(&mut self) -> &mut ::std::vec::Vec<f32> {
        &mut self.values
    }
}

impl ::protobuf::Message for setMotorControllerSafetyAngle_In {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.mask = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_float_into(wire_type, is, &mut self.values)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.mask {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.values.is_empty() {
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(self.values.len() as u32) + (self.values.len() * 4) as u32;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.mask {
            os.write_uint32(1, v)?;
        }
        if !self.values.is_empty() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32((self.values.len() * 4) as u32)?;
            for v in &self.values {
                os.write_float_no_tag(*v)?;
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for setMotorControllerSafetyAngle_In {
    fn new() -> setMotorControllerSafetyAngle_In {
        setMotorControllerSafetyAngle_In::new()
    }

    fn descriptor_static(_: ::std::option::Option<setMotorControllerSafetyAngle_In>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "mask",
                    setMotorControllerSafetyAngle_In::get_mask_for_reflect,
                    setMotorControllerSafetyAngle_In::mut_mask_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "values",
                    setMotorControllerSafetyAngle_In::get_values_for_reflect,
                    setMotorControllerSafetyAngle_In::mut_values_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<setMotorControllerSafetyAngle_In>(
                    "setMotorControllerSafetyAngle_In",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for setMotorControllerSafetyAngle_In {
    fn clear(&mut self) {
        self.clear_mask();
        self.clear_values();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for setMotorControllerSafetyAngle_In {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for setMotorControllerSafetyAngle_In {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct setMotorControllerSafetyAngle_Out {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for setMotorControllerSafetyAngle_Out {}

impl setMotorControllerSafetyAngle_Out {
    pub fn new() -> setMotorControllerSafetyAngle_Out {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static setMotorControllerSafetyAngle_Out {
        static mut instance: ::protobuf::lazy::Lazy<setMotorControllerSafetyAngle_Out> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const setMotorControllerSafetyAngle_Out,
        };
        unsafe {
            instance.get(setMotorControllerSafetyAngle_Out::new)
        }
    }
}

impl ::protobuf::Message for setMotorControllerSafetyAngle_Out {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for setMotorControllerSafetyAngle_Out {
    fn new() -> setMotorControllerSafetyAngle_Out {
        setMotorControllerSafetyAngle_Out::new()
    }

    fn descriptor_static(_: ::std::option::Option<setMotorControllerSafetyAngle_Out>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<setMotorControllerSafetyAngle_Out>(
                    "setMotorControllerSafetyAngle_Out",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for setMotorControllerSafetyAngle_Out {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for setMotorControllerSafetyAngle_Out {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for setMotorControllerSafetyAngle_Out {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct setResetOnDisconnect {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for setResetOnDisconnect {}

impl setResetOnDisconnect {
    pub fn new() -> setResetOnDisconnect {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static setResetOnDisconnect {
        static mut instance: ::protobuf::lazy::Lazy<setResetOnDisconnect> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const setResetOnDisconnect,
        };
        unsafe {
            instance.get(setResetOnDisconnect::new)
        }
    }
}

impl ::protobuf::Message for setResetOnDisconnect {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for setResetOnDisconnect {
    fn new() -> setResetOnDisconnect {
        setResetOnDisconnect::new()
    }

    fn descriptor_static(_: ::std::option::Option<setResetOnDisconnect>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<setResetOnDisconnect>(
                    "setResetOnDisconnect",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for setResetOnDisconnect {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for setResetOnDisconnect {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for setResetOnDisconnect {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct setResetOnDisconnect_In {
    // message fields
    mask: ::std::option::Option<u32>,
    peripheralResetMask: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for setResetOnDisconnect_In {}

impl setResetOnDisconnect_In {
    pub fn new() -> setResetOnDisconnect_In {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static setResetOnDisconnect_In {
        static mut instance: ::protobuf::lazy::Lazy<setResetOnDisconnect_In> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const setResetOnDisconnect_In,
        };
        unsafe {
            instance.get(setResetOnDisconnect_In::new)
        }
    }

    // optional uint32 mask = 1;

    pub fn clear_mask(&mut self) {
        self.mask = ::std::option::Option::None;
    }

    pub fn has_mask(&self) -> bool {
        self.mask.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mask(&mut self, v: u32) {
        self.mask = ::std::option::Option::Some(v);
    }

    pub fn get_mask(&self) -> u32 {
        self.mask.unwrap_or(0)
    }

    fn get_mask_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.mask
    }

    fn mut_mask_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.mask
    }

    // optional uint32 peripheralResetMask = 2;

    pub fn clear_peripheralResetMask(&mut self) {
        self.peripheralResetMask = ::std::option::Option::None;
    }

    pub fn has_peripheralResetMask(&self) -> bool {
        self.peripheralResetMask.is_some()
    }

    // Param is passed by value, moved
    pub fn set_peripheralResetMask(&mut self, v: u32) {
        self.peripheralResetMask = ::std::option::Option::Some(v);
    }

    pub fn get_peripheralResetMask(&self) -> u32 {
        self.peripheralResetMask.unwrap_or(0)
    }

    fn get_peripheralResetMask_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.peripheralResetMask
    }

    fn mut_peripheralResetMask_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.peripheralResetMask
    }
}

impl ::protobuf::Message for setResetOnDisconnect_In {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.mask = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.peripheralResetMask = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.mask {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.peripheralResetMask {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.mask {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.peripheralResetMask {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for setResetOnDisconnect_In {
    fn new() -> setResetOnDisconnect_In {
        setResetOnDisconnect_In::new()
    }

    fn descriptor_static(_: ::std::option::Option<setResetOnDisconnect_In>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "mask",
                    setResetOnDisconnect_In::get_mask_for_reflect,
                    setResetOnDisconnect_In::mut_mask_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "peripheralResetMask",
                    setResetOnDisconnect_In::get_peripheralResetMask_for_reflect,
                    setResetOnDisconnect_In::mut_peripheralResetMask_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<setResetOnDisconnect_In>(
                    "setResetOnDisconnect_In",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for setResetOnDisconnect_In {
    fn clear(&mut self) {
        self.clear_mask();
        self.clear_peripheralResetMask();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for setResetOnDisconnect_In {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for setResetOnDisconnect_In {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct setResetOnDisconnect_Out {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for setResetOnDisconnect_Out {}

impl setResetOnDisconnect_Out {
    pub fn new() -> setResetOnDisconnect_Out {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static setResetOnDisconnect_Out {
        static mut instance: ::protobuf::lazy::Lazy<setResetOnDisconnect_Out> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const setResetOnDisconnect_Out,
        };
        unsafe {
            instance.get(setResetOnDisconnect_Out::new)
        }
    }
}

impl ::protobuf::Message for setResetOnDisconnect_Out {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for setResetOnDisconnect_Out {
    fn new() -> setResetOnDisconnect_Out {
        setResetOnDisconnect_Out::new()
    }

    fn descriptor_static(_: ::std::option::Option<setResetOnDisconnect_Out>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<setResetOnDisconnect_Out>(
                    "setResetOnDisconnect_Out",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for setResetOnDisconnect_Out {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for setResetOnDisconnect_Out {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for setResetOnDisconnect_Out {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct resetEncoderRevs {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for resetEncoderRevs {}

impl resetEncoderRevs {
    pub fn new() -> resetEncoderRevs {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static resetEncoderRevs {
        static mut instance: ::protobuf::lazy::Lazy<resetEncoderRevs> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const resetEncoderRevs,
        };
        unsafe {
            instance.get(resetEncoderRevs::new)
        }
    }
}

impl ::protobuf::Message for resetEncoderRevs {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for resetEncoderRevs {
    fn new() -> resetEncoderRevs {
        resetEncoderRevs::new()
    }

    fn descriptor_static(_: ::std::option::Option<resetEncoderRevs>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<resetEncoderRevs>(
                    "resetEncoderRevs",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for resetEncoderRevs {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for resetEncoderRevs {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for resetEncoderRevs {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct resetEncoderRevs_In {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for resetEncoderRevs_In {}

impl resetEncoderRevs_In {
    pub fn new() -> resetEncoderRevs_In {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static resetEncoderRevs_In {
        static mut instance: ::protobuf::lazy::Lazy<resetEncoderRevs_In> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const resetEncoderRevs_In,
        };
        unsafe {
            instance.get(resetEncoderRevs_In::new)
        }
    }
}

impl ::protobuf::Message for resetEncoderRevs_In {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for resetEncoderRevs_In {
    fn new() -> resetEncoderRevs_In {
        resetEncoderRevs_In::new()
    }

    fn descriptor_static(_: ::std::option::Option<resetEncoderRevs_In>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<resetEncoderRevs_In>(
                    "resetEncoderRevs_In",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for resetEncoderRevs_In {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for resetEncoderRevs_In {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for resetEncoderRevs_In {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct resetEncoderRevs_Out {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for resetEncoderRevs_Out {}

impl resetEncoderRevs_Out {
    pub fn new() -> resetEncoderRevs_Out {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static resetEncoderRevs_Out {
        static mut instance: ::protobuf::lazy::Lazy<resetEncoderRevs_Out> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const resetEncoderRevs_Out,
        };
        unsafe {
            instance.get(resetEncoderRevs_Out::new)
        }
    }
}

impl ::protobuf::Message for resetEncoderRevs_Out {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for resetEncoderRevs_Out {
    fn new() -> resetEncoderRevs_Out {
        resetEncoderRevs_Out::new()
    }

    fn descriptor_static(_: ::std::option::Option<resetEncoderRevs_Out>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<resetEncoderRevs_Out>(
                    "resetEncoderRevs_Out",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for resetEncoderRevs_Out {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for resetEncoderRevs_Out {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for resetEncoderRevs_Out {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct setBuzzerFrequency {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for setBuzzerFrequency {}

impl setBuzzerFrequency {
    pub fn new() -> setBuzzerFrequency {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static setBuzzerFrequency {
        static mut instance: ::protobuf::lazy::Lazy<setBuzzerFrequency> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const setBuzzerFrequency,
        };
        unsafe {
            instance.get(setBuzzerFrequency::new)
        }
    }
}

impl ::protobuf::Message for setBuzzerFrequency {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for setBuzzerFrequency {
    fn new() -> setBuzzerFrequency {
        setBuzzerFrequency::new()
    }

    fn descriptor_static(_: ::std::option::Option<setBuzzerFrequency>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<setBuzzerFrequency>(
                    "setBuzzerFrequency",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for setBuzzerFrequency {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for setBuzzerFrequency {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for setBuzzerFrequency {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct setBuzzerFrequency_In {
    // message fields
    value: ::std::option::Option<f32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for setBuzzerFrequency_In {}

impl setBuzzerFrequency_In {
    pub fn new() -> setBuzzerFrequency_In {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static setBuzzerFrequency_In {
        static mut instance: ::protobuf::lazy::Lazy<setBuzzerFrequency_In> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const setBuzzerFrequency_In,
        };
        unsafe {
            instance.get(setBuzzerFrequency_In::new)
        }
    }

    // optional float value = 1;

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: f32) {
        self.value = ::std::option::Option::Some(v);
    }

    pub fn get_value(&self) -> f32 {
        self.value.unwrap_or(0.)
    }

    fn get_value_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.value
    }

    fn mut_value_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.value
    }
}

impl ::protobuf::Message for setBuzzerFrequency_In {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.value = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.value {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.value {
            os.write_float(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for setBuzzerFrequency_In {
    fn new() -> setBuzzerFrequency_In {
        setBuzzerFrequency_In::new()
    }

    fn descriptor_static(_: ::std::option::Option<setBuzzerFrequency_In>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "value",
                    setBuzzerFrequency_In::get_value_for_reflect,
                    setBuzzerFrequency_In::mut_value_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<setBuzzerFrequency_In>(
                    "setBuzzerFrequency_In",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for setBuzzerFrequency_In {
    fn clear(&mut self) {
        self.clear_value();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for setBuzzerFrequency_In {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for setBuzzerFrequency_In {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct setBuzzerFrequency_Out {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for setBuzzerFrequency_Out {}

impl setBuzzerFrequency_Out {
    pub fn new() -> setBuzzerFrequency_Out {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static setBuzzerFrequency_Out {
        static mut instance: ::protobuf::lazy::Lazy<setBuzzerFrequency_Out> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const setBuzzerFrequency_Out,
        };
        unsafe {
            instance.get(setBuzzerFrequency_Out::new)
        }
    }
}

impl ::protobuf::Message for setBuzzerFrequency_Out {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for setBuzzerFrequency_Out {
    fn new() -> setBuzzerFrequency_Out {
        setBuzzerFrequency_Out::new()
    }

    fn descriptor_static(_: ::std::option::Option<setBuzzerFrequency_Out>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<setBuzzerFrequency_Out>(
                    "setBuzzerFrequency_Out",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for setBuzzerFrequency_Out {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for setBuzzerFrequency_Out {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for setBuzzerFrequency_Out {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct setLedColor {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for setLedColor {}

impl setLedColor {
    pub fn new() -> setLedColor {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static setLedColor {
        static mut instance: ::protobuf::lazy::Lazy<setLedColor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const setLedColor,
        };
        unsafe {
            instance.get(setLedColor::new)
        }
    }
}

impl ::protobuf::Message for setLedColor {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for setLedColor {
    fn new() -> setLedColor {
        setLedColor::new()
    }

    fn descriptor_static(_: ::std::option::Option<setLedColor>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<setLedColor>(
                    "setLedColor",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for setLedColor {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for setLedColor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for setLedColor {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct setLedColor_In {
    // message fields
    value: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for setLedColor_In {}

impl setLedColor_In {
    pub fn new() -> setLedColor_In {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static setLedColor_In {
        static mut instance: ::protobuf::lazy::Lazy<setLedColor_In> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const setLedColor_In,
        };
        unsafe {
            instance.get(setLedColor_In::new)
        }
    }

    // optional uint32 value = 1;

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: u32) {
        self.value = ::std::option::Option::Some(v);
    }

    pub fn get_value(&self) -> u32 {
        self.value.unwrap_or(0)
    }

    fn get_value_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.value
    }

    fn mut_value_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.value
    }
}

impl ::protobuf::Message for setLedColor_In {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.value = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.value {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.value {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for setLedColor_In {
    fn new() -> setLedColor_In {
        setLedColor_In::new()
    }

    fn descriptor_static(_: ::std::option::Option<setLedColor_In>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "value",
                    setLedColor_In::get_value_for_reflect,
                    setLedColor_In::mut_value_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<setLedColor_In>(
                    "setLedColor_In",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for setLedColor_In {
    fn clear(&mut self) {
        self.clear_value();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for setLedColor_In {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for setLedColor_In {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct setLedColor_Out {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for setLedColor_Out {}

impl setLedColor_Out {
    pub fn new() -> setLedColor_Out {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static setLedColor_Out {
        static mut instance: ::protobuf::lazy::Lazy<setLedColor_Out> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const setLedColor_Out,
        };
        unsafe {
            instance.get(setLedColor_Out::new)
        }
    }
}

impl ::protobuf::Message for setLedColor_Out {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for setLedColor_Out {
    fn new() -> setLedColor_Out {
        setLedColor_Out::new()
    }

    fn descriptor_static(_: ::std::option::Option<setLedColor_Out>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<setLedColor_Out>(
                    "setLedColor_Out",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for setLedColor_Out {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for setLedColor_Out {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for setLedColor_Out {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct stop {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for stop {}

impl stop {
    pub fn new() -> stop {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static stop {
        static mut instance: ::protobuf::lazy::Lazy<stop> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const stop,
        };
        unsafe {
            instance.get(stop::new)
        }
    }
}

impl ::protobuf::Message for stop {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for stop {
    fn new() -> stop {
        stop::new()
    }

    fn descriptor_static(_: ::std::option::Option<stop>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<stop>(
                    "stop",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for stop {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for stop {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for stop {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct stop_In {
    // message fields
    mask: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for stop_In {}

impl stop_In {
    pub fn new() -> stop_In {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static stop_In {
        static mut instance: ::protobuf::lazy::Lazy<stop_In> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const stop_In,
        };
        unsafe {
            instance.get(stop_In::new)
        }
    }

    // optional uint32 mask = 1;

    pub fn clear_mask(&mut self) {
        self.mask = ::std::option::Option::None;
    }

    pub fn has_mask(&self) -> bool {
        self.mask.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mask(&mut self, v: u32) {
        self.mask = ::std::option::Option::Some(v);
    }

    pub fn get_mask(&self) -> u32 {
        self.mask.unwrap_or(0)
    }

    fn get_mask_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.mask
    }

    fn mut_mask_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.mask
    }
}

impl ::protobuf::Message for stop_In {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.mask = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.mask {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.mask {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for stop_In {
    fn new() -> stop_In {
        stop_In::new()
    }

    fn descriptor_static(_: ::std::option::Option<stop_In>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "mask",
                    stop_In::get_mask_for_reflect,
                    stop_In::mut_mask_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<stop_In>(
                    "stop_In",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for stop_In {
    fn clear(&mut self) {
        self.clear_mask();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for stop_In {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for stop_In {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct stop_Out {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for stop_Out {}

impl stop_Out {
    pub fn new() -> stop_Out {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static stop_Out {
        static mut instance: ::protobuf::lazy::Lazy<stop_Out> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const stop_Out,
        };
        unsafe {
            instance.get(stop_Out::new)
        }
    }
}

impl ::protobuf::Message for stop_Out {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for stop_Out {
    fn new() -> stop_Out {
        stop_Out::new()
    }

    fn descriptor_static(_: ::std::option::Option<stop_Out>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<stop_Out>(
                    "stop_Out",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for stop_Out {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for stop_Out {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for stop_Out {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Goal {
    // message fields
    field_type: ::std::option::Option<Goal_Type>,
    goal: ::std::option::Option<f32>,
    controller: ::std::option::Option<Goal_Controller>,
    timeout: ::std::option::Option<f32>,
    modeOnTimeout: ::std::option::Option<JointState>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Goal {}

impl Goal {
    pub fn new() -> Goal {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Goal {
        static mut instance: ::protobuf::lazy::Lazy<Goal> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Goal,
        };
        unsafe {
            instance.get(Goal::new)
        }
    }

    // optional .linkbot.robot.Goal.Type type = 1;

    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: Goal_Type) {
        self.field_type = ::std::option::Option::Some(v);
    }

    pub fn get_field_type(&self) -> Goal_Type {
        self.field_type.unwrap_or(Goal_Type::ABSOLUTE)
    }

    fn get_field_type_for_reflect(&self) -> &::std::option::Option<Goal_Type> {
        &self.field_type
    }

    fn mut_field_type_for_reflect(&mut self) -> &mut ::std::option::Option<Goal_Type> {
        &mut self.field_type
    }

    // optional float goal = 2;

    pub fn clear_goal(&mut self) {
        self.goal = ::std::option::Option::None;
    }

    pub fn has_goal(&self) -> bool {
        self.goal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_goal(&mut self, v: f32) {
        self.goal = ::std::option::Option::Some(v);
    }

    pub fn get_goal(&self) -> f32 {
        self.goal.unwrap_or(0.)
    }

    fn get_goal_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.goal
    }

    fn mut_goal_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.goal
    }

    // optional .linkbot.robot.Goal.Controller controller = 3;

    pub fn clear_controller(&mut self) {
        self.controller = ::std::option::Option::None;
    }

    pub fn has_controller(&self) -> bool {
        self.controller.is_some()
    }

    // Param is passed by value, moved
    pub fn set_controller(&mut self, v: Goal_Controller) {
        self.controller = ::std::option::Option::Some(v);
    }

    pub fn get_controller(&self) -> Goal_Controller {
        self.controller.unwrap_or(Goal_Controller::PID)
    }

    fn get_controller_for_reflect(&self) -> &::std::option::Option<Goal_Controller> {
        &self.controller
    }

    fn mut_controller_for_reflect(&mut self) -> &mut ::std::option::Option<Goal_Controller> {
        &mut self.controller
    }

    // optional float timeout = 4;

    pub fn clear_timeout(&mut self) {
        self.timeout = ::std::option::Option::None;
    }

    pub fn has_timeout(&self) -> bool {
        self.timeout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timeout(&mut self, v: f32) {
        self.timeout = ::std::option::Option::Some(v);
    }

    pub fn get_timeout(&self) -> f32 {
        self.timeout.unwrap_or(0.)
    }

    fn get_timeout_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.timeout
    }

    fn mut_timeout_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.timeout
    }

    // optional .linkbot.robot.JointState modeOnTimeout = 5;

    pub fn clear_modeOnTimeout(&mut self) {
        self.modeOnTimeout = ::std::option::Option::None;
    }

    pub fn has_modeOnTimeout(&self) -> bool {
        self.modeOnTimeout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modeOnTimeout(&mut self, v: JointState) {
        self.modeOnTimeout = ::std::option::Option::Some(v);
    }

    pub fn get_modeOnTimeout(&self) -> JointState {
        self.modeOnTimeout.unwrap_or(JointState::COAST)
    }

    fn get_modeOnTimeout_for_reflect(&self) -> &::std::option::Option<JointState> {
        &self.modeOnTimeout
    }

    fn mut_modeOnTimeout_for_reflect(&mut self) -> &mut ::std::option::Option<JointState> {
        &mut self.modeOnTimeout
    }
}

impl ::protobuf::Message for Goal {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.goal = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.controller = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.timeout = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.modeOnTimeout = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(v) = self.goal {
            my_size += 5;
        }
        if let Some(v) = self.controller {
            my_size += ::protobuf::rt::enum_size(3, v);
        }
        if let Some(v) = self.timeout {
            my_size += 5;
        }
        if let Some(v) = self.modeOnTimeout {
            my_size += ::protobuf::rt::enum_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_enum(1, v.value())?;
        }
        if let Some(v) = self.goal {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.controller {
            os.write_enum(3, v.value())?;
        }
        if let Some(v) = self.timeout {
            os.write_float(4, v)?;
        }
        if let Some(v) = self.modeOnTimeout {
            os.write_enum(5, v.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Goal {
    fn new() -> Goal {
        Goal::new()
    }

    fn descriptor_static(_: ::std::option::Option<Goal>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Goal_Type>>(
                    "type",
                    Goal::get_field_type_for_reflect,
                    Goal::mut_field_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "goal",
                    Goal::get_goal_for_reflect,
                    Goal::mut_goal_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Goal_Controller>>(
                    "controller",
                    Goal::get_controller_for_reflect,
                    Goal::mut_controller_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "timeout",
                    Goal::get_timeout_for_reflect,
                    Goal::mut_timeout_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<JointState>>(
                    "modeOnTimeout",
                    Goal::get_modeOnTimeout_for_reflect,
                    Goal::mut_modeOnTimeout_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Goal>(
                    "Goal",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Goal {
    fn clear(&mut self) {
        self.clear_field_type();
        self.clear_goal();
        self.clear_controller();
        self.clear_timeout();
        self.clear_modeOnTimeout();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Goal {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Goal {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Goal_Type {
    ABSOLUTE = 1,
    RELATIVE = 2,
    INFINITE = 3,
}

impl ::protobuf::ProtobufEnum for Goal_Type {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Goal_Type> {
        match value {
            1 => ::std::option::Option::Some(Goal_Type::ABSOLUTE),
            2 => ::std::option::Option::Some(Goal_Type::RELATIVE),
            3 => ::std::option::Option::Some(Goal_Type::INFINITE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Goal_Type] = &[
            Goal_Type::ABSOLUTE,
            Goal_Type::RELATIVE,
            Goal_Type::INFINITE,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<Goal_Type>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Goal_Type", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Goal_Type {
}

impl ::protobuf::reflect::ProtobufValue for Goal_Type {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Goal_Controller {
    PID = 1,
    CONSTVEL = 2,
    SMOOTH = 3,
    ACCEL = 4,
    CYCLOIDAL = 5,
    HARMONIC = 6,
}

impl ::protobuf::ProtobufEnum for Goal_Controller {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Goal_Controller> {
        match value {
            1 => ::std::option::Option::Some(Goal_Controller::PID),
            2 => ::std::option::Option::Some(Goal_Controller::CONSTVEL),
            3 => ::std::option::Option::Some(Goal_Controller::SMOOTH),
            4 => ::std::option::Option::Some(Goal_Controller::ACCEL),
            5 => ::std::option::Option::Some(Goal_Controller::CYCLOIDAL),
            6 => ::std::option::Option::Some(Goal_Controller::HARMONIC),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Goal_Controller] = &[
            Goal_Controller::PID,
            Goal_Controller::CONSTVEL,
            Goal_Controller::SMOOTH,
            Goal_Controller::ACCEL,
            Goal_Controller::CYCLOIDAL,
            Goal_Controller::HARMONIC,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<Goal_Controller>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Goal_Controller", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Goal_Controller {
}

impl ::protobuf::reflect::ProtobufValue for Goal_Controller {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct robotMove {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for robotMove {}

impl robotMove {
    pub fn new() -> robotMove {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static robotMove {
        static mut instance: ::protobuf::lazy::Lazy<robotMove> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const robotMove,
        };
        unsafe {
            instance.get(robotMove::new)
        }
    }
}

impl ::protobuf::Message for robotMove {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for robotMove {
    fn new() -> robotMove {
        robotMove::new()
    }

    fn descriptor_static(_: ::std::option::Option<robotMove>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<robotMove>(
                    "robotMove",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for robotMove {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for robotMove {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for robotMove {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct robotMove_In {
    // message fields
    motorOneGoal: ::protobuf::SingularPtrField<Goal>,
    motorTwoGoal: ::protobuf::SingularPtrField<Goal>,
    motorThreeGoal: ::protobuf::SingularPtrField<Goal>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for robotMove_In {}

impl robotMove_In {
    pub fn new() -> robotMove_In {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static robotMove_In {
        static mut instance: ::protobuf::lazy::Lazy<robotMove_In> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const robotMove_In,
        };
        unsafe {
            instance.get(robotMove_In::new)
        }
    }

    // optional .linkbot.robot.Goal motorOneGoal = 1;

    pub fn clear_motorOneGoal(&mut self) {
        self.motorOneGoal.clear();
    }

    pub fn has_motorOneGoal(&self) -> bool {
        self.motorOneGoal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_motorOneGoal(&mut self, v: Goal) {
        self.motorOneGoal = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_motorOneGoal(&mut self) -> &mut Goal {
        if self.motorOneGoal.is_none() {
            self.motorOneGoal.set_default();
        }
        self.motorOneGoal.as_mut().unwrap()
    }

    // Take field
    pub fn take_motorOneGoal(&mut self) -> Goal {
        self.motorOneGoal.take().unwrap_or_else(|| Goal::new())
    }

    pub fn get_motorOneGoal(&self) -> &Goal {
        self.motorOneGoal.as_ref().unwrap_or_else(|| Goal::default_instance())
    }

    fn get_motorOneGoal_for_reflect(&self) -> &::protobuf::SingularPtrField<Goal> {
        &self.motorOneGoal
    }

    fn mut_motorOneGoal_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Goal> {
        &mut self.motorOneGoal
    }

    // optional .linkbot.robot.Goal motorTwoGoal = 2;

    pub fn clear_motorTwoGoal(&mut self) {
        self.motorTwoGoal.clear();
    }

    pub fn has_motorTwoGoal(&self) -> bool {
        self.motorTwoGoal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_motorTwoGoal(&mut self, v: Goal) {
        self.motorTwoGoal = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_motorTwoGoal(&mut self) -> &mut Goal {
        if self.motorTwoGoal.is_none() {
            self.motorTwoGoal.set_default();
        }
        self.motorTwoGoal.as_mut().unwrap()
    }

    // Take field
    pub fn take_motorTwoGoal(&mut self) -> Goal {
        self.motorTwoGoal.take().unwrap_or_else(|| Goal::new())
    }

    pub fn get_motorTwoGoal(&self) -> &Goal {
        self.motorTwoGoal.as_ref().unwrap_or_else(|| Goal::default_instance())
    }

    fn get_motorTwoGoal_for_reflect(&self) -> &::protobuf::SingularPtrField<Goal> {
        &self.motorTwoGoal
    }

    fn mut_motorTwoGoal_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Goal> {
        &mut self.motorTwoGoal
    }

    // optional .linkbot.robot.Goal motorThreeGoal = 3;

    pub fn clear_motorThreeGoal(&mut self) {
        self.motorThreeGoal.clear();
    }

    pub fn has_motorThreeGoal(&self) -> bool {
        self.motorThreeGoal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_motorThreeGoal(&mut self, v: Goal) {
        self.motorThreeGoal = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_motorThreeGoal(&mut self) -> &mut Goal {
        if self.motorThreeGoal.is_none() {
            self.motorThreeGoal.set_default();
        }
        self.motorThreeGoal.as_mut().unwrap()
    }

    // Take field
    pub fn take_motorThreeGoal(&mut self) -> Goal {
        self.motorThreeGoal.take().unwrap_or_else(|| Goal::new())
    }

    pub fn get_motorThreeGoal(&self) -> &Goal {
        self.motorThreeGoal.as_ref().unwrap_or_else(|| Goal::default_instance())
    }

    fn get_motorThreeGoal_for_reflect(&self) -> &::protobuf::SingularPtrField<Goal> {
        &self.motorThreeGoal
    }

    fn mut_motorThreeGoal_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Goal> {
        &mut self.motorThreeGoal
    }
}

impl ::protobuf::Message for robotMove_In {
    fn is_initialized(&self) -> bool {
        for v in &self.motorOneGoal {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.motorTwoGoal {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.motorThreeGoal {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.motorOneGoal)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.motorTwoGoal)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.motorThreeGoal)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.motorOneGoal.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.motorTwoGoal.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.motorThreeGoal.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.motorOneGoal.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.motorTwoGoal.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.motorThreeGoal.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for robotMove_In {
    fn new() -> robotMove_In {
        robotMove_In::new()
    }

    fn descriptor_static(_: ::std::option::Option<robotMove_In>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Goal>>(
                    "motorOneGoal",
                    robotMove_In::get_motorOneGoal_for_reflect,
                    robotMove_In::mut_motorOneGoal_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Goal>>(
                    "motorTwoGoal",
                    robotMove_In::get_motorTwoGoal_for_reflect,
                    robotMove_In::mut_motorTwoGoal_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Goal>>(
                    "motorThreeGoal",
                    robotMove_In::get_motorThreeGoal_for_reflect,
                    robotMove_In::mut_motorThreeGoal_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<robotMove_In>(
                    "robotMove_In",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for robotMove_In {
    fn clear(&mut self) {
        self.clear_motorOneGoal();
        self.clear_motorTwoGoal();
        self.clear_motorThreeGoal();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for robotMove_In {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for robotMove_In {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct robotMove_Out {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for robotMove_Out {}

impl robotMove_Out {
    pub fn new() -> robotMove_Out {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static robotMove_Out {
        static mut instance: ::protobuf::lazy::Lazy<robotMove_Out> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const robotMove_Out,
        };
        unsafe {
            instance.get(robotMove_Out::new)
        }
    }
}

impl ::protobuf::Message for robotMove_Out {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for robotMove_Out {
    fn new() -> robotMove_Out {
        robotMove_Out::new()
    }

    fn descriptor_static(_: ::std::option::Option<robotMove_Out>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<robotMove_Out>(
                    "robotMove_Out",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for robotMove_Out {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for robotMove_Out {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for robotMove_Out {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct enableAccelerometerEvent {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for enableAccelerometerEvent {}

impl enableAccelerometerEvent {
    pub fn new() -> enableAccelerometerEvent {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static enableAccelerometerEvent {
        static mut instance: ::protobuf::lazy::Lazy<enableAccelerometerEvent> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const enableAccelerometerEvent,
        };
        unsafe {
            instance.get(enableAccelerometerEvent::new)
        }
    }
}

impl ::protobuf::Message for enableAccelerometerEvent {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for enableAccelerometerEvent {
    fn new() -> enableAccelerometerEvent {
        enableAccelerometerEvent::new()
    }

    fn descriptor_static(_: ::std::option::Option<enableAccelerometerEvent>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<enableAccelerometerEvent>(
                    "enableAccelerometerEvent",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for enableAccelerometerEvent {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for enableAccelerometerEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for enableAccelerometerEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct enableAccelerometerEvent_In {
    // message fields
    enable: ::std::option::Option<bool>,
    granularity: ::std::option::Option<f32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for enableAccelerometerEvent_In {}

impl enableAccelerometerEvent_In {
    pub fn new() -> enableAccelerometerEvent_In {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static enableAccelerometerEvent_In {
        static mut instance: ::protobuf::lazy::Lazy<enableAccelerometerEvent_In> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const enableAccelerometerEvent_In,
        };
        unsafe {
            instance.get(enableAccelerometerEvent_In::new)
        }
    }

    // optional bool enable = 1;

    pub fn clear_enable(&mut self) {
        self.enable = ::std::option::Option::None;
    }

    pub fn has_enable(&self) -> bool {
        self.enable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable(&mut self, v: bool) {
        self.enable = ::std::option::Option::Some(v);
    }

    pub fn get_enable(&self) -> bool {
        self.enable.unwrap_or(false)
    }

    fn get_enable_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.enable
    }

    fn mut_enable_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.enable
    }

    // optional float granularity = 2;

    pub fn clear_granularity(&mut self) {
        self.granularity = ::std::option::Option::None;
    }

    pub fn has_granularity(&self) -> bool {
        self.granularity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_granularity(&mut self, v: f32) {
        self.granularity = ::std::option::Option::Some(v);
    }

    pub fn get_granularity(&self) -> f32 {
        self.granularity.unwrap_or(0.)
    }

    fn get_granularity_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.granularity
    }

    fn mut_granularity_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.granularity
    }
}

impl ::protobuf::Message for enableAccelerometerEvent_In {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.enable = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.granularity = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.enable {
            my_size += 2;
        }
        if let Some(v) = self.granularity {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.enable {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.granularity {
            os.write_float(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for enableAccelerometerEvent_In {
    fn new() -> enableAccelerometerEvent_In {
        enableAccelerometerEvent_In::new()
    }

    fn descriptor_static(_: ::std::option::Option<enableAccelerometerEvent_In>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "enable",
                    enableAccelerometerEvent_In::get_enable_for_reflect,
                    enableAccelerometerEvent_In::mut_enable_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "granularity",
                    enableAccelerometerEvent_In::get_granularity_for_reflect,
                    enableAccelerometerEvent_In::mut_granularity_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<enableAccelerometerEvent_In>(
                    "enableAccelerometerEvent_In",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for enableAccelerometerEvent_In {
    fn clear(&mut self) {
        self.clear_enable();
        self.clear_granularity();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for enableAccelerometerEvent_In {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for enableAccelerometerEvent_In {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct enableAccelerometerEvent_Out {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for enableAccelerometerEvent_Out {}

impl enableAccelerometerEvent_Out {
    pub fn new() -> enableAccelerometerEvent_Out {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static enableAccelerometerEvent_Out {
        static mut instance: ::protobuf::lazy::Lazy<enableAccelerometerEvent_Out> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const enableAccelerometerEvent_Out,
        };
        unsafe {
            instance.get(enableAccelerometerEvent_Out::new)
        }
    }
}

impl ::protobuf::Message for enableAccelerometerEvent_Out {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for enableAccelerometerEvent_Out {
    fn new() -> enableAccelerometerEvent_Out {
        enableAccelerometerEvent_Out::new()
    }

    fn descriptor_static(_: ::std::option::Option<enableAccelerometerEvent_Out>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<enableAccelerometerEvent_Out>(
                    "enableAccelerometerEvent_Out",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for enableAccelerometerEvent_Out {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for enableAccelerometerEvent_Out {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for enableAccelerometerEvent_Out {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct enableButtonEvent {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for enableButtonEvent {}

impl enableButtonEvent {
    pub fn new() -> enableButtonEvent {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static enableButtonEvent {
        static mut instance: ::protobuf::lazy::Lazy<enableButtonEvent> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const enableButtonEvent,
        };
        unsafe {
            instance.get(enableButtonEvent::new)
        }
    }
}

impl ::protobuf::Message for enableButtonEvent {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for enableButtonEvent {
    fn new() -> enableButtonEvent {
        enableButtonEvent::new()
    }

    fn descriptor_static(_: ::std::option::Option<enableButtonEvent>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<enableButtonEvent>(
                    "enableButtonEvent",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for enableButtonEvent {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for enableButtonEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for enableButtonEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct enableButtonEvent_In {
    // message fields
    enable: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for enableButtonEvent_In {}

impl enableButtonEvent_In {
    pub fn new() -> enableButtonEvent_In {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static enableButtonEvent_In {
        static mut instance: ::protobuf::lazy::Lazy<enableButtonEvent_In> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const enableButtonEvent_In,
        };
        unsafe {
            instance.get(enableButtonEvent_In::new)
        }
    }

    // optional bool enable = 1;

    pub fn clear_enable(&mut self) {
        self.enable = ::std::option::Option::None;
    }

    pub fn has_enable(&self) -> bool {
        self.enable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable(&mut self, v: bool) {
        self.enable = ::std::option::Option::Some(v);
    }

    pub fn get_enable(&self) -> bool {
        self.enable.unwrap_or(false)
    }

    fn get_enable_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.enable
    }

    fn mut_enable_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.enable
    }
}

impl ::protobuf::Message for enableButtonEvent_In {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.enable = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.enable {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.enable {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for enableButtonEvent_In {
    fn new() -> enableButtonEvent_In {
        enableButtonEvent_In::new()
    }

    fn descriptor_static(_: ::std::option::Option<enableButtonEvent_In>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "enable",
                    enableButtonEvent_In::get_enable_for_reflect,
                    enableButtonEvent_In::mut_enable_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<enableButtonEvent_In>(
                    "enableButtonEvent_In",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for enableButtonEvent_In {
    fn clear(&mut self) {
        self.clear_enable();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for enableButtonEvent_In {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for enableButtonEvent_In {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct enableButtonEvent_Out {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for enableButtonEvent_Out {}

impl enableButtonEvent_Out {
    pub fn new() -> enableButtonEvent_Out {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static enableButtonEvent_Out {
        static mut instance: ::protobuf::lazy::Lazy<enableButtonEvent_Out> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const enableButtonEvent_Out,
        };
        unsafe {
            instance.get(enableButtonEvent_Out::new)
        }
    }
}

impl ::protobuf::Message for enableButtonEvent_Out {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for enableButtonEvent_Out {
    fn new() -> enableButtonEvent_Out {
        enableButtonEvent_Out::new()
    }

    fn descriptor_static(_: ::std::option::Option<enableButtonEvent_Out>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<enableButtonEvent_Out>(
                    "enableButtonEvent_Out",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for enableButtonEvent_Out {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for enableButtonEvent_Out {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for enableButtonEvent_Out {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct enableEncoderEvent {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for enableEncoderEvent {}

impl enableEncoderEvent {
    pub fn new() -> enableEncoderEvent {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static enableEncoderEvent {
        static mut instance: ::protobuf::lazy::Lazy<enableEncoderEvent> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const enableEncoderEvent,
        };
        unsafe {
            instance.get(enableEncoderEvent::new)
        }
    }
}

impl ::protobuf::Message for enableEncoderEvent {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for enableEncoderEvent {
    fn new() -> enableEncoderEvent {
        enableEncoderEvent::new()
    }

    fn descriptor_static(_: ::std::option::Option<enableEncoderEvent>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<enableEncoderEvent>(
                    "enableEncoderEvent",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for enableEncoderEvent {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for enableEncoderEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for enableEncoderEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct enableEncoderEvent_In {
    // message fields
    encoderOne: ::protobuf::SingularPtrField<enableEncoderEvent_In_SignalState>,
    encoderTwo: ::protobuf::SingularPtrField<enableEncoderEvent_In_SignalState>,
    encoderThree: ::protobuf::SingularPtrField<enableEncoderEvent_In_SignalState>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for enableEncoderEvent_In {}

impl enableEncoderEvent_In {
    pub fn new() -> enableEncoderEvent_In {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static enableEncoderEvent_In {
        static mut instance: ::protobuf::lazy::Lazy<enableEncoderEvent_In> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const enableEncoderEvent_In,
        };
        unsafe {
            instance.get(enableEncoderEvent_In::new)
        }
    }

    // optional .linkbot.robot.enableEncoderEvent.In.SignalState encoderOne = 1;

    pub fn clear_encoderOne(&mut self) {
        self.encoderOne.clear();
    }

    pub fn has_encoderOne(&self) -> bool {
        self.encoderOne.is_some()
    }

    // Param is passed by value, moved
    pub fn set_encoderOne(&mut self, v: enableEncoderEvent_In_SignalState) {
        self.encoderOne = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_encoderOne(&mut self) -> &mut enableEncoderEvent_In_SignalState {
        if self.encoderOne.is_none() {
            self.encoderOne.set_default();
        }
        self.encoderOne.as_mut().unwrap()
    }

    // Take field
    pub fn take_encoderOne(&mut self) -> enableEncoderEvent_In_SignalState {
        self.encoderOne.take().unwrap_or_else(|| enableEncoderEvent_In_SignalState::new())
    }

    pub fn get_encoderOne(&self) -> &enableEncoderEvent_In_SignalState {
        self.encoderOne.as_ref().unwrap_or_else(|| enableEncoderEvent_In_SignalState::default_instance())
    }

    fn get_encoderOne_for_reflect(&self) -> &::protobuf::SingularPtrField<enableEncoderEvent_In_SignalState> {
        &self.encoderOne
    }

    fn mut_encoderOne_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<enableEncoderEvent_In_SignalState> {
        &mut self.encoderOne
    }

    // optional .linkbot.robot.enableEncoderEvent.In.SignalState encoderTwo = 2;

    pub fn clear_encoderTwo(&mut self) {
        self.encoderTwo.clear();
    }

    pub fn has_encoderTwo(&self) -> bool {
        self.encoderTwo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_encoderTwo(&mut self, v: enableEncoderEvent_In_SignalState) {
        self.encoderTwo = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_encoderTwo(&mut self) -> &mut enableEncoderEvent_In_SignalState {
        if self.encoderTwo.is_none() {
            self.encoderTwo.set_default();
        }
        self.encoderTwo.as_mut().unwrap()
    }

    // Take field
    pub fn take_encoderTwo(&mut self) -> enableEncoderEvent_In_SignalState {
        self.encoderTwo.take().unwrap_or_else(|| enableEncoderEvent_In_SignalState::new())
    }

    pub fn get_encoderTwo(&self) -> &enableEncoderEvent_In_SignalState {
        self.encoderTwo.as_ref().unwrap_or_else(|| enableEncoderEvent_In_SignalState::default_instance())
    }

    fn get_encoderTwo_for_reflect(&self) -> &::protobuf::SingularPtrField<enableEncoderEvent_In_SignalState> {
        &self.encoderTwo
    }

    fn mut_encoderTwo_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<enableEncoderEvent_In_SignalState> {
        &mut self.encoderTwo
    }

    // optional .linkbot.robot.enableEncoderEvent.In.SignalState encoderThree = 3;

    pub fn clear_encoderThree(&mut self) {
        self.encoderThree.clear();
    }

    pub fn has_encoderThree(&self) -> bool {
        self.encoderThree.is_some()
    }

    // Param is passed by value, moved
    pub fn set_encoderThree(&mut self, v: enableEncoderEvent_In_SignalState) {
        self.encoderThree = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_encoderThree(&mut self) -> &mut enableEncoderEvent_In_SignalState {
        if self.encoderThree.is_none() {
            self.encoderThree.set_default();
        }
        self.encoderThree.as_mut().unwrap()
    }

    // Take field
    pub fn take_encoderThree(&mut self) -> enableEncoderEvent_In_SignalState {
        self.encoderThree.take().unwrap_or_else(|| enableEncoderEvent_In_SignalState::new())
    }

    pub fn get_encoderThree(&self) -> &enableEncoderEvent_In_SignalState {
        self.encoderThree.as_ref().unwrap_or_else(|| enableEncoderEvent_In_SignalState::default_instance())
    }

    fn get_encoderThree_for_reflect(&self) -> &::protobuf::SingularPtrField<enableEncoderEvent_In_SignalState> {
        &self.encoderThree
    }

    fn mut_encoderThree_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<enableEncoderEvent_In_SignalState> {
        &mut self.encoderThree
    }
}

impl ::protobuf::Message for enableEncoderEvent_In {
    fn is_initialized(&self) -> bool {
        for v in &self.encoderOne {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.encoderTwo {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.encoderThree {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.encoderOne)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.encoderTwo)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.encoderThree)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.encoderOne.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.encoderTwo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.encoderThree.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.encoderOne.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.encoderTwo.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.encoderThree.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for enableEncoderEvent_In {
    fn new() -> enableEncoderEvent_In {
        enableEncoderEvent_In::new()
    }

    fn descriptor_static(_: ::std::option::Option<enableEncoderEvent_In>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<enableEncoderEvent_In_SignalState>>(
                    "encoderOne",
                    enableEncoderEvent_In::get_encoderOne_for_reflect,
                    enableEncoderEvent_In::mut_encoderOne_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<enableEncoderEvent_In_SignalState>>(
                    "encoderTwo",
                    enableEncoderEvent_In::get_encoderTwo_for_reflect,
                    enableEncoderEvent_In::mut_encoderTwo_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<enableEncoderEvent_In_SignalState>>(
                    "encoderThree",
                    enableEncoderEvent_In::get_encoderThree_for_reflect,
                    enableEncoderEvent_In::mut_encoderThree_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<enableEncoderEvent_In>(
                    "enableEncoderEvent_In",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for enableEncoderEvent_In {
    fn clear(&mut self) {
        self.clear_encoderOne();
        self.clear_encoderTwo();
        self.clear_encoderThree();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for enableEncoderEvent_In {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for enableEncoderEvent_In {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct enableEncoderEvent_In_SignalState {
    // message fields
    enable: ::std::option::Option<bool>,
    granularity: ::std::option::Option<f32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for enableEncoderEvent_In_SignalState {}

impl enableEncoderEvent_In_SignalState {
    pub fn new() -> enableEncoderEvent_In_SignalState {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static enableEncoderEvent_In_SignalState {
        static mut instance: ::protobuf::lazy::Lazy<enableEncoderEvent_In_SignalState> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const enableEncoderEvent_In_SignalState,
        };
        unsafe {
            instance.get(enableEncoderEvent_In_SignalState::new)
        }
    }

    // optional bool enable = 1;

    pub fn clear_enable(&mut self) {
        self.enable = ::std::option::Option::None;
    }

    pub fn has_enable(&self) -> bool {
        self.enable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable(&mut self, v: bool) {
        self.enable = ::std::option::Option::Some(v);
    }

    pub fn get_enable(&self) -> bool {
        self.enable.unwrap_or(false)
    }

    fn get_enable_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.enable
    }

    fn mut_enable_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.enable
    }

    // optional float granularity = 2;

    pub fn clear_granularity(&mut self) {
        self.granularity = ::std::option::Option::None;
    }

    pub fn has_granularity(&self) -> bool {
        self.granularity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_granularity(&mut self, v: f32) {
        self.granularity = ::std::option::Option::Some(v);
    }

    pub fn get_granularity(&self) -> f32 {
        self.granularity.unwrap_or(0.)
    }

    fn get_granularity_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.granularity
    }

    fn mut_granularity_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.granularity
    }
}

impl ::protobuf::Message for enableEncoderEvent_In_SignalState {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.enable = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.granularity = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.enable {
            my_size += 2;
        }
        if let Some(v) = self.granularity {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.enable {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.granularity {
            os.write_float(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for enableEncoderEvent_In_SignalState {
    fn new() -> enableEncoderEvent_In_SignalState {
        enableEncoderEvent_In_SignalState::new()
    }

    fn descriptor_static(_: ::std::option::Option<enableEncoderEvent_In_SignalState>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "enable",
                    enableEncoderEvent_In_SignalState::get_enable_for_reflect,
                    enableEncoderEvent_In_SignalState::mut_enable_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "granularity",
                    enableEncoderEvent_In_SignalState::get_granularity_for_reflect,
                    enableEncoderEvent_In_SignalState::mut_granularity_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<enableEncoderEvent_In_SignalState>(
                    "enableEncoderEvent_In_SignalState",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for enableEncoderEvent_In_SignalState {
    fn clear(&mut self) {
        self.clear_enable();
        self.clear_granularity();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for enableEncoderEvent_In_SignalState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for enableEncoderEvent_In_SignalState {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct enableEncoderEvent_Out {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for enableEncoderEvent_Out {}

impl enableEncoderEvent_Out {
    pub fn new() -> enableEncoderEvent_Out {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static enableEncoderEvent_Out {
        static mut instance: ::protobuf::lazy::Lazy<enableEncoderEvent_Out> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const enableEncoderEvent_Out,
        };
        unsafe {
            instance.get(enableEncoderEvent_Out::new)
        }
    }
}

impl ::protobuf::Message for enableEncoderEvent_Out {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for enableEncoderEvent_Out {
    fn new() -> enableEncoderEvent_Out {
        enableEncoderEvent_Out::new()
    }

    fn descriptor_static(_: ::std::option::Option<enableEncoderEvent_Out>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<enableEncoderEvent_Out>(
                    "enableEncoderEvent_Out",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for enableEncoderEvent_Out {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for enableEncoderEvent_Out {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for enableEncoderEvent_Out {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct enableJointEvent {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for enableJointEvent {}

impl enableJointEvent {
    pub fn new() -> enableJointEvent {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static enableJointEvent {
        static mut instance: ::protobuf::lazy::Lazy<enableJointEvent> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const enableJointEvent,
        };
        unsafe {
            instance.get(enableJointEvent::new)
        }
    }
}

impl ::protobuf::Message for enableJointEvent {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for enableJointEvent {
    fn new() -> enableJointEvent {
        enableJointEvent::new()
    }

    fn descriptor_static(_: ::std::option::Option<enableJointEvent>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<enableJointEvent>(
                    "enableJointEvent",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for enableJointEvent {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for enableJointEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for enableJointEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct enableJointEvent_In {
    // message fields
    enable: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for enableJointEvent_In {}

impl enableJointEvent_In {
    pub fn new() -> enableJointEvent_In {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static enableJointEvent_In {
        static mut instance: ::protobuf::lazy::Lazy<enableJointEvent_In> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const enableJointEvent_In,
        };
        unsafe {
            instance.get(enableJointEvent_In::new)
        }
    }

    // optional bool enable = 1;

    pub fn clear_enable(&mut self) {
        self.enable = ::std::option::Option::None;
    }

    pub fn has_enable(&self) -> bool {
        self.enable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable(&mut self, v: bool) {
        self.enable = ::std::option::Option::Some(v);
    }

    pub fn get_enable(&self) -> bool {
        self.enable.unwrap_or(false)
    }

    fn get_enable_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.enable
    }

    fn mut_enable_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.enable
    }
}

impl ::protobuf::Message for enableJointEvent_In {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.enable = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.enable {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.enable {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for enableJointEvent_In {
    fn new() -> enableJointEvent_In {
        enableJointEvent_In::new()
    }

    fn descriptor_static(_: ::std::option::Option<enableJointEvent_In>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "enable",
                    enableJointEvent_In::get_enable_for_reflect,
                    enableJointEvent_In::mut_enable_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<enableJointEvent_In>(
                    "enableJointEvent_In",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for enableJointEvent_In {
    fn clear(&mut self) {
        self.clear_enable();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for enableJointEvent_In {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for enableJointEvent_In {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct enableJointEvent_Out {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for enableJointEvent_Out {}

impl enableJointEvent_Out {
    pub fn new() -> enableJointEvent_Out {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static enableJointEvent_Out {
        static mut instance: ::protobuf::lazy::Lazy<enableJointEvent_Out> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const enableJointEvent_Out,
        };
        unsafe {
            instance.get(enableJointEvent_Out::new)
        }
    }
}

impl ::protobuf::Message for enableJointEvent_Out {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for enableJointEvent_Out {
    fn new() -> enableJointEvent_Out {
        enableJointEvent_Out::new()
    }

    fn descriptor_static(_: ::std::option::Option<enableJointEvent_Out>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<enableJointEvent_Out>(
                    "enableJointEvent_Out",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for enableJointEvent_Out {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for enableJointEvent_Out {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for enableJointEvent_Out {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct writeEeprom {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for writeEeprom {}

impl writeEeprom {
    pub fn new() -> writeEeprom {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static writeEeprom {
        static mut instance: ::protobuf::lazy::Lazy<writeEeprom> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const writeEeprom,
        };
        unsafe {
            instance.get(writeEeprom::new)
        }
    }
}

impl ::protobuf::Message for writeEeprom {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for writeEeprom {
    fn new() -> writeEeprom {
        writeEeprom::new()
    }

    fn descriptor_static(_: ::std::option::Option<writeEeprom>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<writeEeprom>(
                    "writeEeprom",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for writeEeprom {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for writeEeprom {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for writeEeprom {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct writeEeprom_In {
    // message fields
    address: ::std::option::Option<u32>,
    data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for writeEeprom_In {}

impl writeEeprom_In {
    pub fn new() -> writeEeprom_In {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static writeEeprom_In {
        static mut instance: ::protobuf::lazy::Lazy<writeEeprom_In> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const writeEeprom_In,
        };
        unsafe {
            instance.get(writeEeprom_In::new)
        }
    }

    // optional uint32 address = 1;

    pub fn clear_address(&mut self) {
        self.address = ::std::option::Option::None;
    }

    pub fn has_address(&self) -> bool {
        self.address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: u32) {
        self.address = ::std::option::Option::Some(v);
    }

    pub fn get_address(&self) -> u32 {
        self.address.unwrap_or(0)
    }

    fn get_address_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.address
    }

    fn mut_address_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.address
    }

    // optional bytes data = 2;

    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.data.is_none() {
            self.data.set_default();
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        self.data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_data(&self) -> &[u8] {
        match self.data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.data
    }

    fn mut_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.data
    }
}

impl ::protobuf::Message for writeEeprom_In {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.address = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.address {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.address {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.data.as_ref() {
            os.write_bytes(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for writeEeprom_In {
    fn new() -> writeEeprom_In {
        writeEeprom_In::new()
    }

    fn descriptor_static(_: ::std::option::Option<writeEeprom_In>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "address",
                    writeEeprom_In::get_address_for_reflect,
                    writeEeprom_In::mut_address_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "data",
                    writeEeprom_In::get_data_for_reflect,
                    writeEeprom_In::mut_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<writeEeprom_In>(
                    "writeEeprom_In",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for writeEeprom_In {
    fn clear(&mut self) {
        self.clear_address();
        self.clear_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for writeEeprom_In {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for writeEeprom_In {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct writeEeprom_Out {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for writeEeprom_Out {}

impl writeEeprom_Out {
    pub fn new() -> writeEeprom_Out {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static writeEeprom_Out {
        static mut instance: ::protobuf::lazy::Lazy<writeEeprom_Out> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const writeEeprom_Out,
        };
        unsafe {
            instance.get(writeEeprom_Out::new)
        }
    }
}

impl ::protobuf::Message for writeEeprom_Out {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for writeEeprom_Out {
    fn new() -> writeEeprom_Out {
        writeEeprom_Out::new()
    }

    fn descriptor_static(_: ::std::option::Option<writeEeprom_Out>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<writeEeprom_Out>(
                    "writeEeprom_Out",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for writeEeprom_Out {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for writeEeprom_Out {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for writeEeprom_Out {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct readEeprom {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for readEeprom {}

impl readEeprom {
    pub fn new() -> readEeprom {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static readEeprom {
        static mut instance: ::protobuf::lazy::Lazy<readEeprom> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const readEeprom,
        };
        unsafe {
            instance.get(readEeprom::new)
        }
    }
}

impl ::protobuf::Message for readEeprom {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for readEeprom {
    fn new() -> readEeprom {
        readEeprom::new()
    }

    fn descriptor_static(_: ::std::option::Option<readEeprom>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<readEeprom>(
                    "readEeprom",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for readEeprom {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for readEeprom {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for readEeprom {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct readEeprom_In {
    // message fields
    address: ::std::option::Option<u32>,
    size: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for readEeprom_In {}

impl readEeprom_In {
    pub fn new() -> readEeprom_In {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static readEeprom_In {
        static mut instance: ::protobuf::lazy::Lazy<readEeprom_In> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const readEeprom_In,
        };
        unsafe {
            instance.get(readEeprom_In::new)
        }
    }

    // optional uint32 address = 1;

    pub fn clear_address(&mut self) {
        self.address = ::std::option::Option::None;
    }

    pub fn has_address(&self) -> bool {
        self.address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: u32) {
        self.address = ::std::option::Option::Some(v);
    }

    pub fn get_address(&self) -> u32 {
        self.address.unwrap_or(0)
    }

    fn get_address_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.address
    }

    fn mut_address_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.address
    }

    // optional uint32 size = 2;

    pub fn clear_size(&mut self) {
        self.size = ::std::option::Option::None;
    }

    pub fn has_size(&self) -> bool {
        self.size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_size(&mut self, v: u32) {
        self.size = ::std::option::Option::Some(v);
    }

    pub fn get_size(&self) -> u32 {
        self.size.unwrap_or(0)
    }

    fn get_size_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.size
    }

    fn mut_size_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.size
    }
}

impl ::protobuf::Message for readEeprom_In {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.address = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.size = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.address {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.size {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.address {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.size {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for readEeprom_In {
    fn new() -> readEeprom_In {
        readEeprom_In::new()
    }

    fn descriptor_static(_: ::std::option::Option<readEeprom_In>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "address",
                    readEeprom_In::get_address_for_reflect,
                    readEeprom_In::mut_address_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "size",
                    readEeprom_In::get_size_for_reflect,
                    readEeprom_In::mut_size_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<readEeprom_In>(
                    "readEeprom_In",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for readEeprom_In {
    fn clear(&mut self) {
        self.clear_address();
        self.clear_size();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for readEeprom_In {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for readEeprom_In {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct readEeprom_Out {
    // message fields
    data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for readEeprom_Out {}

impl readEeprom_Out {
    pub fn new() -> readEeprom_Out {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static readEeprom_Out {
        static mut instance: ::protobuf::lazy::Lazy<readEeprom_Out> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const readEeprom_Out,
        };
        unsafe {
            instance.get(readEeprom_Out::new)
        }
    }

    // optional bytes data = 1;

    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.data.is_none() {
            self.data.set_default();
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        self.data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_data(&self) -> &[u8] {
        match self.data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.data
    }

    fn mut_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.data
    }
}

impl ::protobuf::Message for readEeprom_Out {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.data.as_ref() {
            os.write_bytes(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for readEeprom_Out {
    fn new() -> readEeprom_Out {
        readEeprom_Out::new()
    }

    fn descriptor_static(_: ::std::option::Option<readEeprom_Out>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "data",
                    readEeprom_Out::get_data_for_reflect,
                    readEeprom_Out::mut_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<readEeprom_Out>(
                    "readEeprom_Out",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for readEeprom_Out {
    fn clear(&mut self) {
        self.clear_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for readEeprom_Out {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for readEeprom_Out {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct writeTwi {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for writeTwi {}

impl writeTwi {
    pub fn new() -> writeTwi {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static writeTwi {
        static mut instance: ::protobuf::lazy::Lazy<writeTwi> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const writeTwi,
        };
        unsafe {
            instance.get(writeTwi::new)
        }
    }
}

impl ::protobuf::Message for writeTwi {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for writeTwi {
    fn new() -> writeTwi {
        writeTwi::new()
    }

    fn descriptor_static(_: ::std::option::Option<writeTwi>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<writeTwi>(
                    "writeTwi",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for writeTwi {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for writeTwi {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for writeTwi {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct writeTwi_In {
    // message fields
    address: ::std::option::Option<u32>,
    data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for writeTwi_In {}

impl writeTwi_In {
    pub fn new() -> writeTwi_In {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static writeTwi_In {
        static mut instance: ::protobuf::lazy::Lazy<writeTwi_In> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const writeTwi_In,
        };
        unsafe {
            instance.get(writeTwi_In::new)
        }
    }

    // optional uint32 address = 1;

    pub fn clear_address(&mut self) {
        self.address = ::std::option::Option::None;
    }

    pub fn has_address(&self) -> bool {
        self.address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: u32) {
        self.address = ::std::option::Option::Some(v);
    }

    pub fn get_address(&self) -> u32 {
        self.address.unwrap_or(0)
    }

    fn get_address_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.address
    }

    fn mut_address_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.address
    }

    // optional bytes data = 2;

    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.data.is_none() {
            self.data.set_default();
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        self.data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_data(&self) -> &[u8] {
        match self.data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.data
    }

    fn mut_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.data
    }
}

impl ::protobuf::Message for writeTwi_In {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.address = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.address {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.address {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.data.as_ref() {
            os.write_bytes(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for writeTwi_In {
    fn new() -> writeTwi_In {
        writeTwi_In::new()
    }

    fn descriptor_static(_: ::std::option::Option<writeTwi_In>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "address",
                    writeTwi_In::get_address_for_reflect,
                    writeTwi_In::mut_address_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "data",
                    writeTwi_In::get_data_for_reflect,
                    writeTwi_In::mut_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<writeTwi_In>(
                    "writeTwi_In",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for writeTwi_In {
    fn clear(&mut self) {
        self.clear_address();
        self.clear_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for writeTwi_In {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for writeTwi_In {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct writeTwi_Out {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for writeTwi_Out {}

impl writeTwi_Out {
    pub fn new() -> writeTwi_Out {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static writeTwi_Out {
        static mut instance: ::protobuf::lazy::Lazy<writeTwi_Out> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const writeTwi_Out,
        };
        unsafe {
            instance.get(writeTwi_Out::new)
        }
    }
}

impl ::protobuf::Message for writeTwi_Out {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for writeTwi_Out {
    fn new() -> writeTwi_Out {
        writeTwi_Out::new()
    }

    fn descriptor_static(_: ::std::option::Option<writeTwi_Out>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<writeTwi_Out>(
                    "writeTwi_Out",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for writeTwi_Out {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for writeTwi_Out {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for writeTwi_Out {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct readTwi {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for readTwi {}

impl readTwi {
    pub fn new() -> readTwi {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static readTwi {
        static mut instance: ::protobuf::lazy::Lazy<readTwi> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const readTwi,
        };
        unsafe {
            instance.get(readTwi::new)
        }
    }
}

impl ::protobuf::Message for readTwi {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for readTwi {
    fn new() -> readTwi {
        readTwi::new()
    }

    fn descriptor_static(_: ::std::option::Option<readTwi>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<readTwi>(
                    "readTwi",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for readTwi {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for readTwi {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for readTwi {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct readTwi_In {
    // message fields
    address: ::std::option::Option<u32>,
    recvsize: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for readTwi_In {}

impl readTwi_In {
    pub fn new() -> readTwi_In {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static readTwi_In {
        static mut instance: ::protobuf::lazy::Lazy<readTwi_In> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const readTwi_In,
        };
        unsafe {
            instance.get(readTwi_In::new)
        }
    }

    // optional uint32 address = 1;

    pub fn clear_address(&mut self) {
        self.address = ::std::option::Option::None;
    }

    pub fn has_address(&self) -> bool {
        self.address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: u32) {
        self.address = ::std::option::Option::Some(v);
    }

    pub fn get_address(&self) -> u32 {
        self.address.unwrap_or(0)
    }

    fn get_address_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.address
    }

    fn mut_address_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.address
    }

    // optional uint32 recvsize = 2;

    pub fn clear_recvsize(&mut self) {
        self.recvsize = ::std::option::Option::None;
    }

    pub fn has_recvsize(&self) -> bool {
        self.recvsize.is_some()
    }

    // Param is passed by value, moved
    pub fn set_recvsize(&mut self, v: u32) {
        self.recvsize = ::std::option::Option::Some(v);
    }

    pub fn get_recvsize(&self) -> u32 {
        self.recvsize.unwrap_or(0)
    }

    fn get_recvsize_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.recvsize
    }

    fn mut_recvsize_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.recvsize
    }
}

impl ::protobuf::Message for readTwi_In {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.address = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.recvsize = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.address {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.recvsize {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.address {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.recvsize {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for readTwi_In {
    fn new() -> readTwi_In {
        readTwi_In::new()
    }

    fn descriptor_static(_: ::std::option::Option<readTwi_In>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "address",
                    readTwi_In::get_address_for_reflect,
                    readTwi_In::mut_address_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "recvsize",
                    readTwi_In::get_recvsize_for_reflect,
                    readTwi_In::mut_recvsize_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<readTwi_In>(
                    "readTwi_In",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for readTwi_In {
    fn clear(&mut self) {
        self.clear_address();
        self.clear_recvsize();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for readTwi_In {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for readTwi_In {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct readTwi_Out {
    // message fields
    data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for readTwi_Out {}

impl readTwi_Out {
    pub fn new() -> readTwi_Out {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static readTwi_Out {
        static mut instance: ::protobuf::lazy::Lazy<readTwi_Out> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const readTwi_Out,
        };
        unsafe {
            instance.get(readTwi_Out::new)
        }
    }

    // optional bytes data = 2;

    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.data.is_none() {
            self.data.set_default();
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        self.data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_data(&self) -> &[u8] {
        match self.data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.data
    }

    fn mut_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.data
    }
}

impl ::protobuf::Message for readTwi_Out {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.data.as_ref() {
            os.write_bytes(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for readTwi_Out {
    fn new() -> readTwi_Out {
        readTwi_Out::new()
    }

    fn descriptor_static(_: ::std::option::Option<readTwi_Out>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "data",
                    readTwi_Out::get_data_for_reflect,
                    readTwi_Out::mut_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<readTwi_Out>(
                    "readTwi_Out",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for readTwi_Out {
    fn clear(&mut self) {
        self.clear_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for readTwi_Out {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for readTwi_Out {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct writeReadTwi {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for writeReadTwi {}

impl writeReadTwi {
    pub fn new() -> writeReadTwi {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static writeReadTwi {
        static mut instance: ::protobuf::lazy::Lazy<writeReadTwi> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const writeReadTwi,
        };
        unsafe {
            instance.get(writeReadTwi::new)
        }
    }
}

impl ::protobuf::Message for writeReadTwi {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for writeReadTwi {
    fn new() -> writeReadTwi {
        writeReadTwi::new()
    }

    fn descriptor_static(_: ::std::option::Option<writeReadTwi>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<writeReadTwi>(
                    "writeReadTwi",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for writeReadTwi {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for writeReadTwi {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for writeReadTwi {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct writeReadTwi_In {
    // message fields
    address: ::std::option::Option<u32>,
    recvsize: ::std::option::Option<u32>,
    data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for writeReadTwi_In {}

impl writeReadTwi_In {
    pub fn new() -> writeReadTwi_In {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static writeReadTwi_In {
        static mut instance: ::protobuf::lazy::Lazy<writeReadTwi_In> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const writeReadTwi_In,
        };
        unsafe {
            instance.get(writeReadTwi_In::new)
        }
    }

    // optional uint32 address = 1;

    pub fn clear_address(&mut self) {
        self.address = ::std::option::Option::None;
    }

    pub fn has_address(&self) -> bool {
        self.address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: u32) {
        self.address = ::std::option::Option::Some(v);
    }

    pub fn get_address(&self) -> u32 {
        self.address.unwrap_or(0)
    }

    fn get_address_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.address
    }

    fn mut_address_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.address
    }

    // optional uint32 recvsize = 2;

    pub fn clear_recvsize(&mut self) {
        self.recvsize = ::std::option::Option::None;
    }

    pub fn has_recvsize(&self) -> bool {
        self.recvsize.is_some()
    }

    // Param is passed by value, moved
    pub fn set_recvsize(&mut self, v: u32) {
        self.recvsize = ::std::option::Option::Some(v);
    }

    pub fn get_recvsize(&self) -> u32 {
        self.recvsize.unwrap_or(0)
    }

    fn get_recvsize_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.recvsize
    }

    fn mut_recvsize_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.recvsize
    }

    // optional bytes data = 3;

    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.data.is_none() {
            self.data.set_default();
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        self.data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_data(&self) -> &[u8] {
        match self.data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.data
    }

    fn mut_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.data
    }
}

impl ::protobuf::Message for writeReadTwi_In {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.address = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.recvsize = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.address {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.recvsize {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.address {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.recvsize {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.data.as_ref() {
            os.write_bytes(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for writeReadTwi_In {
    fn new() -> writeReadTwi_In {
        writeReadTwi_In::new()
    }

    fn descriptor_static(_: ::std::option::Option<writeReadTwi_In>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "address",
                    writeReadTwi_In::get_address_for_reflect,
                    writeReadTwi_In::mut_address_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "recvsize",
                    writeReadTwi_In::get_recvsize_for_reflect,
                    writeReadTwi_In::mut_recvsize_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "data",
                    writeReadTwi_In::get_data_for_reflect,
                    writeReadTwi_In::mut_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<writeReadTwi_In>(
                    "writeReadTwi_In",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for writeReadTwi_In {
    fn clear(&mut self) {
        self.clear_address();
        self.clear_recvsize();
        self.clear_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for writeReadTwi_In {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for writeReadTwi_In {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct writeReadTwi_Out {
    // message fields
    data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for writeReadTwi_Out {}

impl writeReadTwi_Out {
    pub fn new() -> writeReadTwi_Out {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static writeReadTwi_Out {
        static mut instance: ::protobuf::lazy::Lazy<writeReadTwi_Out> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const writeReadTwi_Out,
        };
        unsafe {
            instance.get(writeReadTwi_Out::new)
        }
    }

    // optional bytes data = 2;

    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.data.is_none() {
            self.data.set_default();
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        self.data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_data(&self) -> &[u8] {
        match self.data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.data
    }

    fn mut_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.data
    }
}

impl ::protobuf::Message for writeReadTwi_Out {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.data.as_ref() {
            os.write_bytes(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for writeReadTwi_Out {
    fn new() -> writeReadTwi_Out {
        writeReadTwi_Out::new()
    }

    fn descriptor_static(_: ::std::option::Option<writeReadTwi_Out>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "data",
                    writeReadTwi_Out::get_data_for_reflect,
                    writeReadTwi_Out::mut_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<writeReadTwi_Out>(
                    "writeReadTwi_Out",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for writeReadTwi_Out {
    fn clear(&mut self) {
        self.clear_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for writeReadTwi_Out {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for writeReadTwi_Out {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct reboot {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for reboot {}

impl reboot {
    pub fn new() -> reboot {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static reboot {
        static mut instance: ::protobuf::lazy::Lazy<reboot> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const reboot,
        };
        unsafe {
            instance.get(reboot::new)
        }
    }
}

impl ::protobuf::Message for reboot {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for reboot {
    fn new() -> reboot {
        reboot::new()
    }

    fn descriptor_static(_: ::std::option::Option<reboot>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<reboot>(
                    "reboot",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for reboot {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for reboot {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for reboot {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct reboot_In {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for reboot_In {}

impl reboot_In {
    pub fn new() -> reboot_In {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static reboot_In {
        static mut instance: ::protobuf::lazy::Lazy<reboot_In> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const reboot_In,
        };
        unsafe {
            instance.get(reboot_In::new)
        }
    }
}

impl ::protobuf::Message for reboot_In {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for reboot_In {
    fn new() -> reboot_In {
        reboot_In::new()
    }

    fn descriptor_static(_: ::std::option::Option<reboot_In>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<reboot_In>(
                    "reboot_In",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for reboot_In {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for reboot_In {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for reboot_In {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct reboot_Out {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for reboot_Out {}

impl reboot_Out {
    pub fn new() -> reboot_Out {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static reboot_Out {
        static mut instance: ::protobuf::lazy::Lazy<reboot_Out> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const reboot_Out,
        };
        unsafe {
            instance.get(reboot_Out::new)
        }
    }
}

impl ::protobuf::Message for reboot_Out {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for reboot_Out {
    fn new() -> reboot_Out {
        reboot_Out::new()
    }

    fn descriptor_static(_: ::std::option::Option<reboot_Out>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<reboot_Out>(
                    "reboot_Out",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for reboot_Out {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for reboot_Out {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for reboot_Out {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RpcRequest {
    // message fields
    requestId: ::std::option::Option<u32>,
    // message oneof groups
    arg: ::std::option::Option<RpcRequest_oneof_arg>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for RpcRequest {}

#[derive(Clone,PartialEq)]
pub enum RpcRequest_oneof_arg {
    getFirmwareVersionString(getFirmwareVersionString_In),
    getFormFactor(getFormFactor_In),
    getAdcRaw(getAdcRaw_In),
    getBatteryVoltage(getBatteryVoltage_In),
    getAccelerometerData(getAccelerometerData_In),
    getButtonState(getButtonState_In),
    getEncoderValues(getEncoderValues_In),
    getJointStates(getJointStates_In),
    enableAccelerometerEvent(enableAccelerometerEvent_In),
    enableButtonEvent(enableButtonEvent_In),
    enableEncoderEvent(enableEncoderEvent_In),
    enableJointEvent(enableJointEvent_In),
    getBuzzerFrequency(getBuzzerFrequency_In),
    getLedColor(getLedColor_In),
    getMotorControllerOmega(getMotorControllerOmega_In),
    getMotorControllerAlphaI(getMotorControllerAlphaI_In),
    getMotorControllerAlphaF(getMotorControllerAlphaF_In),
    getMotorControllerProportionalGain(getMotorControllerProportionalGain_In),
    getMotorControllerIntegratorGain(getMotorControllerIntegratorGain_In),
    getMotorControllerDerivativeGain(getMotorControllerDerivativeGain_In),
    getMotorControllerSafetyThreshold(getMotorControllerSafetyThreshold_In),
    getMotorControllerSafetyAngle(getMotorControllerSafetyAngle_In),
    setBuzzerFrequency(setBuzzerFrequency_In),
    setLedColor(setLedColor_In),
    setMotorControllerOmega(setMotorControllerOmega_In),
    setMotorControllerAlphaI(setMotorControllerAlphaI_In),
    setMotorControllerAlphaF(setMotorControllerAlphaF_In),
    setMotorControllerProportionalGain(setMotorControllerProportionalGain_In),
    setMotorControllerIntegratorGain(setMotorControllerIntegratorGain_In),
    setMotorControllerDerivativeGain(setMotorControllerDerivativeGain_In),
    setMotorControllerSafetyThreshold(setMotorControllerSafetyThreshold_In),
    setMotorControllerSafetyAngle(setMotorControllerSafetyAngle_In),
    setResetOnDisconnect(setResetOnDisconnect_In),
    resetEncoderRevs(resetEncoderRevs_In),
    robotMove(robotMove_In),
    stop(stop_In),
    reboot(reboot_In),
    writeEeprom(writeEeprom_In),
    readEeprom(readEeprom_In),
    writeTwi(writeTwi_In),
    readTwi(readTwi_In),
    writeReadTwi(writeReadTwi_In),
}

impl RpcRequest {
    pub fn new() -> RpcRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static RpcRequest {
        static mut instance: ::protobuf::lazy::Lazy<RpcRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RpcRequest,
        };
        unsafe {
            instance.get(RpcRequest::new)
        }
    }

    // optional uint32 requestId = 1;

    pub fn clear_requestId(&mut self) {
        self.requestId = ::std::option::Option::None;
    }

    pub fn has_requestId(&self) -> bool {
        self.requestId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_requestId(&mut self, v: u32) {
        self.requestId = ::std::option::Option::Some(v);
    }

    pub fn get_requestId(&self) -> u32 {
        self.requestId.unwrap_or(0)
    }

    fn get_requestId_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.requestId
    }

    fn mut_requestId_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.requestId
    }

    // optional .linkbot.robot.getFirmwareVersionString.In getFirmwareVersionString = 16;

    pub fn clear_getFirmwareVersionString(&mut self) {
        self.arg = ::std::option::Option::None;
    }

    pub fn has_getFirmwareVersionString(&self) -> bool {
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::getFirmwareVersionString(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_getFirmwareVersionString(&mut self, v: getFirmwareVersionString_In) {
        self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::getFirmwareVersionString(v))
    }

    // Mutable pointer to the field.
    pub fn mut_getFirmwareVersionString(&mut self) -> &mut getFirmwareVersionString_In {
        if let ::std::option::Option::Some(RpcRequest_oneof_arg::getFirmwareVersionString(_)) = self.arg {
        } else {
            self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::getFirmwareVersionString(getFirmwareVersionString_In::new()));
        }
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::getFirmwareVersionString(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_getFirmwareVersionString(&mut self) -> getFirmwareVersionString_In {
        if self.has_getFirmwareVersionString() {
            match self.arg.take() {
                ::std::option::Option::Some(RpcRequest_oneof_arg::getFirmwareVersionString(v)) => v,
                _ => panic!(),
            }
        } else {
            getFirmwareVersionString_In::new()
        }
    }

    pub fn get_getFirmwareVersionString(&self) -> &getFirmwareVersionString_In {
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::getFirmwareVersionString(ref v)) => v,
            _ => getFirmwareVersionString_In::default_instance(),
        }
    }

    // optional .linkbot.robot.getFormFactor.In getFormFactor = 17;

    pub fn clear_getFormFactor(&mut self) {
        self.arg = ::std::option::Option::None;
    }

    pub fn has_getFormFactor(&self) -> bool {
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::getFormFactor(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_getFormFactor(&mut self, v: getFormFactor_In) {
        self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::getFormFactor(v))
    }

    // Mutable pointer to the field.
    pub fn mut_getFormFactor(&mut self) -> &mut getFormFactor_In {
        if let ::std::option::Option::Some(RpcRequest_oneof_arg::getFormFactor(_)) = self.arg {
        } else {
            self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::getFormFactor(getFormFactor_In::new()));
        }
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::getFormFactor(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_getFormFactor(&mut self) -> getFormFactor_In {
        if self.has_getFormFactor() {
            match self.arg.take() {
                ::std::option::Option::Some(RpcRequest_oneof_arg::getFormFactor(v)) => v,
                _ => panic!(),
            }
        } else {
            getFormFactor_In::new()
        }
    }

    pub fn get_getFormFactor(&self) -> &getFormFactor_In {
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::getFormFactor(ref v)) => v,
            _ => getFormFactor_In::default_instance(),
        }
    }

    // optional .linkbot.robot.getAdcRaw.In getAdcRaw = 18;

    pub fn clear_getAdcRaw(&mut self) {
        self.arg = ::std::option::Option::None;
    }

    pub fn has_getAdcRaw(&self) -> bool {
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::getAdcRaw(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_getAdcRaw(&mut self, v: getAdcRaw_In) {
        self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::getAdcRaw(v))
    }

    // Mutable pointer to the field.
    pub fn mut_getAdcRaw(&mut self) -> &mut getAdcRaw_In {
        if let ::std::option::Option::Some(RpcRequest_oneof_arg::getAdcRaw(_)) = self.arg {
        } else {
            self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::getAdcRaw(getAdcRaw_In::new()));
        }
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::getAdcRaw(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_getAdcRaw(&mut self) -> getAdcRaw_In {
        if self.has_getAdcRaw() {
            match self.arg.take() {
                ::std::option::Option::Some(RpcRequest_oneof_arg::getAdcRaw(v)) => v,
                _ => panic!(),
            }
        } else {
            getAdcRaw_In::new()
        }
    }

    pub fn get_getAdcRaw(&self) -> &getAdcRaw_In {
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::getAdcRaw(ref v)) => v,
            _ => getAdcRaw_In::default_instance(),
        }
    }

    // optional .linkbot.robot.getBatteryVoltage.In getBatteryVoltage = 19;

    pub fn clear_getBatteryVoltage(&mut self) {
        self.arg = ::std::option::Option::None;
    }

    pub fn has_getBatteryVoltage(&self) -> bool {
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::getBatteryVoltage(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_getBatteryVoltage(&mut self, v: getBatteryVoltage_In) {
        self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::getBatteryVoltage(v))
    }

    // Mutable pointer to the field.
    pub fn mut_getBatteryVoltage(&mut self) -> &mut getBatteryVoltage_In {
        if let ::std::option::Option::Some(RpcRequest_oneof_arg::getBatteryVoltage(_)) = self.arg {
        } else {
            self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::getBatteryVoltage(getBatteryVoltage_In::new()));
        }
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::getBatteryVoltage(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_getBatteryVoltage(&mut self) -> getBatteryVoltage_In {
        if self.has_getBatteryVoltage() {
            match self.arg.take() {
                ::std::option::Option::Some(RpcRequest_oneof_arg::getBatteryVoltage(v)) => v,
                _ => panic!(),
            }
        } else {
            getBatteryVoltage_In::new()
        }
    }

    pub fn get_getBatteryVoltage(&self) -> &getBatteryVoltage_In {
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::getBatteryVoltage(ref v)) => v,
            _ => getBatteryVoltage_In::default_instance(),
        }
    }

    // optional .linkbot.robot.getAccelerometerData.In getAccelerometerData = 20;

    pub fn clear_getAccelerometerData(&mut self) {
        self.arg = ::std::option::Option::None;
    }

    pub fn has_getAccelerometerData(&self) -> bool {
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::getAccelerometerData(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_getAccelerometerData(&mut self, v: getAccelerometerData_In) {
        self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::getAccelerometerData(v))
    }

    // Mutable pointer to the field.
    pub fn mut_getAccelerometerData(&mut self) -> &mut getAccelerometerData_In {
        if let ::std::option::Option::Some(RpcRequest_oneof_arg::getAccelerometerData(_)) = self.arg {
        } else {
            self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::getAccelerometerData(getAccelerometerData_In::new()));
        }
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::getAccelerometerData(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_getAccelerometerData(&mut self) -> getAccelerometerData_In {
        if self.has_getAccelerometerData() {
            match self.arg.take() {
                ::std::option::Option::Some(RpcRequest_oneof_arg::getAccelerometerData(v)) => v,
                _ => panic!(),
            }
        } else {
            getAccelerometerData_In::new()
        }
    }

    pub fn get_getAccelerometerData(&self) -> &getAccelerometerData_In {
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::getAccelerometerData(ref v)) => v,
            _ => getAccelerometerData_In::default_instance(),
        }
    }

    // optional .linkbot.robot.getButtonState.In getButtonState = 21;

    pub fn clear_getButtonState(&mut self) {
        self.arg = ::std::option::Option::None;
    }

    pub fn has_getButtonState(&self) -> bool {
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::getButtonState(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_getButtonState(&mut self, v: getButtonState_In) {
        self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::getButtonState(v))
    }

    // Mutable pointer to the field.
    pub fn mut_getButtonState(&mut self) -> &mut getButtonState_In {
        if let ::std::option::Option::Some(RpcRequest_oneof_arg::getButtonState(_)) = self.arg {
        } else {
            self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::getButtonState(getButtonState_In::new()));
        }
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::getButtonState(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_getButtonState(&mut self) -> getButtonState_In {
        if self.has_getButtonState() {
            match self.arg.take() {
                ::std::option::Option::Some(RpcRequest_oneof_arg::getButtonState(v)) => v,
                _ => panic!(),
            }
        } else {
            getButtonState_In::new()
        }
    }

    pub fn get_getButtonState(&self) -> &getButtonState_In {
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::getButtonState(ref v)) => v,
            _ => getButtonState_In::default_instance(),
        }
    }

    // optional .linkbot.robot.getEncoderValues.In getEncoderValues = 22;

    pub fn clear_getEncoderValues(&mut self) {
        self.arg = ::std::option::Option::None;
    }

    pub fn has_getEncoderValues(&self) -> bool {
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::getEncoderValues(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_getEncoderValues(&mut self, v: getEncoderValues_In) {
        self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::getEncoderValues(v))
    }

    // Mutable pointer to the field.
    pub fn mut_getEncoderValues(&mut self) -> &mut getEncoderValues_In {
        if let ::std::option::Option::Some(RpcRequest_oneof_arg::getEncoderValues(_)) = self.arg {
        } else {
            self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::getEncoderValues(getEncoderValues_In::new()));
        }
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::getEncoderValues(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_getEncoderValues(&mut self) -> getEncoderValues_In {
        if self.has_getEncoderValues() {
            match self.arg.take() {
                ::std::option::Option::Some(RpcRequest_oneof_arg::getEncoderValues(v)) => v,
                _ => panic!(),
            }
        } else {
            getEncoderValues_In::new()
        }
    }

    pub fn get_getEncoderValues(&self) -> &getEncoderValues_In {
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::getEncoderValues(ref v)) => v,
            _ => getEncoderValues_In::default_instance(),
        }
    }

    // optional .linkbot.robot.getJointStates.In getJointStates = 23;

    pub fn clear_getJointStates(&mut self) {
        self.arg = ::std::option::Option::None;
    }

    pub fn has_getJointStates(&self) -> bool {
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::getJointStates(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_getJointStates(&mut self, v: getJointStates_In) {
        self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::getJointStates(v))
    }

    // Mutable pointer to the field.
    pub fn mut_getJointStates(&mut self) -> &mut getJointStates_In {
        if let ::std::option::Option::Some(RpcRequest_oneof_arg::getJointStates(_)) = self.arg {
        } else {
            self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::getJointStates(getJointStates_In::new()));
        }
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::getJointStates(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_getJointStates(&mut self) -> getJointStates_In {
        if self.has_getJointStates() {
            match self.arg.take() {
                ::std::option::Option::Some(RpcRequest_oneof_arg::getJointStates(v)) => v,
                _ => panic!(),
            }
        } else {
            getJointStates_In::new()
        }
    }

    pub fn get_getJointStates(&self) -> &getJointStates_In {
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::getJointStates(ref v)) => v,
            _ => getJointStates_In::default_instance(),
        }
    }

    // optional .linkbot.robot.enableAccelerometerEvent.In enableAccelerometerEvent = 24;

    pub fn clear_enableAccelerometerEvent(&mut self) {
        self.arg = ::std::option::Option::None;
    }

    pub fn has_enableAccelerometerEvent(&self) -> bool {
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::enableAccelerometerEvent(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_enableAccelerometerEvent(&mut self, v: enableAccelerometerEvent_In) {
        self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::enableAccelerometerEvent(v))
    }

    // Mutable pointer to the field.
    pub fn mut_enableAccelerometerEvent(&mut self) -> &mut enableAccelerometerEvent_In {
        if let ::std::option::Option::Some(RpcRequest_oneof_arg::enableAccelerometerEvent(_)) = self.arg {
        } else {
            self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::enableAccelerometerEvent(enableAccelerometerEvent_In::new()));
        }
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::enableAccelerometerEvent(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_enableAccelerometerEvent(&mut self) -> enableAccelerometerEvent_In {
        if self.has_enableAccelerometerEvent() {
            match self.arg.take() {
                ::std::option::Option::Some(RpcRequest_oneof_arg::enableAccelerometerEvent(v)) => v,
                _ => panic!(),
            }
        } else {
            enableAccelerometerEvent_In::new()
        }
    }

    pub fn get_enableAccelerometerEvent(&self) -> &enableAccelerometerEvent_In {
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::enableAccelerometerEvent(ref v)) => v,
            _ => enableAccelerometerEvent_In::default_instance(),
        }
    }

    // optional .linkbot.robot.enableButtonEvent.In enableButtonEvent = 25;

    pub fn clear_enableButtonEvent(&mut self) {
        self.arg = ::std::option::Option::None;
    }

    pub fn has_enableButtonEvent(&self) -> bool {
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::enableButtonEvent(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_enableButtonEvent(&mut self, v: enableButtonEvent_In) {
        self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::enableButtonEvent(v))
    }

    // Mutable pointer to the field.
    pub fn mut_enableButtonEvent(&mut self) -> &mut enableButtonEvent_In {
        if let ::std::option::Option::Some(RpcRequest_oneof_arg::enableButtonEvent(_)) = self.arg {
        } else {
            self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::enableButtonEvent(enableButtonEvent_In::new()));
        }
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::enableButtonEvent(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_enableButtonEvent(&mut self) -> enableButtonEvent_In {
        if self.has_enableButtonEvent() {
            match self.arg.take() {
                ::std::option::Option::Some(RpcRequest_oneof_arg::enableButtonEvent(v)) => v,
                _ => panic!(),
            }
        } else {
            enableButtonEvent_In::new()
        }
    }

    pub fn get_enableButtonEvent(&self) -> &enableButtonEvent_In {
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::enableButtonEvent(ref v)) => v,
            _ => enableButtonEvent_In::default_instance(),
        }
    }

    // optional .linkbot.robot.enableEncoderEvent.In enableEncoderEvent = 26;

    pub fn clear_enableEncoderEvent(&mut self) {
        self.arg = ::std::option::Option::None;
    }

    pub fn has_enableEncoderEvent(&self) -> bool {
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::enableEncoderEvent(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_enableEncoderEvent(&mut self, v: enableEncoderEvent_In) {
        self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::enableEncoderEvent(v))
    }

    // Mutable pointer to the field.
    pub fn mut_enableEncoderEvent(&mut self) -> &mut enableEncoderEvent_In {
        if let ::std::option::Option::Some(RpcRequest_oneof_arg::enableEncoderEvent(_)) = self.arg {
        } else {
            self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::enableEncoderEvent(enableEncoderEvent_In::new()));
        }
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::enableEncoderEvent(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_enableEncoderEvent(&mut self) -> enableEncoderEvent_In {
        if self.has_enableEncoderEvent() {
            match self.arg.take() {
                ::std::option::Option::Some(RpcRequest_oneof_arg::enableEncoderEvent(v)) => v,
                _ => panic!(),
            }
        } else {
            enableEncoderEvent_In::new()
        }
    }

    pub fn get_enableEncoderEvent(&self) -> &enableEncoderEvent_In {
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::enableEncoderEvent(ref v)) => v,
            _ => enableEncoderEvent_In::default_instance(),
        }
    }

    // optional .linkbot.robot.enableJointEvent.In enableJointEvent = 27;

    pub fn clear_enableJointEvent(&mut self) {
        self.arg = ::std::option::Option::None;
    }

    pub fn has_enableJointEvent(&self) -> bool {
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::enableJointEvent(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_enableJointEvent(&mut self, v: enableJointEvent_In) {
        self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::enableJointEvent(v))
    }

    // Mutable pointer to the field.
    pub fn mut_enableJointEvent(&mut self) -> &mut enableJointEvent_In {
        if let ::std::option::Option::Some(RpcRequest_oneof_arg::enableJointEvent(_)) = self.arg {
        } else {
            self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::enableJointEvent(enableJointEvent_In::new()));
        }
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::enableJointEvent(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_enableJointEvent(&mut self) -> enableJointEvent_In {
        if self.has_enableJointEvent() {
            match self.arg.take() {
                ::std::option::Option::Some(RpcRequest_oneof_arg::enableJointEvent(v)) => v,
                _ => panic!(),
            }
        } else {
            enableJointEvent_In::new()
        }
    }

    pub fn get_enableJointEvent(&self) -> &enableJointEvent_In {
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::enableJointEvent(ref v)) => v,
            _ => enableJointEvent_In::default_instance(),
        }
    }

    // optional .linkbot.robot.getBuzzerFrequency.In getBuzzerFrequency = 2;

    pub fn clear_getBuzzerFrequency(&mut self) {
        self.arg = ::std::option::Option::None;
    }

    pub fn has_getBuzzerFrequency(&self) -> bool {
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::getBuzzerFrequency(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_getBuzzerFrequency(&mut self, v: getBuzzerFrequency_In) {
        self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::getBuzzerFrequency(v))
    }

    // Mutable pointer to the field.
    pub fn mut_getBuzzerFrequency(&mut self) -> &mut getBuzzerFrequency_In {
        if let ::std::option::Option::Some(RpcRequest_oneof_arg::getBuzzerFrequency(_)) = self.arg {
        } else {
            self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::getBuzzerFrequency(getBuzzerFrequency_In::new()));
        }
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::getBuzzerFrequency(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_getBuzzerFrequency(&mut self) -> getBuzzerFrequency_In {
        if self.has_getBuzzerFrequency() {
            match self.arg.take() {
                ::std::option::Option::Some(RpcRequest_oneof_arg::getBuzzerFrequency(v)) => v,
                _ => panic!(),
            }
        } else {
            getBuzzerFrequency_In::new()
        }
    }

    pub fn get_getBuzzerFrequency(&self) -> &getBuzzerFrequency_In {
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::getBuzzerFrequency(ref v)) => v,
            _ => getBuzzerFrequency_In::default_instance(),
        }
    }

    // optional .linkbot.robot.getLedColor.In getLedColor = 3;

    pub fn clear_getLedColor(&mut self) {
        self.arg = ::std::option::Option::None;
    }

    pub fn has_getLedColor(&self) -> bool {
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::getLedColor(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_getLedColor(&mut self, v: getLedColor_In) {
        self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::getLedColor(v))
    }

    // Mutable pointer to the field.
    pub fn mut_getLedColor(&mut self) -> &mut getLedColor_In {
        if let ::std::option::Option::Some(RpcRequest_oneof_arg::getLedColor(_)) = self.arg {
        } else {
            self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::getLedColor(getLedColor_In::new()));
        }
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::getLedColor(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_getLedColor(&mut self) -> getLedColor_In {
        if self.has_getLedColor() {
            match self.arg.take() {
                ::std::option::Option::Some(RpcRequest_oneof_arg::getLedColor(v)) => v,
                _ => panic!(),
            }
        } else {
            getLedColor_In::new()
        }
    }

    pub fn get_getLedColor(&self) -> &getLedColor_In {
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::getLedColor(ref v)) => v,
            _ => getLedColor_In::default_instance(),
        }
    }

    // optional .linkbot.robot.getMotorControllerOmega.In getMotorControllerOmega = 28;

    pub fn clear_getMotorControllerOmega(&mut self) {
        self.arg = ::std::option::Option::None;
    }

    pub fn has_getMotorControllerOmega(&self) -> bool {
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::getMotorControllerOmega(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_getMotorControllerOmega(&mut self, v: getMotorControllerOmega_In) {
        self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::getMotorControllerOmega(v))
    }

    // Mutable pointer to the field.
    pub fn mut_getMotorControllerOmega(&mut self) -> &mut getMotorControllerOmega_In {
        if let ::std::option::Option::Some(RpcRequest_oneof_arg::getMotorControllerOmega(_)) = self.arg {
        } else {
            self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::getMotorControllerOmega(getMotorControllerOmega_In::new()));
        }
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::getMotorControllerOmega(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_getMotorControllerOmega(&mut self) -> getMotorControllerOmega_In {
        if self.has_getMotorControllerOmega() {
            match self.arg.take() {
                ::std::option::Option::Some(RpcRequest_oneof_arg::getMotorControllerOmega(v)) => v,
                _ => panic!(),
            }
        } else {
            getMotorControllerOmega_In::new()
        }
    }

    pub fn get_getMotorControllerOmega(&self) -> &getMotorControllerOmega_In {
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::getMotorControllerOmega(ref v)) => v,
            _ => getMotorControllerOmega_In::default_instance(),
        }
    }

    // optional .linkbot.robot.getMotorControllerAlphaI.In getMotorControllerAlphaI = 29;

    pub fn clear_getMotorControllerAlphaI(&mut self) {
        self.arg = ::std::option::Option::None;
    }

    pub fn has_getMotorControllerAlphaI(&self) -> bool {
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::getMotorControllerAlphaI(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_getMotorControllerAlphaI(&mut self, v: getMotorControllerAlphaI_In) {
        self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::getMotorControllerAlphaI(v))
    }

    // Mutable pointer to the field.
    pub fn mut_getMotorControllerAlphaI(&mut self) -> &mut getMotorControllerAlphaI_In {
        if let ::std::option::Option::Some(RpcRequest_oneof_arg::getMotorControllerAlphaI(_)) = self.arg {
        } else {
            self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::getMotorControllerAlphaI(getMotorControllerAlphaI_In::new()));
        }
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::getMotorControllerAlphaI(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_getMotorControllerAlphaI(&mut self) -> getMotorControllerAlphaI_In {
        if self.has_getMotorControllerAlphaI() {
            match self.arg.take() {
                ::std::option::Option::Some(RpcRequest_oneof_arg::getMotorControllerAlphaI(v)) => v,
                _ => panic!(),
            }
        } else {
            getMotorControllerAlphaI_In::new()
        }
    }

    pub fn get_getMotorControllerAlphaI(&self) -> &getMotorControllerAlphaI_In {
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::getMotorControllerAlphaI(ref v)) => v,
            _ => getMotorControllerAlphaI_In::default_instance(),
        }
    }

    // optional .linkbot.robot.getMotorControllerAlphaF.In getMotorControllerAlphaF = 30;

    pub fn clear_getMotorControllerAlphaF(&mut self) {
        self.arg = ::std::option::Option::None;
    }

    pub fn has_getMotorControllerAlphaF(&self) -> bool {
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::getMotorControllerAlphaF(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_getMotorControllerAlphaF(&mut self, v: getMotorControllerAlphaF_In) {
        self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::getMotorControllerAlphaF(v))
    }

    // Mutable pointer to the field.
    pub fn mut_getMotorControllerAlphaF(&mut self) -> &mut getMotorControllerAlphaF_In {
        if let ::std::option::Option::Some(RpcRequest_oneof_arg::getMotorControllerAlphaF(_)) = self.arg {
        } else {
            self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::getMotorControllerAlphaF(getMotorControllerAlphaF_In::new()));
        }
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::getMotorControllerAlphaF(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_getMotorControllerAlphaF(&mut self) -> getMotorControllerAlphaF_In {
        if self.has_getMotorControllerAlphaF() {
            match self.arg.take() {
                ::std::option::Option::Some(RpcRequest_oneof_arg::getMotorControllerAlphaF(v)) => v,
                _ => panic!(),
            }
        } else {
            getMotorControllerAlphaF_In::new()
        }
    }

    pub fn get_getMotorControllerAlphaF(&self) -> &getMotorControllerAlphaF_In {
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::getMotorControllerAlphaF(ref v)) => v,
            _ => getMotorControllerAlphaF_In::default_instance(),
        }
    }

    // optional .linkbot.robot.getMotorControllerProportionalGain.In getMotorControllerProportionalGain = 31;

    pub fn clear_getMotorControllerProportionalGain(&mut self) {
        self.arg = ::std::option::Option::None;
    }

    pub fn has_getMotorControllerProportionalGain(&self) -> bool {
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::getMotorControllerProportionalGain(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_getMotorControllerProportionalGain(&mut self, v: getMotorControllerProportionalGain_In) {
        self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::getMotorControllerProportionalGain(v))
    }

    // Mutable pointer to the field.
    pub fn mut_getMotorControllerProportionalGain(&mut self) -> &mut getMotorControllerProportionalGain_In {
        if let ::std::option::Option::Some(RpcRequest_oneof_arg::getMotorControllerProportionalGain(_)) = self.arg {
        } else {
            self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::getMotorControllerProportionalGain(getMotorControllerProportionalGain_In::new()));
        }
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::getMotorControllerProportionalGain(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_getMotorControllerProportionalGain(&mut self) -> getMotorControllerProportionalGain_In {
        if self.has_getMotorControllerProportionalGain() {
            match self.arg.take() {
                ::std::option::Option::Some(RpcRequest_oneof_arg::getMotorControllerProportionalGain(v)) => v,
                _ => panic!(),
            }
        } else {
            getMotorControllerProportionalGain_In::new()
        }
    }

    pub fn get_getMotorControllerProportionalGain(&self) -> &getMotorControllerProportionalGain_In {
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::getMotorControllerProportionalGain(ref v)) => v,
            _ => getMotorControllerProportionalGain_In::default_instance(),
        }
    }

    // optional .linkbot.robot.getMotorControllerIntegratorGain.In getMotorControllerIntegratorGain = 32;

    pub fn clear_getMotorControllerIntegratorGain(&mut self) {
        self.arg = ::std::option::Option::None;
    }

    pub fn has_getMotorControllerIntegratorGain(&self) -> bool {
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::getMotorControllerIntegratorGain(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_getMotorControllerIntegratorGain(&mut self, v: getMotorControllerIntegratorGain_In) {
        self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::getMotorControllerIntegratorGain(v))
    }

    // Mutable pointer to the field.
    pub fn mut_getMotorControllerIntegratorGain(&mut self) -> &mut getMotorControllerIntegratorGain_In {
        if let ::std::option::Option::Some(RpcRequest_oneof_arg::getMotorControllerIntegratorGain(_)) = self.arg {
        } else {
            self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::getMotorControllerIntegratorGain(getMotorControllerIntegratorGain_In::new()));
        }
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::getMotorControllerIntegratorGain(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_getMotorControllerIntegratorGain(&mut self) -> getMotorControllerIntegratorGain_In {
        if self.has_getMotorControllerIntegratorGain() {
            match self.arg.take() {
                ::std::option::Option::Some(RpcRequest_oneof_arg::getMotorControllerIntegratorGain(v)) => v,
                _ => panic!(),
            }
        } else {
            getMotorControllerIntegratorGain_In::new()
        }
    }

    pub fn get_getMotorControllerIntegratorGain(&self) -> &getMotorControllerIntegratorGain_In {
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::getMotorControllerIntegratorGain(ref v)) => v,
            _ => getMotorControllerIntegratorGain_In::default_instance(),
        }
    }

    // optional .linkbot.robot.getMotorControllerDerivativeGain.In getMotorControllerDerivativeGain = 33;

    pub fn clear_getMotorControllerDerivativeGain(&mut self) {
        self.arg = ::std::option::Option::None;
    }

    pub fn has_getMotorControllerDerivativeGain(&self) -> bool {
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::getMotorControllerDerivativeGain(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_getMotorControllerDerivativeGain(&mut self, v: getMotorControllerDerivativeGain_In) {
        self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::getMotorControllerDerivativeGain(v))
    }

    // Mutable pointer to the field.
    pub fn mut_getMotorControllerDerivativeGain(&mut self) -> &mut getMotorControllerDerivativeGain_In {
        if let ::std::option::Option::Some(RpcRequest_oneof_arg::getMotorControllerDerivativeGain(_)) = self.arg {
        } else {
            self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::getMotorControllerDerivativeGain(getMotorControllerDerivativeGain_In::new()));
        }
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::getMotorControllerDerivativeGain(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_getMotorControllerDerivativeGain(&mut self) -> getMotorControllerDerivativeGain_In {
        if self.has_getMotorControllerDerivativeGain() {
            match self.arg.take() {
                ::std::option::Option::Some(RpcRequest_oneof_arg::getMotorControllerDerivativeGain(v)) => v,
                _ => panic!(),
            }
        } else {
            getMotorControllerDerivativeGain_In::new()
        }
    }

    pub fn get_getMotorControllerDerivativeGain(&self) -> &getMotorControllerDerivativeGain_In {
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::getMotorControllerDerivativeGain(ref v)) => v,
            _ => getMotorControllerDerivativeGain_In::default_instance(),
        }
    }

    // optional .linkbot.robot.getMotorControllerSafetyThreshold.In getMotorControllerSafetyThreshold = 34;

    pub fn clear_getMotorControllerSafetyThreshold(&mut self) {
        self.arg = ::std::option::Option::None;
    }

    pub fn has_getMotorControllerSafetyThreshold(&self) -> bool {
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::getMotorControllerSafetyThreshold(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_getMotorControllerSafetyThreshold(&mut self, v: getMotorControllerSafetyThreshold_In) {
        self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::getMotorControllerSafetyThreshold(v))
    }

    // Mutable pointer to the field.
    pub fn mut_getMotorControllerSafetyThreshold(&mut self) -> &mut getMotorControllerSafetyThreshold_In {
        if let ::std::option::Option::Some(RpcRequest_oneof_arg::getMotorControllerSafetyThreshold(_)) = self.arg {
        } else {
            self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::getMotorControllerSafetyThreshold(getMotorControllerSafetyThreshold_In::new()));
        }
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::getMotorControllerSafetyThreshold(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_getMotorControllerSafetyThreshold(&mut self) -> getMotorControllerSafetyThreshold_In {
        if self.has_getMotorControllerSafetyThreshold() {
            match self.arg.take() {
                ::std::option::Option::Some(RpcRequest_oneof_arg::getMotorControllerSafetyThreshold(v)) => v,
                _ => panic!(),
            }
        } else {
            getMotorControllerSafetyThreshold_In::new()
        }
    }

    pub fn get_getMotorControllerSafetyThreshold(&self) -> &getMotorControllerSafetyThreshold_In {
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::getMotorControllerSafetyThreshold(ref v)) => v,
            _ => getMotorControllerSafetyThreshold_In::default_instance(),
        }
    }

    // optional .linkbot.robot.getMotorControllerSafetyAngle.In getMotorControllerSafetyAngle = 35;

    pub fn clear_getMotorControllerSafetyAngle(&mut self) {
        self.arg = ::std::option::Option::None;
    }

    pub fn has_getMotorControllerSafetyAngle(&self) -> bool {
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::getMotorControllerSafetyAngle(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_getMotorControllerSafetyAngle(&mut self, v: getMotorControllerSafetyAngle_In) {
        self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::getMotorControllerSafetyAngle(v))
    }

    // Mutable pointer to the field.
    pub fn mut_getMotorControllerSafetyAngle(&mut self) -> &mut getMotorControllerSafetyAngle_In {
        if let ::std::option::Option::Some(RpcRequest_oneof_arg::getMotorControllerSafetyAngle(_)) = self.arg {
        } else {
            self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::getMotorControllerSafetyAngle(getMotorControllerSafetyAngle_In::new()));
        }
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::getMotorControllerSafetyAngle(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_getMotorControllerSafetyAngle(&mut self) -> getMotorControllerSafetyAngle_In {
        if self.has_getMotorControllerSafetyAngle() {
            match self.arg.take() {
                ::std::option::Option::Some(RpcRequest_oneof_arg::getMotorControllerSafetyAngle(v)) => v,
                _ => panic!(),
            }
        } else {
            getMotorControllerSafetyAngle_In::new()
        }
    }

    pub fn get_getMotorControllerSafetyAngle(&self) -> &getMotorControllerSafetyAngle_In {
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::getMotorControllerSafetyAngle(ref v)) => v,
            _ => getMotorControllerSafetyAngle_In::default_instance(),
        }
    }

    // optional .linkbot.robot.setBuzzerFrequency.In setBuzzerFrequency = 4;

    pub fn clear_setBuzzerFrequency(&mut self) {
        self.arg = ::std::option::Option::None;
    }

    pub fn has_setBuzzerFrequency(&self) -> bool {
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::setBuzzerFrequency(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_setBuzzerFrequency(&mut self, v: setBuzzerFrequency_In) {
        self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::setBuzzerFrequency(v))
    }

    // Mutable pointer to the field.
    pub fn mut_setBuzzerFrequency(&mut self) -> &mut setBuzzerFrequency_In {
        if let ::std::option::Option::Some(RpcRequest_oneof_arg::setBuzzerFrequency(_)) = self.arg {
        } else {
            self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::setBuzzerFrequency(setBuzzerFrequency_In::new()));
        }
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::setBuzzerFrequency(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_setBuzzerFrequency(&mut self) -> setBuzzerFrequency_In {
        if self.has_setBuzzerFrequency() {
            match self.arg.take() {
                ::std::option::Option::Some(RpcRequest_oneof_arg::setBuzzerFrequency(v)) => v,
                _ => panic!(),
            }
        } else {
            setBuzzerFrequency_In::new()
        }
    }

    pub fn get_setBuzzerFrequency(&self) -> &setBuzzerFrequency_In {
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::setBuzzerFrequency(ref v)) => v,
            _ => setBuzzerFrequency_In::default_instance(),
        }
    }

    // optional .linkbot.robot.setLedColor.In setLedColor = 5;

    pub fn clear_setLedColor(&mut self) {
        self.arg = ::std::option::Option::None;
    }

    pub fn has_setLedColor(&self) -> bool {
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::setLedColor(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_setLedColor(&mut self, v: setLedColor_In) {
        self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::setLedColor(v))
    }

    // Mutable pointer to the field.
    pub fn mut_setLedColor(&mut self) -> &mut setLedColor_In {
        if let ::std::option::Option::Some(RpcRequest_oneof_arg::setLedColor(_)) = self.arg {
        } else {
            self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::setLedColor(setLedColor_In::new()));
        }
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::setLedColor(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_setLedColor(&mut self) -> setLedColor_In {
        if self.has_setLedColor() {
            match self.arg.take() {
                ::std::option::Option::Some(RpcRequest_oneof_arg::setLedColor(v)) => v,
                _ => panic!(),
            }
        } else {
            setLedColor_In::new()
        }
    }

    pub fn get_setLedColor(&self) -> &setLedColor_In {
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::setLedColor(ref v)) => v,
            _ => setLedColor_In::default_instance(),
        }
    }

    // optional .linkbot.robot.setMotorControllerOmega.In setMotorControllerOmega = 36;

    pub fn clear_setMotorControllerOmega(&mut self) {
        self.arg = ::std::option::Option::None;
    }

    pub fn has_setMotorControllerOmega(&self) -> bool {
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::setMotorControllerOmega(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_setMotorControllerOmega(&mut self, v: setMotorControllerOmega_In) {
        self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::setMotorControllerOmega(v))
    }

    // Mutable pointer to the field.
    pub fn mut_setMotorControllerOmega(&mut self) -> &mut setMotorControllerOmega_In {
        if let ::std::option::Option::Some(RpcRequest_oneof_arg::setMotorControllerOmega(_)) = self.arg {
        } else {
            self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::setMotorControllerOmega(setMotorControllerOmega_In::new()));
        }
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::setMotorControllerOmega(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_setMotorControllerOmega(&mut self) -> setMotorControllerOmega_In {
        if self.has_setMotorControllerOmega() {
            match self.arg.take() {
                ::std::option::Option::Some(RpcRequest_oneof_arg::setMotorControllerOmega(v)) => v,
                _ => panic!(),
            }
        } else {
            setMotorControllerOmega_In::new()
        }
    }

    pub fn get_setMotorControllerOmega(&self) -> &setMotorControllerOmega_In {
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::setMotorControllerOmega(ref v)) => v,
            _ => setMotorControllerOmega_In::default_instance(),
        }
    }

    // optional .linkbot.robot.setMotorControllerAlphaI.In setMotorControllerAlphaI = 37;

    pub fn clear_setMotorControllerAlphaI(&mut self) {
        self.arg = ::std::option::Option::None;
    }

    pub fn has_setMotorControllerAlphaI(&self) -> bool {
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::setMotorControllerAlphaI(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_setMotorControllerAlphaI(&mut self, v: setMotorControllerAlphaI_In) {
        self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::setMotorControllerAlphaI(v))
    }

    // Mutable pointer to the field.
    pub fn mut_setMotorControllerAlphaI(&mut self) -> &mut setMotorControllerAlphaI_In {
        if let ::std::option::Option::Some(RpcRequest_oneof_arg::setMotorControllerAlphaI(_)) = self.arg {
        } else {
            self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::setMotorControllerAlphaI(setMotorControllerAlphaI_In::new()));
        }
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::setMotorControllerAlphaI(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_setMotorControllerAlphaI(&mut self) -> setMotorControllerAlphaI_In {
        if self.has_setMotorControllerAlphaI() {
            match self.arg.take() {
                ::std::option::Option::Some(RpcRequest_oneof_arg::setMotorControllerAlphaI(v)) => v,
                _ => panic!(),
            }
        } else {
            setMotorControllerAlphaI_In::new()
        }
    }

    pub fn get_setMotorControllerAlphaI(&self) -> &setMotorControllerAlphaI_In {
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::setMotorControllerAlphaI(ref v)) => v,
            _ => setMotorControllerAlphaI_In::default_instance(),
        }
    }

    // optional .linkbot.robot.setMotorControllerAlphaF.In setMotorControllerAlphaF = 38;

    pub fn clear_setMotorControllerAlphaF(&mut self) {
        self.arg = ::std::option::Option::None;
    }

    pub fn has_setMotorControllerAlphaF(&self) -> bool {
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::setMotorControllerAlphaF(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_setMotorControllerAlphaF(&mut self, v: setMotorControllerAlphaF_In) {
        self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::setMotorControllerAlphaF(v))
    }

    // Mutable pointer to the field.
    pub fn mut_setMotorControllerAlphaF(&mut self) -> &mut setMotorControllerAlphaF_In {
        if let ::std::option::Option::Some(RpcRequest_oneof_arg::setMotorControllerAlphaF(_)) = self.arg {
        } else {
            self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::setMotorControllerAlphaF(setMotorControllerAlphaF_In::new()));
        }
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::setMotorControllerAlphaF(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_setMotorControllerAlphaF(&mut self) -> setMotorControllerAlphaF_In {
        if self.has_setMotorControllerAlphaF() {
            match self.arg.take() {
                ::std::option::Option::Some(RpcRequest_oneof_arg::setMotorControllerAlphaF(v)) => v,
                _ => panic!(),
            }
        } else {
            setMotorControllerAlphaF_In::new()
        }
    }

    pub fn get_setMotorControllerAlphaF(&self) -> &setMotorControllerAlphaF_In {
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::setMotorControllerAlphaF(ref v)) => v,
            _ => setMotorControllerAlphaF_In::default_instance(),
        }
    }

    // optional .linkbot.robot.setMotorControllerProportionalGain.In setMotorControllerProportionalGain = 39;

    pub fn clear_setMotorControllerProportionalGain(&mut self) {
        self.arg = ::std::option::Option::None;
    }

    pub fn has_setMotorControllerProportionalGain(&self) -> bool {
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::setMotorControllerProportionalGain(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_setMotorControllerProportionalGain(&mut self, v: setMotorControllerProportionalGain_In) {
        self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::setMotorControllerProportionalGain(v))
    }

    // Mutable pointer to the field.
    pub fn mut_setMotorControllerProportionalGain(&mut self) -> &mut setMotorControllerProportionalGain_In {
        if let ::std::option::Option::Some(RpcRequest_oneof_arg::setMotorControllerProportionalGain(_)) = self.arg {
        } else {
            self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::setMotorControllerProportionalGain(setMotorControllerProportionalGain_In::new()));
        }
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::setMotorControllerProportionalGain(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_setMotorControllerProportionalGain(&mut self) -> setMotorControllerProportionalGain_In {
        if self.has_setMotorControllerProportionalGain() {
            match self.arg.take() {
                ::std::option::Option::Some(RpcRequest_oneof_arg::setMotorControllerProportionalGain(v)) => v,
                _ => panic!(),
            }
        } else {
            setMotorControllerProportionalGain_In::new()
        }
    }

    pub fn get_setMotorControllerProportionalGain(&self) -> &setMotorControllerProportionalGain_In {
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::setMotorControllerProportionalGain(ref v)) => v,
            _ => setMotorControllerProportionalGain_In::default_instance(),
        }
    }

    // optional .linkbot.robot.setMotorControllerIntegratorGain.In setMotorControllerIntegratorGain = 40;

    pub fn clear_setMotorControllerIntegratorGain(&mut self) {
        self.arg = ::std::option::Option::None;
    }

    pub fn has_setMotorControllerIntegratorGain(&self) -> bool {
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::setMotorControllerIntegratorGain(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_setMotorControllerIntegratorGain(&mut self, v: setMotorControllerIntegratorGain_In) {
        self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::setMotorControllerIntegratorGain(v))
    }

    // Mutable pointer to the field.
    pub fn mut_setMotorControllerIntegratorGain(&mut self) -> &mut setMotorControllerIntegratorGain_In {
        if let ::std::option::Option::Some(RpcRequest_oneof_arg::setMotorControllerIntegratorGain(_)) = self.arg {
        } else {
            self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::setMotorControllerIntegratorGain(setMotorControllerIntegratorGain_In::new()));
        }
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::setMotorControllerIntegratorGain(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_setMotorControllerIntegratorGain(&mut self) -> setMotorControllerIntegratorGain_In {
        if self.has_setMotorControllerIntegratorGain() {
            match self.arg.take() {
                ::std::option::Option::Some(RpcRequest_oneof_arg::setMotorControllerIntegratorGain(v)) => v,
                _ => panic!(),
            }
        } else {
            setMotorControllerIntegratorGain_In::new()
        }
    }

    pub fn get_setMotorControllerIntegratorGain(&self) -> &setMotorControllerIntegratorGain_In {
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::setMotorControllerIntegratorGain(ref v)) => v,
            _ => setMotorControllerIntegratorGain_In::default_instance(),
        }
    }

    // optional .linkbot.robot.setMotorControllerDerivativeGain.In setMotorControllerDerivativeGain = 41;

    pub fn clear_setMotorControllerDerivativeGain(&mut self) {
        self.arg = ::std::option::Option::None;
    }

    pub fn has_setMotorControllerDerivativeGain(&self) -> bool {
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::setMotorControllerDerivativeGain(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_setMotorControllerDerivativeGain(&mut self, v: setMotorControllerDerivativeGain_In) {
        self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::setMotorControllerDerivativeGain(v))
    }

    // Mutable pointer to the field.
    pub fn mut_setMotorControllerDerivativeGain(&mut self) -> &mut setMotorControllerDerivativeGain_In {
        if let ::std::option::Option::Some(RpcRequest_oneof_arg::setMotorControllerDerivativeGain(_)) = self.arg {
        } else {
            self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::setMotorControllerDerivativeGain(setMotorControllerDerivativeGain_In::new()));
        }
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::setMotorControllerDerivativeGain(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_setMotorControllerDerivativeGain(&mut self) -> setMotorControllerDerivativeGain_In {
        if self.has_setMotorControllerDerivativeGain() {
            match self.arg.take() {
                ::std::option::Option::Some(RpcRequest_oneof_arg::setMotorControllerDerivativeGain(v)) => v,
                _ => panic!(),
            }
        } else {
            setMotorControllerDerivativeGain_In::new()
        }
    }

    pub fn get_setMotorControllerDerivativeGain(&self) -> &setMotorControllerDerivativeGain_In {
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::setMotorControllerDerivativeGain(ref v)) => v,
            _ => setMotorControllerDerivativeGain_In::default_instance(),
        }
    }

    // optional .linkbot.robot.setMotorControllerSafetyThreshold.In setMotorControllerSafetyThreshold = 42;

    pub fn clear_setMotorControllerSafetyThreshold(&mut self) {
        self.arg = ::std::option::Option::None;
    }

    pub fn has_setMotorControllerSafetyThreshold(&self) -> bool {
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::setMotorControllerSafetyThreshold(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_setMotorControllerSafetyThreshold(&mut self, v: setMotorControllerSafetyThreshold_In) {
        self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::setMotorControllerSafetyThreshold(v))
    }

    // Mutable pointer to the field.
    pub fn mut_setMotorControllerSafetyThreshold(&mut self) -> &mut setMotorControllerSafetyThreshold_In {
        if let ::std::option::Option::Some(RpcRequest_oneof_arg::setMotorControllerSafetyThreshold(_)) = self.arg {
        } else {
            self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::setMotorControllerSafetyThreshold(setMotorControllerSafetyThreshold_In::new()));
        }
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::setMotorControllerSafetyThreshold(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_setMotorControllerSafetyThreshold(&mut self) -> setMotorControllerSafetyThreshold_In {
        if self.has_setMotorControllerSafetyThreshold() {
            match self.arg.take() {
                ::std::option::Option::Some(RpcRequest_oneof_arg::setMotorControllerSafetyThreshold(v)) => v,
                _ => panic!(),
            }
        } else {
            setMotorControllerSafetyThreshold_In::new()
        }
    }

    pub fn get_setMotorControllerSafetyThreshold(&self) -> &setMotorControllerSafetyThreshold_In {
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::setMotorControllerSafetyThreshold(ref v)) => v,
            _ => setMotorControllerSafetyThreshold_In::default_instance(),
        }
    }

    // optional .linkbot.robot.setMotorControllerSafetyAngle.In setMotorControllerSafetyAngle = 43;

    pub fn clear_setMotorControllerSafetyAngle(&mut self) {
        self.arg = ::std::option::Option::None;
    }

    pub fn has_setMotorControllerSafetyAngle(&self) -> bool {
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::setMotorControllerSafetyAngle(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_setMotorControllerSafetyAngle(&mut self, v: setMotorControllerSafetyAngle_In) {
        self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::setMotorControllerSafetyAngle(v))
    }

    // Mutable pointer to the field.
    pub fn mut_setMotorControllerSafetyAngle(&mut self) -> &mut setMotorControllerSafetyAngle_In {
        if let ::std::option::Option::Some(RpcRequest_oneof_arg::setMotorControllerSafetyAngle(_)) = self.arg {
        } else {
            self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::setMotorControllerSafetyAngle(setMotorControllerSafetyAngle_In::new()));
        }
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::setMotorControllerSafetyAngle(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_setMotorControllerSafetyAngle(&mut self) -> setMotorControllerSafetyAngle_In {
        if self.has_setMotorControllerSafetyAngle() {
            match self.arg.take() {
                ::std::option::Option::Some(RpcRequest_oneof_arg::setMotorControllerSafetyAngle(v)) => v,
                _ => panic!(),
            }
        } else {
            setMotorControllerSafetyAngle_In::new()
        }
    }

    pub fn get_setMotorControllerSafetyAngle(&self) -> &setMotorControllerSafetyAngle_In {
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::setMotorControllerSafetyAngle(ref v)) => v,
            _ => setMotorControllerSafetyAngle_In::default_instance(),
        }
    }

    // optional .linkbot.robot.setResetOnDisconnect.In setResetOnDisconnect = 53;

    pub fn clear_setResetOnDisconnect(&mut self) {
        self.arg = ::std::option::Option::None;
    }

    pub fn has_setResetOnDisconnect(&self) -> bool {
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::setResetOnDisconnect(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_setResetOnDisconnect(&mut self, v: setResetOnDisconnect_In) {
        self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::setResetOnDisconnect(v))
    }

    // Mutable pointer to the field.
    pub fn mut_setResetOnDisconnect(&mut self) -> &mut setResetOnDisconnect_In {
        if let ::std::option::Option::Some(RpcRequest_oneof_arg::setResetOnDisconnect(_)) = self.arg {
        } else {
            self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::setResetOnDisconnect(setResetOnDisconnect_In::new()));
        }
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::setResetOnDisconnect(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_setResetOnDisconnect(&mut self) -> setResetOnDisconnect_In {
        if self.has_setResetOnDisconnect() {
            match self.arg.take() {
                ::std::option::Option::Some(RpcRequest_oneof_arg::setResetOnDisconnect(v)) => v,
                _ => panic!(),
            }
        } else {
            setResetOnDisconnect_In::new()
        }
    }

    pub fn get_setResetOnDisconnect(&self) -> &setResetOnDisconnect_In {
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::setResetOnDisconnect(ref v)) => v,
            _ => setResetOnDisconnect_In::default_instance(),
        }
    }

    // optional .linkbot.robot.resetEncoderRevs.In resetEncoderRevs = 44;

    pub fn clear_resetEncoderRevs(&mut self) {
        self.arg = ::std::option::Option::None;
    }

    pub fn has_resetEncoderRevs(&self) -> bool {
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::resetEncoderRevs(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_resetEncoderRevs(&mut self, v: resetEncoderRevs_In) {
        self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::resetEncoderRevs(v))
    }

    // Mutable pointer to the field.
    pub fn mut_resetEncoderRevs(&mut self) -> &mut resetEncoderRevs_In {
        if let ::std::option::Option::Some(RpcRequest_oneof_arg::resetEncoderRevs(_)) = self.arg {
        } else {
            self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::resetEncoderRevs(resetEncoderRevs_In::new()));
        }
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::resetEncoderRevs(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_resetEncoderRevs(&mut self) -> resetEncoderRevs_In {
        if self.has_resetEncoderRevs() {
            match self.arg.take() {
                ::std::option::Option::Some(RpcRequest_oneof_arg::resetEncoderRevs(v)) => v,
                _ => panic!(),
            }
        } else {
            resetEncoderRevs_In::new()
        }
    }

    pub fn get_resetEncoderRevs(&self) -> &resetEncoderRevs_In {
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::resetEncoderRevs(ref v)) => v,
            _ => resetEncoderRevs_In::default_instance(),
        }
    }

    // optional .linkbot.robot.robotMove.In robotMove = 45;

    pub fn clear_robotMove(&mut self) {
        self.arg = ::std::option::Option::None;
    }

    pub fn has_robotMove(&self) -> bool {
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::robotMove(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_robotMove(&mut self, v: robotMove_In) {
        self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::robotMove(v))
    }

    // Mutable pointer to the field.
    pub fn mut_robotMove(&mut self) -> &mut robotMove_In {
        if let ::std::option::Option::Some(RpcRequest_oneof_arg::robotMove(_)) = self.arg {
        } else {
            self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::robotMove(robotMove_In::new()));
        }
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::robotMove(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_robotMove(&mut self) -> robotMove_In {
        if self.has_robotMove() {
            match self.arg.take() {
                ::std::option::Option::Some(RpcRequest_oneof_arg::robotMove(v)) => v,
                _ => panic!(),
            }
        } else {
            robotMove_In::new()
        }
    }

    pub fn get_robotMove(&self) -> &robotMove_In {
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::robotMove(ref v)) => v,
            _ => robotMove_In::default_instance(),
        }
    }

    // optional .linkbot.robot.stop.In stop = 46;

    pub fn clear_stop(&mut self) {
        self.arg = ::std::option::Option::None;
    }

    pub fn has_stop(&self) -> bool {
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::stop(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_stop(&mut self, v: stop_In) {
        self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::stop(v))
    }

    // Mutable pointer to the field.
    pub fn mut_stop(&mut self) -> &mut stop_In {
        if let ::std::option::Option::Some(RpcRequest_oneof_arg::stop(_)) = self.arg {
        } else {
            self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::stop(stop_In::new()));
        }
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::stop(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_stop(&mut self) -> stop_In {
        if self.has_stop() {
            match self.arg.take() {
                ::std::option::Option::Some(RpcRequest_oneof_arg::stop(v)) => v,
                _ => panic!(),
            }
        } else {
            stop_In::new()
        }
    }

    pub fn get_stop(&self) -> &stop_In {
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::stop(ref v)) => v,
            _ => stop_In::default_instance(),
        }
    }

    // optional .linkbot.robot.reboot.In reboot = 47;

    pub fn clear_reboot(&mut self) {
        self.arg = ::std::option::Option::None;
    }

    pub fn has_reboot(&self) -> bool {
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::reboot(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_reboot(&mut self, v: reboot_In) {
        self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::reboot(v))
    }

    // Mutable pointer to the field.
    pub fn mut_reboot(&mut self) -> &mut reboot_In {
        if let ::std::option::Option::Some(RpcRequest_oneof_arg::reboot(_)) = self.arg {
        } else {
            self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::reboot(reboot_In::new()));
        }
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::reboot(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_reboot(&mut self) -> reboot_In {
        if self.has_reboot() {
            match self.arg.take() {
                ::std::option::Option::Some(RpcRequest_oneof_arg::reboot(v)) => v,
                _ => panic!(),
            }
        } else {
            reboot_In::new()
        }
    }

    pub fn get_reboot(&self) -> &reboot_In {
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::reboot(ref v)) => v,
            _ => reboot_In::default_instance(),
        }
    }

    // optional .linkbot.robot.writeEeprom.In writeEeprom = 48;

    pub fn clear_writeEeprom(&mut self) {
        self.arg = ::std::option::Option::None;
    }

    pub fn has_writeEeprom(&self) -> bool {
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::writeEeprom(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_writeEeprom(&mut self, v: writeEeprom_In) {
        self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::writeEeprom(v))
    }

    // Mutable pointer to the field.
    pub fn mut_writeEeprom(&mut self) -> &mut writeEeprom_In {
        if let ::std::option::Option::Some(RpcRequest_oneof_arg::writeEeprom(_)) = self.arg {
        } else {
            self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::writeEeprom(writeEeprom_In::new()));
        }
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::writeEeprom(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_writeEeprom(&mut self) -> writeEeprom_In {
        if self.has_writeEeprom() {
            match self.arg.take() {
                ::std::option::Option::Some(RpcRequest_oneof_arg::writeEeprom(v)) => v,
                _ => panic!(),
            }
        } else {
            writeEeprom_In::new()
        }
    }

    pub fn get_writeEeprom(&self) -> &writeEeprom_In {
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::writeEeprom(ref v)) => v,
            _ => writeEeprom_In::default_instance(),
        }
    }

    // optional .linkbot.robot.readEeprom.In readEeprom = 49;

    pub fn clear_readEeprom(&mut self) {
        self.arg = ::std::option::Option::None;
    }

    pub fn has_readEeprom(&self) -> bool {
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::readEeprom(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_readEeprom(&mut self, v: readEeprom_In) {
        self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::readEeprom(v))
    }

    // Mutable pointer to the field.
    pub fn mut_readEeprom(&mut self) -> &mut readEeprom_In {
        if let ::std::option::Option::Some(RpcRequest_oneof_arg::readEeprom(_)) = self.arg {
        } else {
            self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::readEeprom(readEeprom_In::new()));
        }
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::readEeprom(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_readEeprom(&mut self) -> readEeprom_In {
        if self.has_readEeprom() {
            match self.arg.take() {
                ::std::option::Option::Some(RpcRequest_oneof_arg::readEeprom(v)) => v,
                _ => panic!(),
            }
        } else {
            readEeprom_In::new()
        }
    }

    pub fn get_readEeprom(&self) -> &readEeprom_In {
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::readEeprom(ref v)) => v,
            _ => readEeprom_In::default_instance(),
        }
    }

    // optional .linkbot.robot.writeTwi.In writeTwi = 50;

    pub fn clear_writeTwi(&mut self) {
        self.arg = ::std::option::Option::None;
    }

    pub fn has_writeTwi(&self) -> bool {
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::writeTwi(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_writeTwi(&mut self, v: writeTwi_In) {
        self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::writeTwi(v))
    }

    // Mutable pointer to the field.
    pub fn mut_writeTwi(&mut self) -> &mut writeTwi_In {
        if let ::std::option::Option::Some(RpcRequest_oneof_arg::writeTwi(_)) = self.arg {
        } else {
            self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::writeTwi(writeTwi_In::new()));
        }
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::writeTwi(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_writeTwi(&mut self) -> writeTwi_In {
        if self.has_writeTwi() {
            match self.arg.take() {
                ::std::option::Option::Some(RpcRequest_oneof_arg::writeTwi(v)) => v,
                _ => panic!(),
            }
        } else {
            writeTwi_In::new()
        }
    }

    pub fn get_writeTwi(&self) -> &writeTwi_In {
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::writeTwi(ref v)) => v,
            _ => writeTwi_In::default_instance(),
        }
    }

    // optional .linkbot.robot.readTwi.In readTwi = 51;

    pub fn clear_readTwi(&mut self) {
        self.arg = ::std::option::Option::None;
    }

    pub fn has_readTwi(&self) -> bool {
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::readTwi(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_readTwi(&mut self, v: readTwi_In) {
        self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::readTwi(v))
    }

    // Mutable pointer to the field.
    pub fn mut_readTwi(&mut self) -> &mut readTwi_In {
        if let ::std::option::Option::Some(RpcRequest_oneof_arg::readTwi(_)) = self.arg {
        } else {
            self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::readTwi(readTwi_In::new()));
        }
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::readTwi(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_readTwi(&mut self) -> readTwi_In {
        if self.has_readTwi() {
            match self.arg.take() {
                ::std::option::Option::Some(RpcRequest_oneof_arg::readTwi(v)) => v,
                _ => panic!(),
            }
        } else {
            readTwi_In::new()
        }
    }

    pub fn get_readTwi(&self) -> &readTwi_In {
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::readTwi(ref v)) => v,
            _ => readTwi_In::default_instance(),
        }
    }

    // optional .linkbot.robot.writeReadTwi.In writeReadTwi = 52;

    pub fn clear_writeReadTwi(&mut self) {
        self.arg = ::std::option::Option::None;
    }

    pub fn has_writeReadTwi(&self) -> bool {
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::writeReadTwi(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_writeReadTwi(&mut self, v: writeReadTwi_In) {
        self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::writeReadTwi(v))
    }

    // Mutable pointer to the field.
    pub fn mut_writeReadTwi(&mut self) -> &mut writeReadTwi_In {
        if let ::std::option::Option::Some(RpcRequest_oneof_arg::writeReadTwi(_)) = self.arg {
        } else {
            self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::writeReadTwi(writeReadTwi_In::new()));
        }
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::writeReadTwi(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_writeReadTwi(&mut self) -> writeReadTwi_In {
        if self.has_writeReadTwi() {
            match self.arg.take() {
                ::std::option::Option::Some(RpcRequest_oneof_arg::writeReadTwi(v)) => v,
                _ => panic!(),
            }
        } else {
            writeReadTwi_In::new()
        }
    }

    pub fn get_writeReadTwi(&self) -> &writeReadTwi_In {
        match self.arg {
            ::std::option::Option::Some(RpcRequest_oneof_arg::writeReadTwi(ref v)) => v,
            _ => writeReadTwi_In::default_instance(),
        }
    }
}

impl ::protobuf::Message for RpcRequest {
    fn is_initialized(&self) -> bool {
        if let Some(RpcRequest_oneof_arg::getFirmwareVersionString(ref v)) = self.arg {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RpcRequest_oneof_arg::getFormFactor(ref v)) = self.arg {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RpcRequest_oneof_arg::getAdcRaw(ref v)) = self.arg {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RpcRequest_oneof_arg::getBatteryVoltage(ref v)) = self.arg {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RpcRequest_oneof_arg::getAccelerometerData(ref v)) = self.arg {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RpcRequest_oneof_arg::getButtonState(ref v)) = self.arg {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RpcRequest_oneof_arg::getEncoderValues(ref v)) = self.arg {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RpcRequest_oneof_arg::getJointStates(ref v)) = self.arg {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RpcRequest_oneof_arg::enableAccelerometerEvent(ref v)) = self.arg {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RpcRequest_oneof_arg::enableButtonEvent(ref v)) = self.arg {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RpcRequest_oneof_arg::enableEncoderEvent(ref v)) = self.arg {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RpcRequest_oneof_arg::enableJointEvent(ref v)) = self.arg {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RpcRequest_oneof_arg::getBuzzerFrequency(ref v)) = self.arg {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RpcRequest_oneof_arg::getLedColor(ref v)) = self.arg {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RpcRequest_oneof_arg::getMotorControllerOmega(ref v)) = self.arg {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RpcRequest_oneof_arg::getMotorControllerAlphaI(ref v)) = self.arg {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RpcRequest_oneof_arg::getMotorControllerAlphaF(ref v)) = self.arg {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RpcRequest_oneof_arg::getMotorControllerProportionalGain(ref v)) = self.arg {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RpcRequest_oneof_arg::getMotorControllerIntegratorGain(ref v)) = self.arg {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RpcRequest_oneof_arg::getMotorControllerDerivativeGain(ref v)) = self.arg {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RpcRequest_oneof_arg::getMotorControllerSafetyThreshold(ref v)) = self.arg {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RpcRequest_oneof_arg::getMotorControllerSafetyAngle(ref v)) = self.arg {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RpcRequest_oneof_arg::setBuzzerFrequency(ref v)) = self.arg {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RpcRequest_oneof_arg::setLedColor(ref v)) = self.arg {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RpcRequest_oneof_arg::setMotorControllerOmega(ref v)) = self.arg {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RpcRequest_oneof_arg::setMotorControllerAlphaI(ref v)) = self.arg {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RpcRequest_oneof_arg::setMotorControllerAlphaF(ref v)) = self.arg {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RpcRequest_oneof_arg::setMotorControllerProportionalGain(ref v)) = self.arg {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RpcRequest_oneof_arg::setMotorControllerIntegratorGain(ref v)) = self.arg {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RpcRequest_oneof_arg::setMotorControllerDerivativeGain(ref v)) = self.arg {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RpcRequest_oneof_arg::setMotorControllerSafetyThreshold(ref v)) = self.arg {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RpcRequest_oneof_arg::setMotorControllerSafetyAngle(ref v)) = self.arg {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RpcRequest_oneof_arg::setResetOnDisconnect(ref v)) = self.arg {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RpcRequest_oneof_arg::resetEncoderRevs(ref v)) = self.arg {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RpcRequest_oneof_arg::robotMove(ref v)) = self.arg {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RpcRequest_oneof_arg::stop(ref v)) = self.arg {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RpcRequest_oneof_arg::reboot(ref v)) = self.arg {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RpcRequest_oneof_arg::writeEeprom(ref v)) = self.arg {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RpcRequest_oneof_arg::readEeprom(ref v)) = self.arg {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RpcRequest_oneof_arg::writeTwi(ref v)) = self.arg {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RpcRequest_oneof_arg::readTwi(ref v)) = self.arg {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RpcRequest_oneof_arg::writeReadTwi(ref v)) = self.arg {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.requestId = ::std::option::Option::Some(tmp);
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::getFirmwareVersionString(is.read_message()?));
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::getFormFactor(is.read_message()?));
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::getAdcRaw(is.read_message()?));
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::getBatteryVoltage(is.read_message()?));
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::getAccelerometerData(is.read_message()?));
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::getButtonState(is.read_message()?));
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::getEncoderValues(is.read_message()?));
                },
                23 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::getJointStates(is.read_message()?));
                },
                24 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::enableAccelerometerEvent(is.read_message()?));
                },
                25 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::enableButtonEvent(is.read_message()?));
                },
                26 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::enableEncoderEvent(is.read_message()?));
                },
                27 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::enableJointEvent(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::getBuzzerFrequency(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::getLedColor(is.read_message()?));
                },
                28 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::getMotorControllerOmega(is.read_message()?));
                },
                29 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::getMotorControllerAlphaI(is.read_message()?));
                },
                30 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::getMotorControllerAlphaF(is.read_message()?));
                },
                31 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::getMotorControllerProportionalGain(is.read_message()?));
                },
                32 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::getMotorControllerIntegratorGain(is.read_message()?));
                },
                33 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::getMotorControllerDerivativeGain(is.read_message()?));
                },
                34 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::getMotorControllerSafetyThreshold(is.read_message()?));
                },
                35 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::getMotorControllerSafetyAngle(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::setBuzzerFrequency(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::setLedColor(is.read_message()?));
                },
                36 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::setMotorControllerOmega(is.read_message()?));
                },
                37 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::setMotorControllerAlphaI(is.read_message()?));
                },
                38 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::setMotorControllerAlphaF(is.read_message()?));
                },
                39 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::setMotorControllerProportionalGain(is.read_message()?));
                },
                40 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::setMotorControllerIntegratorGain(is.read_message()?));
                },
                41 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::setMotorControllerDerivativeGain(is.read_message()?));
                },
                42 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::setMotorControllerSafetyThreshold(is.read_message()?));
                },
                43 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::setMotorControllerSafetyAngle(is.read_message()?));
                },
                53 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::setResetOnDisconnect(is.read_message()?));
                },
                44 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::resetEncoderRevs(is.read_message()?));
                },
                45 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::robotMove(is.read_message()?));
                },
                46 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::stop(is.read_message()?));
                },
                47 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::reboot(is.read_message()?));
                },
                48 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::writeEeprom(is.read_message()?));
                },
                49 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::readEeprom(is.read_message()?));
                },
                50 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::writeTwi(is.read_message()?));
                },
                51 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::readTwi(is.read_message()?));
                },
                52 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.arg = ::std::option::Option::Some(RpcRequest_oneof_arg::writeReadTwi(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.requestId {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let ::std::option::Option::Some(ref v) = self.arg {
            match v {
                &RpcRequest_oneof_arg::getFirmwareVersionString(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RpcRequest_oneof_arg::getFormFactor(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RpcRequest_oneof_arg::getAdcRaw(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RpcRequest_oneof_arg::getBatteryVoltage(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RpcRequest_oneof_arg::getAccelerometerData(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RpcRequest_oneof_arg::getButtonState(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RpcRequest_oneof_arg::getEncoderValues(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RpcRequest_oneof_arg::getJointStates(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RpcRequest_oneof_arg::enableAccelerometerEvent(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RpcRequest_oneof_arg::enableButtonEvent(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RpcRequest_oneof_arg::enableEncoderEvent(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RpcRequest_oneof_arg::enableJointEvent(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RpcRequest_oneof_arg::getBuzzerFrequency(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RpcRequest_oneof_arg::getLedColor(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RpcRequest_oneof_arg::getMotorControllerOmega(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RpcRequest_oneof_arg::getMotorControllerAlphaI(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RpcRequest_oneof_arg::getMotorControllerAlphaF(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RpcRequest_oneof_arg::getMotorControllerProportionalGain(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RpcRequest_oneof_arg::getMotorControllerIntegratorGain(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RpcRequest_oneof_arg::getMotorControllerDerivativeGain(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RpcRequest_oneof_arg::getMotorControllerSafetyThreshold(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RpcRequest_oneof_arg::getMotorControllerSafetyAngle(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RpcRequest_oneof_arg::setBuzzerFrequency(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RpcRequest_oneof_arg::setLedColor(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RpcRequest_oneof_arg::setMotorControllerOmega(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RpcRequest_oneof_arg::setMotorControllerAlphaI(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RpcRequest_oneof_arg::setMotorControllerAlphaF(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RpcRequest_oneof_arg::setMotorControllerProportionalGain(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RpcRequest_oneof_arg::setMotorControllerIntegratorGain(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RpcRequest_oneof_arg::setMotorControllerDerivativeGain(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RpcRequest_oneof_arg::setMotorControllerSafetyThreshold(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RpcRequest_oneof_arg::setMotorControllerSafetyAngle(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RpcRequest_oneof_arg::setResetOnDisconnect(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RpcRequest_oneof_arg::resetEncoderRevs(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RpcRequest_oneof_arg::robotMove(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RpcRequest_oneof_arg::stop(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RpcRequest_oneof_arg::reboot(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RpcRequest_oneof_arg::writeEeprom(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RpcRequest_oneof_arg::readEeprom(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RpcRequest_oneof_arg::writeTwi(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RpcRequest_oneof_arg::readTwi(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RpcRequest_oneof_arg::writeReadTwi(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.requestId {
            os.write_uint32(1, v)?;
        }
        if let ::std::option::Option::Some(ref v) = self.arg {
            match v {
                &RpcRequest_oneof_arg::getFirmwareVersionString(ref v) => {
                    os.write_tag(16, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RpcRequest_oneof_arg::getFormFactor(ref v) => {
                    os.write_tag(17, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RpcRequest_oneof_arg::getAdcRaw(ref v) => {
                    os.write_tag(18, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RpcRequest_oneof_arg::getBatteryVoltage(ref v) => {
                    os.write_tag(19, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RpcRequest_oneof_arg::getAccelerometerData(ref v) => {
                    os.write_tag(20, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RpcRequest_oneof_arg::getButtonState(ref v) => {
                    os.write_tag(21, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RpcRequest_oneof_arg::getEncoderValues(ref v) => {
                    os.write_tag(22, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RpcRequest_oneof_arg::getJointStates(ref v) => {
                    os.write_tag(23, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RpcRequest_oneof_arg::enableAccelerometerEvent(ref v) => {
                    os.write_tag(24, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RpcRequest_oneof_arg::enableButtonEvent(ref v) => {
                    os.write_tag(25, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RpcRequest_oneof_arg::enableEncoderEvent(ref v) => {
                    os.write_tag(26, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RpcRequest_oneof_arg::enableJointEvent(ref v) => {
                    os.write_tag(27, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RpcRequest_oneof_arg::getBuzzerFrequency(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RpcRequest_oneof_arg::getLedColor(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RpcRequest_oneof_arg::getMotorControllerOmega(ref v) => {
                    os.write_tag(28, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RpcRequest_oneof_arg::getMotorControllerAlphaI(ref v) => {
                    os.write_tag(29, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RpcRequest_oneof_arg::getMotorControllerAlphaF(ref v) => {
                    os.write_tag(30, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RpcRequest_oneof_arg::getMotorControllerProportionalGain(ref v) => {
                    os.write_tag(31, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RpcRequest_oneof_arg::getMotorControllerIntegratorGain(ref v) => {
                    os.write_tag(32, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RpcRequest_oneof_arg::getMotorControllerDerivativeGain(ref v) => {
                    os.write_tag(33, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RpcRequest_oneof_arg::getMotorControllerSafetyThreshold(ref v) => {
                    os.write_tag(34, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RpcRequest_oneof_arg::getMotorControllerSafetyAngle(ref v) => {
                    os.write_tag(35, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RpcRequest_oneof_arg::setBuzzerFrequency(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RpcRequest_oneof_arg::setLedColor(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RpcRequest_oneof_arg::setMotorControllerOmega(ref v) => {
                    os.write_tag(36, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RpcRequest_oneof_arg::setMotorControllerAlphaI(ref v) => {
                    os.write_tag(37, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RpcRequest_oneof_arg::setMotorControllerAlphaF(ref v) => {
                    os.write_tag(38, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RpcRequest_oneof_arg::setMotorControllerProportionalGain(ref v) => {
                    os.write_tag(39, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RpcRequest_oneof_arg::setMotorControllerIntegratorGain(ref v) => {
                    os.write_tag(40, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RpcRequest_oneof_arg::setMotorControllerDerivativeGain(ref v) => {
                    os.write_tag(41, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RpcRequest_oneof_arg::setMotorControllerSafetyThreshold(ref v) => {
                    os.write_tag(42, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RpcRequest_oneof_arg::setMotorControllerSafetyAngle(ref v) => {
                    os.write_tag(43, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RpcRequest_oneof_arg::setResetOnDisconnect(ref v) => {
                    os.write_tag(53, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RpcRequest_oneof_arg::resetEncoderRevs(ref v) => {
                    os.write_tag(44, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RpcRequest_oneof_arg::robotMove(ref v) => {
                    os.write_tag(45, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RpcRequest_oneof_arg::stop(ref v) => {
                    os.write_tag(46, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RpcRequest_oneof_arg::reboot(ref v) => {
                    os.write_tag(47, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RpcRequest_oneof_arg::writeEeprom(ref v) => {
                    os.write_tag(48, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RpcRequest_oneof_arg::readEeprom(ref v) => {
                    os.write_tag(49, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RpcRequest_oneof_arg::writeTwi(ref v) => {
                    os.write_tag(50, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RpcRequest_oneof_arg::readTwi(ref v) => {
                    os.write_tag(51, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RpcRequest_oneof_arg::writeReadTwi(ref v) => {
                    os.write_tag(52, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for RpcRequest {
    fn new() -> RpcRequest {
        RpcRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<RpcRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "requestId",
                    RpcRequest::get_requestId_for_reflect,
                    RpcRequest::mut_requestId_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, getFirmwareVersionString_In>(
                    "getFirmwareVersionString",
                    RpcRequest::has_getFirmwareVersionString,
                    RpcRequest::get_getFirmwareVersionString,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, getFormFactor_In>(
                    "getFormFactor",
                    RpcRequest::has_getFormFactor,
                    RpcRequest::get_getFormFactor,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, getAdcRaw_In>(
                    "getAdcRaw",
                    RpcRequest::has_getAdcRaw,
                    RpcRequest::get_getAdcRaw,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, getBatteryVoltage_In>(
                    "getBatteryVoltage",
                    RpcRequest::has_getBatteryVoltage,
                    RpcRequest::get_getBatteryVoltage,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, getAccelerometerData_In>(
                    "getAccelerometerData",
                    RpcRequest::has_getAccelerometerData,
                    RpcRequest::get_getAccelerometerData,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, getButtonState_In>(
                    "getButtonState",
                    RpcRequest::has_getButtonState,
                    RpcRequest::get_getButtonState,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, getEncoderValues_In>(
                    "getEncoderValues",
                    RpcRequest::has_getEncoderValues,
                    RpcRequest::get_getEncoderValues,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, getJointStates_In>(
                    "getJointStates",
                    RpcRequest::has_getJointStates,
                    RpcRequest::get_getJointStates,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, enableAccelerometerEvent_In>(
                    "enableAccelerometerEvent",
                    RpcRequest::has_enableAccelerometerEvent,
                    RpcRequest::get_enableAccelerometerEvent,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, enableButtonEvent_In>(
                    "enableButtonEvent",
                    RpcRequest::has_enableButtonEvent,
                    RpcRequest::get_enableButtonEvent,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, enableEncoderEvent_In>(
                    "enableEncoderEvent",
                    RpcRequest::has_enableEncoderEvent,
                    RpcRequest::get_enableEncoderEvent,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, enableJointEvent_In>(
                    "enableJointEvent",
                    RpcRequest::has_enableJointEvent,
                    RpcRequest::get_enableJointEvent,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, getBuzzerFrequency_In>(
                    "getBuzzerFrequency",
                    RpcRequest::has_getBuzzerFrequency,
                    RpcRequest::get_getBuzzerFrequency,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, getLedColor_In>(
                    "getLedColor",
                    RpcRequest::has_getLedColor,
                    RpcRequest::get_getLedColor,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, getMotorControllerOmega_In>(
                    "getMotorControllerOmega",
                    RpcRequest::has_getMotorControllerOmega,
                    RpcRequest::get_getMotorControllerOmega,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, getMotorControllerAlphaI_In>(
                    "getMotorControllerAlphaI",
                    RpcRequest::has_getMotorControllerAlphaI,
                    RpcRequest::get_getMotorControllerAlphaI,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, getMotorControllerAlphaF_In>(
                    "getMotorControllerAlphaF",
                    RpcRequest::has_getMotorControllerAlphaF,
                    RpcRequest::get_getMotorControllerAlphaF,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, getMotorControllerProportionalGain_In>(
                    "getMotorControllerProportionalGain",
                    RpcRequest::has_getMotorControllerProportionalGain,
                    RpcRequest::get_getMotorControllerProportionalGain,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, getMotorControllerIntegratorGain_In>(
                    "getMotorControllerIntegratorGain",
                    RpcRequest::has_getMotorControllerIntegratorGain,
                    RpcRequest::get_getMotorControllerIntegratorGain,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, getMotorControllerDerivativeGain_In>(
                    "getMotorControllerDerivativeGain",
                    RpcRequest::has_getMotorControllerDerivativeGain,
                    RpcRequest::get_getMotorControllerDerivativeGain,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, getMotorControllerSafetyThreshold_In>(
                    "getMotorControllerSafetyThreshold",
                    RpcRequest::has_getMotorControllerSafetyThreshold,
                    RpcRequest::get_getMotorControllerSafetyThreshold,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, getMotorControllerSafetyAngle_In>(
                    "getMotorControllerSafetyAngle",
                    RpcRequest::has_getMotorControllerSafetyAngle,
                    RpcRequest::get_getMotorControllerSafetyAngle,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, setBuzzerFrequency_In>(
                    "setBuzzerFrequency",
                    RpcRequest::has_setBuzzerFrequency,
                    RpcRequest::get_setBuzzerFrequency,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, setLedColor_In>(
                    "setLedColor",
                    RpcRequest::has_setLedColor,
                    RpcRequest::get_setLedColor,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, setMotorControllerOmega_In>(
                    "setMotorControllerOmega",
                    RpcRequest::has_setMotorControllerOmega,
                    RpcRequest::get_setMotorControllerOmega,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, setMotorControllerAlphaI_In>(
                    "setMotorControllerAlphaI",
                    RpcRequest::has_setMotorControllerAlphaI,
                    RpcRequest::get_setMotorControllerAlphaI,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, setMotorControllerAlphaF_In>(
                    "setMotorControllerAlphaF",
                    RpcRequest::has_setMotorControllerAlphaF,
                    RpcRequest::get_setMotorControllerAlphaF,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, setMotorControllerProportionalGain_In>(
                    "setMotorControllerProportionalGain",
                    RpcRequest::has_setMotorControllerProportionalGain,
                    RpcRequest::get_setMotorControllerProportionalGain,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, setMotorControllerIntegratorGain_In>(
                    "setMotorControllerIntegratorGain",
                    RpcRequest::has_setMotorControllerIntegratorGain,
                    RpcRequest::get_setMotorControllerIntegratorGain,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, setMotorControllerDerivativeGain_In>(
                    "setMotorControllerDerivativeGain",
                    RpcRequest::has_setMotorControllerDerivativeGain,
                    RpcRequest::get_setMotorControllerDerivativeGain,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, setMotorControllerSafetyThreshold_In>(
                    "setMotorControllerSafetyThreshold",
                    RpcRequest::has_setMotorControllerSafetyThreshold,
                    RpcRequest::get_setMotorControllerSafetyThreshold,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, setMotorControllerSafetyAngle_In>(
                    "setMotorControllerSafetyAngle",
                    RpcRequest::has_setMotorControllerSafetyAngle,
                    RpcRequest::get_setMotorControllerSafetyAngle,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, setResetOnDisconnect_In>(
                    "setResetOnDisconnect",
                    RpcRequest::has_setResetOnDisconnect,
                    RpcRequest::get_setResetOnDisconnect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, resetEncoderRevs_In>(
                    "resetEncoderRevs",
                    RpcRequest::has_resetEncoderRevs,
                    RpcRequest::get_resetEncoderRevs,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, robotMove_In>(
                    "robotMove",
                    RpcRequest::has_robotMove,
                    RpcRequest::get_robotMove,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, stop_In>(
                    "stop",
                    RpcRequest::has_stop,
                    RpcRequest::get_stop,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, reboot_In>(
                    "reboot",
                    RpcRequest::has_reboot,
                    RpcRequest::get_reboot,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, writeEeprom_In>(
                    "writeEeprom",
                    RpcRequest::has_writeEeprom,
                    RpcRequest::get_writeEeprom,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, readEeprom_In>(
                    "readEeprom",
                    RpcRequest::has_readEeprom,
                    RpcRequest::get_readEeprom,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, writeTwi_In>(
                    "writeTwi",
                    RpcRequest::has_writeTwi,
                    RpcRequest::get_writeTwi,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, readTwi_In>(
                    "readTwi",
                    RpcRequest::has_readTwi,
                    RpcRequest::get_readTwi,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, writeReadTwi_In>(
                    "writeReadTwi",
                    RpcRequest::has_writeReadTwi,
                    RpcRequest::get_writeReadTwi,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RpcRequest>(
                    "RpcRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for RpcRequest {
    fn clear(&mut self) {
        self.clear_requestId();
        self.clear_getFirmwareVersionString();
        self.clear_getFormFactor();
        self.clear_getAdcRaw();
        self.clear_getBatteryVoltage();
        self.clear_getAccelerometerData();
        self.clear_getButtonState();
        self.clear_getEncoderValues();
        self.clear_getJointStates();
        self.clear_enableAccelerometerEvent();
        self.clear_enableButtonEvent();
        self.clear_enableEncoderEvent();
        self.clear_enableJointEvent();
        self.clear_getBuzzerFrequency();
        self.clear_getLedColor();
        self.clear_getMotorControllerOmega();
        self.clear_getMotorControllerAlphaI();
        self.clear_getMotorControllerAlphaF();
        self.clear_getMotorControllerProportionalGain();
        self.clear_getMotorControllerIntegratorGain();
        self.clear_getMotorControllerDerivativeGain();
        self.clear_getMotorControllerSafetyThreshold();
        self.clear_getMotorControllerSafetyAngle();
        self.clear_setBuzzerFrequency();
        self.clear_setLedColor();
        self.clear_setMotorControllerOmega();
        self.clear_setMotorControllerAlphaI();
        self.clear_setMotorControllerAlphaF();
        self.clear_setMotorControllerProportionalGain();
        self.clear_setMotorControllerIntegratorGain();
        self.clear_setMotorControllerDerivativeGain();
        self.clear_setMotorControllerSafetyThreshold();
        self.clear_setMotorControllerSafetyAngle();
        self.clear_setResetOnDisconnect();
        self.clear_resetEncoderRevs();
        self.clear_robotMove();
        self.clear_stop();
        self.clear_reboot();
        self.clear_writeEeprom();
        self.clear_readEeprom();
        self.clear_writeTwi();
        self.clear_readTwi();
        self.clear_writeReadTwi();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RpcRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RpcRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RpcReply {
    // message fields
    requestId: ::std::option::Option<u32>,
    // message oneof groups
    arg: ::std::option::Option<RpcReply_oneof_arg>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for RpcReply {}

#[derive(Clone,PartialEq)]
pub enum RpcReply_oneof_arg {
    getFirmwareVersionString(getFirmwareVersionString_Out),
    getFormFactor(getFormFactor_Out),
    getAdcRaw(getAdcRaw_Out),
    getBatteryVoltage(getBatteryVoltage_Out),
    getAccelerometerData(getAccelerometerData_Out),
    getButtonState(getButtonState_Out),
    getEncoderValues(getEncoderValues_Out),
    getJointStates(getJointStates_Out),
    enableAccelerometerEvent(enableAccelerometerEvent_Out),
    enableButtonEvent(enableButtonEvent_Out),
    enableEncoderEvent(enableEncoderEvent_Out),
    enableJointEvent(enableJointEvent_Out),
    getBuzzerFrequency(getBuzzerFrequency_Out),
    getLedColor(getLedColor_Out),
    getMotorControllerOmega(getMotorControllerOmega_Out),
    getMotorControllerAlphaI(getMotorControllerAlphaI_Out),
    getMotorControllerAlphaF(getMotorControllerAlphaF_Out),
    getMotorControllerProportionalGain(getMotorControllerProportionalGain_Out),
    getMotorControllerIntegratorGain(getMotorControllerIntegratorGain_Out),
    getMotorControllerDerivativeGain(getMotorControllerDerivativeGain_Out),
    getMotorControllerSafetyThreshold(getMotorControllerSafetyThreshold_Out),
    getMotorControllerSafetyAngle(getMotorControllerSafetyAngle_Out),
    setBuzzerFrequency(setBuzzerFrequency_Out),
    setLedColor(setLedColor_Out),
    setMotorControllerOmega(setMotorControllerOmega_Out),
    setMotorControllerAlphaI(setMotorControllerAlphaI_Out),
    setMotorControllerAlphaF(setMotorControllerAlphaF_Out),
    setMotorControllerProportionalGain(setMotorControllerProportionalGain_Out),
    setMotorControllerIntegratorGain(setMotorControllerIntegratorGain_Out),
    setMotorControllerDerivativeGain(setMotorControllerDerivativeGain_Out),
    setMotorControllerSafetyThreshold(setMotorControllerSafetyThreshold_Out),
    setMotorControllerSafetyAngle(setMotorControllerSafetyAngle_Out),
    setResetOnDisconnect(setResetOnDisconnect_Out),
    resetEncoderRevs(resetEncoderRevs_Out),
    robotMove(robotMove_Out),
    stop(stop_Out),
    reboot(reboot_Out),
    writeEeprom(writeEeprom_Out),
    readEeprom(readEeprom_Out),
    writeTwi(writeTwi_Out),
    readTwi(readTwi_Out),
    writeReadTwi(writeReadTwi_Out),
}

impl RpcReply {
    pub fn new() -> RpcReply {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static RpcReply {
        static mut instance: ::protobuf::lazy::Lazy<RpcReply> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RpcReply,
        };
        unsafe {
            instance.get(RpcReply::new)
        }
    }

    // optional uint32 requestId = 1;

    pub fn clear_requestId(&mut self) {
        self.requestId = ::std::option::Option::None;
    }

    pub fn has_requestId(&self) -> bool {
        self.requestId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_requestId(&mut self, v: u32) {
        self.requestId = ::std::option::Option::Some(v);
    }

    pub fn get_requestId(&self) -> u32 {
        self.requestId.unwrap_or(0)
    }

    fn get_requestId_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.requestId
    }

    fn mut_requestId_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.requestId
    }

    // optional .linkbot.robot.getFirmwareVersionString.Out getFirmwareVersionString = 16;

    pub fn clear_getFirmwareVersionString(&mut self) {
        self.arg = ::std::option::Option::None;
    }

    pub fn has_getFirmwareVersionString(&self) -> bool {
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::getFirmwareVersionString(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_getFirmwareVersionString(&mut self, v: getFirmwareVersionString_Out) {
        self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::getFirmwareVersionString(v))
    }

    // Mutable pointer to the field.
    pub fn mut_getFirmwareVersionString(&mut self) -> &mut getFirmwareVersionString_Out {
        if let ::std::option::Option::Some(RpcReply_oneof_arg::getFirmwareVersionString(_)) = self.arg {
        } else {
            self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::getFirmwareVersionString(getFirmwareVersionString_Out::new()));
        }
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::getFirmwareVersionString(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_getFirmwareVersionString(&mut self) -> getFirmwareVersionString_Out {
        if self.has_getFirmwareVersionString() {
            match self.arg.take() {
                ::std::option::Option::Some(RpcReply_oneof_arg::getFirmwareVersionString(v)) => v,
                _ => panic!(),
            }
        } else {
            getFirmwareVersionString_Out::new()
        }
    }

    pub fn get_getFirmwareVersionString(&self) -> &getFirmwareVersionString_Out {
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::getFirmwareVersionString(ref v)) => v,
            _ => getFirmwareVersionString_Out::default_instance(),
        }
    }

    // optional .linkbot.robot.getFormFactor.Out getFormFactor = 17;

    pub fn clear_getFormFactor(&mut self) {
        self.arg = ::std::option::Option::None;
    }

    pub fn has_getFormFactor(&self) -> bool {
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::getFormFactor(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_getFormFactor(&mut self, v: getFormFactor_Out) {
        self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::getFormFactor(v))
    }

    // Mutable pointer to the field.
    pub fn mut_getFormFactor(&mut self) -> &mut getFormFactor_Out {
        if let ::std::option::Option::Some(RpcReply_oneof_arg::getFormFactor(_)) = self.arg {
        } else {
            self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::getFormFactor(getFormFactor_Out::new()));
        }
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::getFormFactor(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_getFormFactor(&mut self) -> getFormFactor_Out {
        if self.has_getFormFactor() {
            match self.arg.take() {
                ::std::option::Option::Some(RpcReply_oneof_arg::getFormFactor(v)) => v,
                _ => panic!(),
            }
        } else {
            getFormFactor_Out::new()
        }
    }

    pub fn get_getFormFactor(&self) -> &getFormFactor_Out {
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::getFormFactor(ref v)) => v,
            _ => getFormFactor_Out::default_instance(),
        }
    }

    // optional .linkbot.robot.getAdcRaw.Out getAdcRaw = 18;

    pub fn clear_getAdcRaw(&mut self) {
        self.arg = ::std::option::Option::None;
    }

    pub fn has_getAdcRaw(&self) -> bool {
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::getAdcRaw(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_getAdcRaw(&mut self, v: getAdcRaw_Out) {
        self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::getAdcRaw(v))
    }

    // Mutable pointer to the field.
    pub fn mut_getAdcRaw(&mut self) -> &mut getAdcRaw_Out {
        if let ::std::option::Option::Some(RpcReply_oneof_arg::getAdcRaw(_)) = self.arg {
        } else {
            self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::getAdcRaw(getAdcRaw_Out::new()));
        }
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::getAdcRaw(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_getAdcRaw(&mut self) -> getAdcRaw_Out {
        if self.has_getAdcRaw() {
            match self.arg.take() {
                ::std::option::Option::Some(RpcReply_oneof_arg::getAdcRaw(v)) => v,
                _ => panic!(),
            }
        } else {
            getAdcRaw_Out::new()
        }
    }

    pub fn get_getAdcRaw(&self) -> &getAdcRaw_Out {
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::getAdcRaw(ref v)) => v,
            _ => getAdcRaw_Out::default_instance(),
        }
    }

    // optional .linkbot.robot.getBatteryVoltage.Out getBatteryVoltage = 19;

    pub fn clear_getBatteryVoltage(&mut self) {
        self.arg = ::std::option::Option::None;
    }

    pub fn has_getBatteryVoltage(&self) -> bool {
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::getBatteryVoltage(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_getBatteryVoltage(&mut self, v: getBatteryVoltage_Out) {
        self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::getBatteryVoltage(v))
    }

    // Mutable pointer to the field.
    pub fn mut_getBatteryVoltage(&mut self) -> &mut getBatteryVoltage_Out {
        if let ::std::option::Option::Some(RpcReply_oneof_arg::getBatteryVoltage(_)) = self.arg {
        } else {
            self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::getBatteryVoltage(getBatteryVoltage_Out::new()));
        }
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::getBatteryVoltage(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_getBatteryVoltage(&mut self) -> getBatteryVoltage_Out {
        if self.has_getBatteryVoltage() {
            match self.arg.take() {
                ::std::option::Option::Some(RpcReply_oneof_arg::getBatteryVoltage(v)) => v,
                _ => panic!(),
            }
        } else {
            getBatteryVoltage_Out::new()
        }
    }

    pub fn get_getBatteryVoltage(&self) -> &getBatteryVoltage_Out {
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::getBatteryVoltage(ref v)) => v,
            _ => getBatteryVoltage_Out::default_instance(),
        }
    }

    // optional .linkbot.robot.getAccelerometerData.Out getAccelerometerData = 20;

    pub fn clear_getAccelerometerData(&mut self) {
        self.arg = ::std::option::Option::None;
    }

    pub fn has_getAccelerometerData(&self) -> bool {
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::getAccelerometerData(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_getAccelerometerData(&mut self, v: getAccelerometerData_Out) {
        self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::getAccelerometerData(v))
    }

    // Mutable pointer to the field.
    pub fn mut_getAccelerometerData(&mut self) -> &mut getAccelerometerData_Out {
        if let ::std::option::Option::Some(RpcReply_oneof_arg::getAccelerometerData(_)) = self.arg {
        } else {
            self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::getAccelerometerData(getAccelerometerData_Out::new()));
        }
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::getAccelerometerData(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_getAccelerometerData(&mut self) -> getAccelerometerData_Out {
        if self.has_getAccelerometerData() {
            match self.arg.take() {
                ::std::option::Option::Some(RpcReply_oneof_arg::getAccelerometerData(v)) => v,
                _ => panic!(),
            }
        } else {
            getAccelerometerData_Out::new()
        }
    }

    pub fn get_getAccelerometerData(&self) -> &getAccelerometerData_Out {
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::getAccelerometerData(ref v)) => v,
            _ => getAccelerometerData_Out::default_instance(),
        }
    }

    // optional .linkbot.robot.getButtonState.Out getButtonState = 21;

    pub fn clear_getButtonState(&mut self) {
        self.arg = ::std::option::Option::None;
    }

    pub fn has_getButtonState(&self) -> bool {
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::getButtonState(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_getButtonState(&mut self, v: getButtonState_Out) {
        self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::getButtonState(v))
    }

    // Mutable pointer to the field.
    pub fn mut_getButtonState(&mut self) -> &mut getButtonState_Out {
        if let ::std::option::Option::Some(RpcReply_oneof_arg::getButtonState(_)) = self.arg {
        } else {
            self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::getButtonState(getButtonState_Out::new()));
        }
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::getButtonState(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_getButtonState(&mut self) -> getButtonState_Out {
        if self.has_getButtonState() {
            match self.arg.take() {
                ::std::option::Option::Some(RpcReply_oneof_arg::getButtonState(v)) => v,
                _ => panic!(),
            }
        } else {
            getButtonState_Out::new()
        }
    }

    pub fn get_getButtonState(&self) -> &getButtonState_Out {
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::getButtonState(ref v)) => v,
            _ => getButtonState_Out::default_instance(),
        }
    }

    // optional .linkbot.robot.getEncoderValues.Out getEncoderValues = 22;

    pub fn clear_getEncoderValues(&mut self) {
        self.arg = ::std::option::Option::None;
    }

    pub fn has_getEncoderValues(&self) -> bool {
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::getEncoderValues(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_getEncoderValues(&mut self, v: getEncoderValues_Out) {
        self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::getEncoderValues(v))
    }

    // Mutable pointer to the field.
    pub fn mut_getEncoderValues(&mut self) -> &mut getEncoderValues_Out {
        if let ::std::option::Option::Some(RpcReply_oneof_arg::getEncoderValues(_)) = self.arg {
        } else {
            self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::getEncoderValues(getEncoderValues_Out::new()));
        }
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::getEncoderValues(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_getEncoderValues(&mut self) -> getEncoderValues_Out {
        if self.has_getEncoderValues() {
            match self.arg.take() {
                ::std::option::Option::Some(RpcReply_oneof_arg::getEncoderValues(v)) => v,
                _ => panic!(),
            }
        } else {
            getEncoderValues_Out::new()
        }
    }

    pub fn get_getEncoderValues(&self) -> &getEncoderValues_Out {
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::getEncoderValues(ref v)) => v,
            _ => getEncoderValues_Out::default_instance(),
        }
    }

    // optional .linkbot.robot.getJointStates.Out getJointStates = 23;

    pub fn clear_getJointStates(&mut self) {
        self.arg = ::std::option::Option::None;
    }

    pub fn has_getJointStates(&self) -> bool {
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::getJointStates(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_getJointStates(&mut self, v: getJointStates_Out) {
        self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::getJointStates(v))
    }

    // Mutable pointer to the field.
    pub fn mut_getJointStates(&mut self) -> &mut getJointStates_Out {
        if let ::std::option::Option::Some(RpcReply_oneof_arg::getJointStates(_)) = self.arg {
        } else {
            self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::getJointStates(getJointStates_Out::new()));
        }
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::getJointStates(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_getJointStates(&mut self) -> getJointStates_Out {
        if self.has_getJointStates() {
            match self.arg.take() {
                ::std::option::Option::Some(RpcReply_oneof_arg::getJointStates(v)) => v,
                _ => panic!(),
            }
        } else {
            getJointStates_Out::new()
        }
    }

    pub fn get_getJointStates(&self) -> &getJointStates_Out {
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::getJointStates(ref v)) => v,
            _ => getJointStates_Out::default_instance(),
        }
    }

    // optional .linkbot.robot.enableAccelerometerEvent.Out enableAccelerometerEvent = 24;

    pub fn clear_enableAccelerometerEvent(&mut self) {
        self.arg = ::std::option::Option::None;
    }

    pub fn has_enableAccelerometerEvent(&self) -> bool {
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::enableAccelerometerEvent(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_enableAccelerometerEvent(&mut self, v: enableAccelerometerEvent_Out) {
        self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::enableAccelerometerEvent(v))
    }

    // Mutable pointer to the field.
    pub fn mut_enableAccelerometerEvent(&mut self) -> &mut enableAccelerometerEvent_Out {
        if let ::std::option::Option::Some(RpcReply_oneof_arg::enableAccelerometerEvent(_)) = self.arg {
        } else {
            self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::enableAccelerometerEvent(enableAccelerometerEvent_Out::new()));
        }
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::enableAccelerometerEvent(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_enableAccelerometerEvent(&mut self) -> enableAccelerometerEvent_Out {
        if self.has_enableAccelerometerEvent() {
            match self.arg.take() {
                ::std::option::Option::Some(RpcReply_oneof_arg::enableAccelerometerEvent(v)) => v,
                _ => panic!(),
            }
        } else {
            enableAccelerometerEvent_Out::new()
        }
    }

    pub fn get_enableAccelerometerEvent(&self) -> &enableAccelerometerEvent_Out {
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::enableAccelerometerEvent(ref v)) => v,
            _ => enableAccelerometerEvent_Out::default_instance(),
        }
    }

    // optional .linkbot.robot.enableButtonEvent.Out enableButtonEvent = 25;

    pub fn clear_enableButtonEvent(&mut self) {
        self.arg = ::std::option::Option::None;
    }

    pub fn has_enableButtonEvent(&self) -> bool {
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::enableButtonEvent(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_enableButtonEvent(&mut self, v: enableButtonEvent_Out) {
        self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::enableButtonEvent(v))
    }

    // Mutable pointer to the field.
    pub fn mut_enableButtonEvent(&mut self) -> &mut enableButtonEvent_Out {
        if let ::std::option::Option::Some(RpcReply_oneof_arg::enableButtonEvent(_)) = self.arg {
        } else {
            self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::enableButtonEvent(enableButtonEvent_Out::new()));
        }
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::enableButtonEvent(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_enableButtonEvent(&mut self) -> enableButtonEvent_Out {
        if self.has_enableButtonEvent() {
            match self.arg.take() {
                ::std::option::Option::Some(RpcReply_oneof_arg::enableButtonEvent(v)) => v,
                _ => panic!(),
            }
        } else {
            enableButtonEvent_Out::new()
        }
    }

    pub fn get_enableButtonEvent(&self) -> &enableButtonEvent_Out {
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::enableButtonEvent(ref v)) => v,
            _ => enableButtonEvent_Out::default_instance(),
        }
    }

    // optional .linkbot.robot.enableEncoderEvent.Out enableEncoderEvent = 26;

    pub fn clear_enableEncoderEvent(&mut self) {
        self.arg = ::std::option::Option::None;
    }

    pub fn has_enableEncoderEvent(&self) -> bool {
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::enableEncoderEvent(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_enableEncoderEvent(&mut self, v: enableEncoderEvent_Out) {
        self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::enableEncoderEvent(v))
    }

    // Mutable pointer to the field.
    pub fn mut_enableEncoderEvent(&mut self) -> &mut enableEncoderEvent_Out {
        if let ::std::option::Option::Some(RpcReply_oneof_arg::enableEncoderEvent(_)) = self.arg {
        } else {
            self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::enableEncoderEvent(enableEncoderEvent_Out::new()));
        }
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::enableEncoderEvent(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_enableEncoderEvent(&mut self) -> enableEncoderEvent_Out {
        if self.has_enableEncoderEvent() {
            match self.arg.take() {
                ::std::option::Option::Some(RpcReply_oneof_arg::enableEncoderEvent(v)) => v,
                _ => panic!(),
            }
        } else {
            enableEncoderEvent_Out::new()
        }
    }

    pub fn get_enableEncoderEvent(&self) -> &enableEncoderEvent_Out {
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::enableEncoderEvent(ref v)) => v,
            _ => enableEncoderEvent_Out::default_instance(),
        }
    }

    // optional .linkbot.robot.enableJointEvent.Out enableJointEvent = 27;

    pub fn clear_enableJointEvent(&mut self) {
        self.arg = ::std::option::Option::None;
    }

    pub fn has_enableJointEvent(&self) -> bool {
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::enableJointEvent(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_enableJointEvent(&mut self, v: enableJointEvent_Out) {
        self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::enableJointEvent(v))
    }

    // Mutable pointer to the field.
    pub fn mut_enableJointEvent(&mut self) -> &mut enableJointEvent_Out {
        if let ::std::option::Option::Some(RpcReply_oneof_arg::enableJointEvent(_)) = self.arg {
        } else {
            self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::enableJointEvent(enableJointEvent_Out::new()));
        }
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::enableJointEvent(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_enableJointEvent(&mut self) -> enableJointEvent_Out {
        if self.has_enableJointEvent() {
            match self.arg.take() {
                ::std::option::Option::Some(RpcReply_oneof_arg::enableJointEvent(v)) => v,
                _ => panic!(),
            }
        } else {
            enableJointEvent_Out::new()
        }
    }

    pub fn get_enableJointEvent(&self) -> &enableJointEvent_Out {
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::enableJointEvent(ref v)) => v,
            _ => enableJointEvent_Out::default_instance(),
        }
    }

    // optional .linkbot.robot.getBuzzerFrequency.Out getBuzzerFrequency = 2;

    pub fn clear_getBuzzerFrequency(&mut self) {
        self.arg = ::std::option::Option::None;
    }

    pub fn has_getBuzzerFrequency(&self) -> bool {
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::getBuzzerFrequency(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_getBuzzerFrequency(&mut self, v: getBuzzerFrequency_Out) {
        self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::getBuzzerFrequency(v))
    }

    // Mutable pointer to the field.
    pub fn mut_getBuzzerFrequency(&mut self) -> &mut getBuzzerFrequency_Out {
        if let ::std::option::Option::Some(RpcReply_oneof_arg::getBuzzerFrequency(_)) = self.arg {
        } else {
            self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::getBuzzerFrequency(getBuzzerFrequency_Out::new()));
        }
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::getBuzzerFrequency(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_getBuzzerFrequency(&mut self) -> getBuzzerFrequency_Out {
        if self.has_getBuzzerFrequency() {
            match self.arg.take() {
                ::std::option::Option::Some(RpcReply_oneof_arg::getBuzzerFrequency(v)) => v,
                _ => panic!(),
            }
        } else {
            getBuzzerFrequency_Out::new()
        }
    }

    pub fn get_getBuzzerFrequency(&self) -> &getBuzzerFrequency_Out {
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::getBuzzerFrequency(ref v)) => v,
            _ => getBuzzerFrequency_Out::default_instance(),
        }
    }

    // optional .linkbot.robot.getLedColor.Out getLedColor = 3;

    pub fn clear_getLedColor(&mut self) {
        self.arg = ::std::option::Option::None;
    }

    pub fn has_getLedColor(&self) -> bool {
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::getLedColor(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_getLedColor(&mut self, v: getLedColor_Out) {
        self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::getLedColor(v))
    }

    // Mutable pointer to the field.
    pub fn mut_getLedColor(&mut self) -> &mut getLedColor_Out {
        if let ::std::option::Option::Some(RpcReply_oneof_arg::getLedColor(_)) = self.arg {
        } else {
            self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::getLedColor(getLedColor_Out::new()));
        }
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::getLedColor(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_getLedColor(&mut self) -> getLedColor_Out {
        if self.has_getLedColor() {
            match self.arg.take() {
                ::std::option::Option::Some(RpcReply_oneof_arg::getLedColor(v)) => v,
                _ => panic!(),
            }
        } else {
            getLedColor_Out::new()
        }
    }

    pub fn get_getLedColor(&self) -> &getLedColor_Out {
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::getLedColor(ref v)) => v,
            _ => getLedColor_Out::default_instance(),
        }
    }

    // optional .linkbot.robot.getMotorControllerOmega.Out getMotorControllerOmega = 28;

    pub fn clear_getMotorControllerOmega(&mut self) {
        self.arg = ::std::option::Option::None;
    }

    pub fn has_getMotorControllerOmega(&self) -> bool {
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::getMotorControllerOmega(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_getMotorControllerOmega(&mut self, v: getMotorControllerOmega_Out) {
        self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::getMotorControllerOmega(v))
    }

    // Mutable pointer to the field.
    pub fn mut_getMotorControllerOmega(&mut self) -> &mut getMotorControllerOmega_Out {
        if let ::std::option::Option::Some(RpcReply_oneof_arg::getMotorControllerOmega(_)) = self.arg {
        } else {
            self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::getMotorControllerOmega(getMotorControllerOmega_Out::new()));
        }
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::getMotorControllerOmega(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_getMotorControllerOmega(&mut self) -> getMotorControllerOmega_Out {
        if self.has_getMotorControllerOmega() {
            match self.arg.take() {
                ::std::option::Option::Some(RpcReply_oneof_arg::getMotorControllerOmega(v)) => v,
                _ => panic!(),
            }
        } else {
            getMotorControllerOmega_Out::new()
        }
    }

    pub fn get_getMotorControllerOmega(&self) -> &getMotorControllerOmega_Out {
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::getMotorControllerOmega(ref v)) => v,
            _ => getMotorControllerOmega_Out::default_instance(),
        }
    }

    // optional .linkbot.robot.getMotorControllerAlphaI.Out getMotorControllerAlphaI = 29;

    pub fn clear_getMotorControllerAlphaI(&mut self) {
        self.arg = ::std::option::Option::None;
    }

    pub fn has_getMotorControllerAlphaI(&self) -> bool {
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::getMotorControllerAlphaI(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_getMotorControllerAlphaI(&mut self, v: getMotorControllerAlphaI_Out) {
        self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::getMotorControllerAlphaI(v))
    }

    // Mutable pointer to the field.
    pub fn mut_getMotorControllerAlphaI(&mut self) -> &mut getMotorControllerAlphaI_Out {
        if let ::std::option::Option::Some(RpcReply_oneof_arg::getMotorControllerAlphaI(_)) = self.arg {
        } else {
            self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::getMotorControllerAlphaI(getMotorControllerAlphaI_Out::new()));
        }
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::getMotorControllerAlphaI(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_getMotorControllerAlphaI(&mut self) -> getMotorControllerAlphaI_Out {
        if self.has_getMotorControllerAlphaI() {
            match self.arg.take() {
                ::std::option::Option::Some(RpcReply_oneof_arg::getMotorControllerAlphaI(v)) => v,
                _ => panic!(),
            }
        } else {
            getMotorControllerAlphaI_Out::new()
        }
    }

    pub fn get_getMotorControllerAlphaI(&self) -> &getMotorControllerAlphaI_Out {
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::getMotorControllerAlphaI(ref v)) => v,
            _ => getMotorControllerAlphaI_Out::default_instance(),
        }
    }

    // optional .linkbot.robot.getMotorControllerAlphaF.Out getMotorControllerAlphaF = 30;

    pub fn clear_getMotorControllerAlphaF(&mut self) {
        self.arg = ::std::option::Option::None;
    }

    pub fn has_getMotorControllerAlphaF(&self) -> bool {
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::getMotorControllerAlphaF(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_getMotorControllerAlphaF(&mut self, v: getMotorControllerAlphaF_Out) {
        self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::getMotorControllerAlphaF(v))
    }

    // Mutable pointer to the field.
    pub fn mut_getMotorControllerAlphaF(&mut self) -> &mut getMotorControllerAlphaF_Out {
        if let ::std::option::Option::Some(RpcReply_oneof_arg::getMotorControllerAlphaF(_)) = self.arg {
        } else {
            self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::getMotorControllerAlphaF(getMotorControllerAlphaF_Out::new()));
        }
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::getMotorControllerAlphaF(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_getMotorControllerAlphaF(&mut self) -> getMotorControllerAlphaF_Out {
        if self.has_getMotorControllerAlphaF() {
            match self.arg.take() {
                ::std::option::Option::Some(RpcReply_oneof_arg::getMotorControllerAlphaF(v)) => v,
                _ => panic!(),
            }
        } else {
            getMotorControllerAlphaF_Out::new()
        }
    }

    pub fn get_getMotorControllerAlphaF(&self) -> &getMotorControllerAlphaF_Out {
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::getMotorControllerAlphaF(ref v)) => v,
            _ => getMotorControllerAlphaF_Out::default_instance(),
        }
    }

    // optional .linkbot.robot.getMotorControllerProportionalGain.Out getMotorControllerProportionalGain = 31;

    pub fn clear_getMotorControllerProportionalGain(&mut self) {
        self.arg = ::std::option::Option::None;
    }

    pub fn has_getMotorControllerProportionalGain(&self) -> bool {
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::getMotorControllerProportionalGain(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_getMotorControllerProportionalGain(&mut self, v: getMotorControllerProportionalGain_Out) {
        self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::getMotorControllerProportionalGain(v))
    }

    // Mutable pointer to the field.
    pub fn mut_getMotorControllerProportionalGain(&mut self) -> &mut getMotorControllerProportionalGain_Out {
        if let ::std::option::Option::Some(RpcReply_oneof_arg::getMotorControllerProportionalGain(_)) = self.arg {
        } else {
            self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::getMotorControllerProportionalGain(getMotorControllerProportionalGain_Out::new()));
        }
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::getMotorControllerProportionalGain(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_getMotorControllerProportionalGain(&mut self) -> getMotorControllerProportionalGain_Out {
        if self.has_getMotorControllerProportionalGain() {
            match self.arg.take() {
                ::std::option::Option::Some(RpcReply_oneof_arg::getMotorControllerProportionalGain(v)) => v,
                _ => panic!(),
            }
        } else {
            getMotorControllerProportionalGain_Out::new()
        }
    }

    pub fn get_getMotorControllerProportionalGain(&self) -> &getMotorControllerProportionalGain_Out {
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::getMotorControllerProportionalGain(ref v)) => v,
            _ => getMotorControllerProportionalGain_Out::default_instance(),
        }
    }

    // optional .linkbot.robot.getMotorControllerIntegratorGain.Out getMotorControllerIntegratorGain = 32;

    pub fn clear_getMotorControllerIntegratorGain(&mut self) {
        self.arg = ::std::option::Option::None;
    }

    pub fn has_getMotorControllerIntegratorGain(&self) -> bool {
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::getMotorControllerIntegratorGain(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_getMotorControllerIntegratorGain(&mut self, v: getMotorControllerIntegratorGain_Out) {
        self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::getMotorControllerIntegratorGain(v))
    }

    // Mutable pointer to the field.
    pub fn mut_getMotorControllerIntegratorGain(&mut self) -> &mut getMotorControllerIntegratorGain_Out {
        if let ::std::option::Option::Some(RpcReply_oneof_arg::getMotorControllerIntegratorGain(_)) = self.arg {
        } else {
            self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::getMotorControllerIntegratorGain(getMotorControllerIntegratorGain_Out::new()));
        }
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::getMotorControllerIntegratorGain(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_getMotorControllerIntegratorGain(&mut self) -> getMotorControllerIntegratorGain_Out {
        if self.has_getMotorControllerIntegratorGain() {
            match self.arg.take() {
                ::std::option::Option::Some(RpcReply_oneof_arg::getMotorControllerIntegratorGain(v)) => v,
                _ => panic!(),
            }
        } else {
            getMotorControllerIntegratorGain_Out::new()
        }
    }

    pub fn get_getMotorControllerIntegratorGain(&self) -> &getMotorControllerIntegratorGain_Out {
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::getMotorControllerIntegratorGain(ref v)) => v,
            _ => getMotorControllerIntegratorGain_Out::default_instance(),
        }
    }

    // optional .linkbot.robot.getMotorControllerDerivativeGain.Out getMotorControllerDerivativeGain = 33;

    pub fn clear_getMotorControllerDerivativeGain(&mut self) {
        self.arg = ::std::option::Option::None;
    }

    pub fn has_getMotorControllerDerivativeGain(&self) -> bool {
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::getMotorControllerDerivativeGain(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_getMotorControllerDerivativeGain(&mut self, v: getMotorControllerDerivativeGain_Out) {
        self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::getMotorControllerDerivativeGain(v))
    }

    // Mutable pointer to the field.
    pub fn mut_getMotorControllerDerivativeGain(&mut self) -> &mut getMotorControllerDerivativeGain_Out {
        if let ::std::option::Option::Some(RpcReply_oneof_arg::getMotorControllerDerivativeGain(_)) = self.arg {
        } else {
            self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::getMotorControllerDerivativeGain(getMotorControllerDerivativeGain_Out::new()));
        }
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::getMotorControllerDerivativeGain(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_getMotorControllerDerivativeGain(&mut self) -> getMotorControllerDerivativeGain_Out {
        if self.has_getMotorControllerDerivativeGain() {
            match self.arg.take() {
                ::std::option::Option::Some(RpcReply_oneof_arg::getMotorControllerDerivativeGain(v)) => v,
                _ => panic!(),
            }
        } else {
            getMotorControllerDerivativeGain_Out::new()
        }
    }

    pub fn get_getMotorControllerDerivativeGain(&self) -> &getMotorControllerDerivativeGain_Out {
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::getMotorControllerDerivativeGain(ref v)) => v,
            _ => getMotorControllerDerivativeGain_Out::default_instance(),
        }
    }

    // optional .linkbot.robot.getMotorControllerSafetyThreshold.Out getMotorControllerSafetyThreshold = 34;

    pub fn clear_getMotorControllerSafetyThreshold(&mut self) {
        self.arg = ::std::option::Option::None;
    }

    pub fn has_getMotorControllerSafetyThreshold(&self) -> bool {
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::getMotorControllerSafetyThreshold(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_getMotorControllerSafetyThreshold(&mut self, v: getMotorControllerSafetyThreshold_Out) {
        self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::getMotorControllerSafetyThreshold(v))
    }

    // Mutable pointer to the field.
    pub fn mut_getMotorControllerSafetyThreshold(&mut self) -> &mut getMotorControllerSafetyThreshold_Out {
        if let ::std::option::Option::Some(RpcReply_oneof_arg::getMotorControllerSafetyThreshold(_)) = self.arg {
        } else {
            self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::getMotorControllerSafetyThreshold(getMotorControllerSafetyThreshold_Out::new()));
        }
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::getMotorControllerSafetyThreshold(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_getMotorControllerSafetyThreshold(&mut self) -> getMotorControllerSafetyThreshold_Out {
        if self.has_getMotorControllerSafetyThreshold() {
            match self.arg.take() {
                ::std::option::Option::Some(RpcReply_oneof_arg::getMotorControllerSafetyThreshold(v)) => v,
                _ => panic!(),
            }
        } else {
            getMotorControllerSafetyThreshold_Out::new()
        }
    }

    pub fn get_getMotorControllerSafetyThreshold(&self) -> &getMotorControllerSafetyThreshold_Out {
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::getMotorControllerSafetyThreshold(ref v)) => v,
            _ => getMotorControllerSafetyThreshold_Out::default_instance(),
        }
    }

    // optional .linkbot.robot.getMotorControllerSafetyAngle.Out getMotorControllerSafetyAngle = 35;

    pub fn clear_getMotorControllerSafetyAngle(&mut self) {
        self.arg = ::std::option::Option::None;
    }

    pub fn has_getMotorControllerSafetyAngle(&self) -> bool {
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::getMotorControllerSafetyAngle(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_getMotorControllerSafetyAngle(&mut self, v: getMotorControllerSafetyAngle_Out) {
        self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::getMotorControllerSafetyAngle(v))
    }

    // Mutable pointer to the field.
    pub fn mut_getMotorControllerSafetyAngle(&mut self) -> &mut getMotorControllerSafetyAngle_Out {
        if let ::std::option::Option::Some(RpcReply_oneof_arg::getMotorControllerSafetyAngle(_)) = self.arg {
        } else {
            self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::getMotorControllerSafetyAngle(getMotorControllerSafetyAngle_Out::new()));
        }
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::getMotorControllerSafetyAngle(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_getMotorControllerSafetyAngle(&mut self) -> getMotorControllerSafetyAngle_Out {
        if self.has_getMotorControllerSafetyAngle() {
            match self.arg.take() {
                ::std::option::Option::Some(RpcReply_oneof_arg::getMotorControllerSafetyAngle(v)) => v,
                _ => panic!(),
            }
        } else {
            getMotorControllerSafetyAngle_Out::new()
        }
    }

    pub fn get_getMotorControllerSafetyAngle(&self) -> &getMotorControllerSafetyAngle_Out {
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::getMotorControllerSafetyAngle(ref v)) => v,
            _ => getMotorControllerSafetyAngle_Out::default_instance(),
        }
    }

    // optional .linkbot.robot.setBuzzerFrequency.Out setBuzzerFrequency = 4;

    pub fn clear_setBuzzerFrequency(&mut self) {
        self.arg = ::std::option::Option::None;
    }

    pub fn has_setBuzzerFrequency(&self) -> bool {
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::setBuzzerFrequency(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_setBuzzerFrequency(&mut self, v: setBuzzerFrequency_Out) {
        self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::setBuzzerFrequency(v))
    }

    // Mutable pointer to the field.
    pub fn mut_setBuzzerFrequency(&mut self) -> &mut setBuzzerFrequency_Out {
        if let ::std::option::Option::Some(RpcReply_oneof_arg::setBuzzerFrequency(_)) = self.arg {
        } else {
            self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::setBuzzerFrequency(setBuzzerFrequency_Out::new()));
        }
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::setBuzzerFrequency(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_setBuzzerFrequency(&mut self) -> setBuzzerFrequency_Out {
        if self.has_setBuzzerFrequency() {
            match self.arg.take() {
                ::std::option::Option::Some(RpcReply_oneof_arg::setBuzzerFrequency(v)) => v,
                _ => panic!(),
            }
        } else {
            setBuzzerFrequency_Out::new()
        }
    }

    pub fn get_setBuzzerFrequency(&self) -> &setBuzzerFrequency_Out {
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::setBuzzerFrequency(ref v)) => v,
            _ => setBuzzerFrequency_Out::default_instance(),
        }
    }

    // optional .linkbot.robot.setLedColor.Out setLedColor = 5;

    pub fn clear_setLedColor(&mut self) {
        self.arg = ::std::option::Option::None;
    }

    pub fn has_setLedColor(&self) -> bool {
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::setLedColor(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_setLedColor(&mut self, v: setLedColor_Out) {
        self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::setLedColor(v))
    }

    // Mutable pointer to the field.
    pub fn mut_setLedColor(&mut self) -> &mut setLedColor_Out {
        if let ::std::option::Option::Some(RpcReply_oneof_arg::setLedColor(_)) = self.arg {
        } else {
            self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::setLedColor(setLedColor_Out::new()));
        }
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::setLedColor(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_setLedColor(&mut self) -> setLedColor_Out {
        if self.has_setLedColor() {
            match self.arg.take() {
                ::std::option::Option::Some(RpcReply_oneof_arg::setLedColor(v)) => v,
                _ => panic!(),
            }
        } else {
            setLedColor_Out::new()
        }
    }

    pub fn get_setLedColor(&self) -> &setLedColor_Out {
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::setLedColor(ref v)) => v,
            _ => setLedColor_Out::default_instance(),
        }
    }

    // optional .linkbot.robot.setMotorControllerOmega.Out setMotorControllerOmega = 36;

    pub fn clear_setMotorControllerOmega(&mut self) {
        self.arg = ::std::option::Option::None;
    }

    pub fn has_setMotorControllerOmega(&self) -> bool {
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::setMotorControllerOmega(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_setMotorControllerOmega(&mut self, v: setMotorControllerOmega_Out) {
        self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::setMotorControllerOmega(v))
    }

    // Mutable pointer to the field.
    pub fn mut_setMotorControllerOmega(&mut self) -> &mut setMotorControllerOmega_Out {
        if let ::std::option::Option::Some(RpcReply_oneof_arg::setMotorControllerOmega(_)) = self.arg {
        } else {
            self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::setMotorControllerOmega(setMotorControllerOmega_Out::new()));
        }
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::setMotorControllerOmega(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_setMotorControllerOmega(&mut self) -> setMotorControllerOmega_Out {
        if self.has_setMotorControllerOmega() {
            match self.arg.take() {
                ::std::option::Option::Some(RpcReply_oneof_arg::setMotorControllerOmega(v)) => v,
                _ => panic!(),
            }
        } else {
            setMotorControllerOmega_Out::new()
        }
    }

    pub fn get_setMotorControllerOmega(&self) -> &setMotorControllerOmega_Out {
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::setMotorControllerOmega(ref v)) => v,
            _ => setMotorControllerOmega_Out::default_instance(),
        }
    }

    // optional .linkbot.robot.setMotorControllerAlphaI.Out setMotorControllerAlphaI = 37;

    pub fn clear_setMotorControllerAlphaI(&mut self) {
        self.arg = ::std::option::Option::None;
    }

    pub fn has_setMotorControllerAlphaI(&self) -> bool {
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::setMotorControllerAlphaI(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_setMotorControllerAlphaI(&mut self, v: setMotorControllerAlphaI_Out) {
        self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::setMotorControllerAlphaI(v))
    }

    // Mutable pointer to the field.
    pub fn mut_setMotorControllerAlphaI(&mut self) -> &mut setMotorControllerAlphaI_Out {
        if let ::std::option::Option::Some(RpcReply_oneof_arg::setMotorControllerAlphaI(_)) = self.arg {
        } else {
            self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::setMotorControllerAlphaI(setMotorControllerAlphaI_Out::new()));
        }
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::setMotorControllerAlphaI(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_setMotorControllerAlphaI(&mut self) -> setMotorControllerAlphaI_Out {
        if self.has_setMotorControllerAlphaI() {
            match self.arg.take() {
                ::std::option::Option::Some(RpcReply_oneof_arg::setMotorControllerAlphaI(v)) => v,
                _ => panic!(),
            }
        } else {
            setMotorControllerAlphaI_Out::new()
        }
    }

    pub fn get_setMotorControllerAlphaI(&self) -> &setMotorControllerAlphaI_Out {
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::setMotorControllerAlphaI(ref v)) => v,
            _ => setMotorControllerAlphaI_Out::default_instance(),
        }
    }

    // optional .linkbot.robot.setMotorControllerAlphaF.Out setMotorControllerAlphaF = 38;

    pub fn clear_setMotorControllerAlphaF(&mut self) {
        self.arg = ::std::option::Option::None;
    }

    pub fn has_setMotorControllerAlphaF(&self) -> bool {
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::setMotorControllerAlphaF(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_setMotorControllerAlphaF(&mut self, v: setMotorControllerAlphaF_Out) {
        self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::setMotorControllerAlphaF(v))
    }

    // Mutable pointer to the field.
    pub fn mut_setMotorControllerAlphaF(&mut self) -> &mut setMotorControllerAlphaF_Out {
        if let ::std::option::Option::Some(RpcReply_oneof_arg::setMotorControllerAlphaF(_)) = self.arg {
        } else {
            self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::setMotorControllerAlphaF(setMotorControllerAlphaF_Out::new()));
        }
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::setMotorControllerAlphaF(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_setMotorControllerAlphaF(&mut self) -> setMotorControllerAlphaF_Out {
        if self.has_setMotorControllerAlphaF() {
            match self.arg.take() {
                ::std::option::Option::Some(RpcReply_oneof_arg::setMotorControllerAlphaF(v)) => v,
                _ => panic!(),
            }
        } else {
            setMotorControllerAlphaF_Out::new()
        }
    }

    pub fn get_setMotorControllerAlphaF(&self) -> &setMotorControllerAlphaF_Out {
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::setMotorControllerAlphaF(ref v)) => v,
            _ => setMotorControllerAlphaF_Out::default_instance(),
        }
    }

    // optional .linkbot.robot.setMotorControllerProportionalGain.Out setMotorControllerProportionalGain = 39;

    pub fn clear_setMotorControllerProportionalGain(&mut self) {
        self.arg = ::std::option::Option::None;
    }

    pub fn has_setMotorControllerProportionalGain(&self) -> bool {
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::setMotorControllerProportionalGain(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_setMotorControllerProportionalGain(&mut self, v: setMotorControllerProportionalGain_Out) {
        self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::setMotorControllerProportionalGain(v))
    }

    // Mutable pointer to the field.
    pub fn mut_setMotorControllerProportionalGain(&mut self) -> &mut setMotorControllerProportionalGain_Out {
        if let ::std::option::Option::Some(RpcReply_oneof_arg::setMotorControllerProportionalGain(_)) = self.arg {
        } else {
            self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::setMotorControllerProportionalGain(setMotorControllerProportionalGain_Out::new()));
        }
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::setMotorControllerProportionalGain(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_setMotorControllerProportionalGain(&mut self) -> setMotorControllerProportionalGain_Out {
        if self.has_setMotorControllerProportionalGain() {
            match self.arg.take() {
                ::std::option::Option::Some(RpcReply_oneof_arg::setMotorControllerProportionalGain(v)) => v,
                _ => panic!(),
            }
        } else {
            setMotorControllerProportionalGain_Out::new()
        }
    }

    pub fn get_setMotorControllerProportionalGain(&self) -> &setMotorControllerProportionalGain_Out {
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::setMotorControllerProportionalGain(ref v)) => v,
            _ => setMotorControllerProportionalGain_Out::default_instance(),
        }
    }

    // optional .linkbot.robot.setMotorControllerIntegratorGain.Out setMotorControllerIntegratorGain = 40;

    pub fn clear_setMotorControllerIntegratorGain(&mut self) {
        self.arg = ::std::option::Option::None;
    }

    pub fn has_setMotorControllerIntegratorGain(&self) -> bool {
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::setMotorControllerIntegratorGain(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_setMotorControllerIntegratorGain(&mut self, v: setMotorControllerIntegratorGain_Out) {
        self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::setMotorControllerIntegratorGain(v))
    }

    // Mutable pointer to the field.
    pub fn mut_setMotorControllerIntegratorGain(&mut self) -> &mut setMotorControllerIntegratorGain_Out {
        if let ::std::option::Option::Some(RpcReply_oneof_arg::setMotorControllerIntegratorGain(_)) = self.arg {
        } else {
            self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::setMotorControllerIntegratorGain(setMotorControllerIntegratorGain_Out::new()));
        }
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::setMotorControllerIntegratorGain(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_setMotorControllerIntegratorGain(&mut self) -> setMotorControllerIntegratorGain_Out {
        if self.has_setMotorControllerIntegratorGain() {
            match self.arg.take() {
                ::std::option::Option::Some(RpcReply_oneof_arg::setMotorControllerIntegratorGain(v)) => v,
                _ => panic!(),
            }
        } else {
            setMotorControllerIntegratorGain_Out::new()
        }
    }

    pub fn get_setMotorControllerIntegratorGain(&self) -> &setMotorControllerIntegratorGain_Out {
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::setMotorControllerIntegratorGain(ref v)) => v,
            _ => setMotorControllerIntegratorGain_Out::default_instance(),
        }
    }

    // optional .linkbot.robot.setMotorControllerDerivativeGain.Out setMotorControllerDerivativeGain = 41;

    pub fn clear_setMotorControllerDerivativeGain(&mut self) {
        self.arg = ::std::option::Option::None;
    }

    pub fn has_setMotorControllerDerivativeGain(&self) -> bool {
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::setMotorControllerDerivativeGain(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_setMotorControllerDerivativeGain(&mut self, v: setMotorControllerDerivativeGain_Out) {
        self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::setMotorControllerDerivativeGain(v))
    }

    // Mutable pointer to the field.
    pub fn mut_setMotorControllerDerivativeGain(&mut self) -> &mut setMotorControllerDerivativeGain_Out {
        if let ::std::option::Option::Some(RpcReply_oneof_arg::setMotorControllerDerivativeGain(_)) = self.arg {
        } else {
            self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::setMotorControllerDerivativeGain(setMotorControllerDerivativeGain_Out::new()));
        }
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::setMotorControllerDerivativeGain(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_setMotorControllerDerivativeGain(&mut self) -> setMotorControllerDerivativeGain_Out {
        if self.has_setMotorControllerDerivativeGain() {
            match self.arg.take() {
                ::std::option::Option::Some(RpcReply_oneof_arg::setMotorControllerDerivativeGain(v)) => v,
                _ => panic!(),
            }
        } else {
            setMotorControllerDerivativeGain_Out::new()
        }
    }

    pub fn get_setMotorControllerDerivativeGain(&self) -> &setMotorControllerDerivativeGain_Out {
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::setMotorControllerDerivativeGain(ref v)) => v,
            _ => setMotorControllerDerivativeGain_Out::default_instance(),
        }
    }

    // optional .linkbot.robot.setMotorControllerSafetyThreshold.Out setMotorControllerSafetyThreshold = 42;

    pub fn clear_setMotorControllerSafetyThreshold(&mut self) {
        self.arg = ::std::option::Option::None;
    }

    pub fn has_setMotorControllerSafetyThreshold(&self) -> bool {
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::setMotorControllerSafetyThreshold(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_setMotorControllerSafetyThreshold(&mut self, v: setMotorControllerSafetyThreshold_Out) {
        self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::setMotorControllerSafetyThreshold(v))
    }

    // Mutable pointer to the field.
    pub fn mut_setMotorControllerSafetyThreshold(&mut self) -> &mut setMotorControllerSafetyThreshold_Out {
        if let ::std::option::Option::Some(RpcReply_oneof_arg::setMotorControllerSafetyThreshold(_)) = self.arg {
        } else {
            self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::setMotorControllerSafetyThreshold(setMotorControllerSafetyThreshold_Out::new()));
        }
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::setMotorControllerSafetyThreshold(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_setMotorControllerSafetyThreshold(&mut self) -> setMotorControllerSafetyThreshold_Out {
        if self.has_setMotorControllerSafetyThreshold() {
            match self.arg.take() {
                ::std::option::Option::Some(RpcReply_oneof_arg::setMotorControllerSafetyThreshold(v)) => v,
                _ => panic!(),
            }
        } else {
            setMotorControllerSafetyThreshold_Out::new()
        }
    }

    pub fn get_setMotorControllerSafetyThreshold(&self) -> &setMotorControllerSafetyThreshold_Out {
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::setMotorControllerSafetyThreshold(ref v)) => v,
            _ => setMotorControllerSafetyThreshold_Out::default_instance(),
        }
    }

    // optional .linkbot.robot.setMotorControllerSafetyAngle.Out setMotorControllerSafetyAngle = 43;

    pub fn clear_setMotorControllerSafetyAngle(&mut self) {
        self.arg = ::std::option::Option::None;
    }

    pub fn has_setMotorControllerSafetyAngle(&self) -> bool {
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::setMotorControllerSafetyAngle(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_setMotorControllerSafetyAngle(&mut self, v: setMotorControllerSafetyAngle_Out) {
        self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::setMotorControllerSafetyAngle(v))
    }

    // Mutable pointer to the field.
    pub fn mut_setMotorControllerSafetyAngle(&mut self) -> &mut setMotorControllerSafetyAngle_Out {
        if let ::std::option::Option::Some(RpcReply_oneof_arg::setMotorControllerSafetyAngle(_)) = self.arg {
        } else {
            self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::setMotorControllerSafetyAngle(setMotorControllerSafetyAngle_Out::new()));
        }
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::setMotorControllerSafetyAngle(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_setMotorControllerSafetyAngle(&mut self) -> setMotorControllerSafetyAngle_Out {
        if self.has_setMotorControllerSafetyAngle() {
            match self.arg.take() {
                ::std::option::Option::Some(RpcReply_oneof_arg::setMotorControllerSafetyAngle(v)) => v,
                _ => panic!(),
            }
        } else {
            setMotorControllerSafetyAngle_Out::new()
        }
    }

    pub fn get_setMotorControllerSafetyAngle(&self) -> &setMotorControllerSafetyAngle_Out {
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::setMotorControllerSafetyAngle(ref v)) => v,
            _ => setMotorControllerSafetyAngle_Out::default_instance(),
        }
    }

    // optional .linkbot.robot.setResetOnDisconnect.Out setResetOnDisconnect = 53;

    pub fn clear_setResetOnDisconnect(&mut self) {
        self.arg = ::std::option::Option::None;
    }

    pub fn has_setResetOnDisconnect(&self) -> bool {
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::setResetOnDisconnect(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_setResetOnDisconnect(&mut self, v: setResetOnDisconnect_Out) {
        self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::setResetOnDisconnect(v))
    }

    // Mutable pointer to the field.
    pub fn mut_setResetOnDisconnect(&mut self) -> &mut setResetOnDisconnect_Out {
        if let ::std::option::Option::Some(RpcReply_oneof_arg::setResetOnDisconnect(_)) = self.arg {
        } else {
            self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::setResetOnDisconnect(setResetOnDisconnect_Out::new()));
        }
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::setResetOnDisconnect(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_setResetOnDisconnect(&mut self) -> setResetOnDisconnect_Out {
        if self.has_setResetOnDisconnect() {
            match self.arg.take() {
                ::std::option::Option::Some(RpcReply_oneof_arg::setResetOnDisconnect(v)) => v,
                _ => panic!(),
            }
        } else {
            setResetOnDisconnect_Out::new()
        }
    }

    pub fn get_setResetOnDisconnect(&self) -> &setResetOnDisconnect_Out {
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::setResetOnDisconnect(ref v)) => v,
            _ => setResetOnDisconnect_Out::default_instance(),
        }
    }

    // optional .linkbot.robot.resetEncoderRevs.Out resetEncoderRevs = 44;

    pub fn clear_resetEncoderRevs(&mut self) {
        self.arg = ::std::option::Option::None;
    }

    pub fn has_resetEncoderRevs(&self) -> bool {
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::resetEncoderRevs(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_resetEncoderRevs(&mut self, v: resetEncoderRevs_Out) {
        self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::resetEncoderRevs(v))
    }

    // Mutable pointer to the field.
    pub fn mut_resetEncoderRevs(&mut self) -> &mut resetEncoderRevs_Out {
        if let ::std::option::Option::Some(RpcReply_oneof_arg::resetEncoderRevs(_)) = self.arg {
        } else {
            self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::resetEncoderRevs(resetEncoderRevs_Out::new()));
        }
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::resetEncoderRevs(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_resetEncoderRevs(&mut self) -> resetEncoderRevs_Out {
        if self.has_resetEncoderRevs() {
            match self.arg.take() {
                ::std::option::Option::Some(RpcReply_oneof_arg::resetEncoderRevs(v)) => v,
                _ => panic!(),
            }
        } else {
            resetEncoderRevs_Out::new()
        }
    }

    pub fn get_resetEncoderRevs(&self) -> &resetEncoderRevs_Out {
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::resetEncoderRevs(ref v)) => v,
            _ => resetEncoderRevs_Out::default_instance(),
        }
    }

    // optional .linkbot.robot.robotMove.Out robotMove = 45;

    pub fn clear_robotMove(&mut self) {
        self.arg = ::std::option::Option::None;
    }

    pub fn has_robotMove(&self) -> bool {
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::robotMove(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_robotMove(&mut self, v: robotMove_Out) {
        self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::robotMove(v))
    }

    // Mutable pointer to the field.
    pub fn mut_robotMove(&mut self) -> &mut robotMove_Out {
        if let ::std::option::Option::Some(RpcReply_oneof_arg::robotMove(_)) = self.arg {
        } else {
            self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::robotMove(robotMove_Out::new()));
        }
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::robotMove(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_robotMove(&mut self) -> robotMove_Out {
        if self.has_robotMove() {
            match self.arg.take() {
                ::std::option::Option::Some(RpcReply_oneof_arg::robotMove(v)) => v,
                _ => panic!(),
            }
        } else {
            robotMove_Out::new()
        }
    }

    pub fn get_robotMove(&self) -> &robotMove_Out {
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::robotMove(ref v)) => v,
            _ => robotMove_Out::default_instance(),
        }
    }

    // optional .linkbot.robot.stop.Out stop = 46;

    pub fn clear_stop(&mut self) {
        self.arg = ::std::option::Option::None;
    }

    pub fn has_stop(&self) -> bool {
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::stop(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_stop(&mut self, v: stop_Out) {
        self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::stop(v))
    }

    // Mutable pointer to the field.
    pub fn mut_stop(&mut self) -> &mut stop_Out {
        if let ::std::option::Option::Some(RpcReply_oneof_arg::stop(_)) = self.arg {
        } else {
            self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::stop(stop_Out::new()));
        }
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::stop(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_stop(&mut self) -> stop_Out {
        if self.has_stop() {
            match self.arg.take() {
                ::std::option::Option::Some(RpcReply_oneof_arg::stop(v)) => v,
                _ => panic!(),
            }
        } else {
            stop_Out::new()
        }
    }

    pub fn get_stop(&self) -> &stop_Out {
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::stop(ref v)) => v,
            _ => stop_Out::default_instance(),
        }
    }

    // optional .linkbot.robot.reboot.Out reboot = 47;

    pub fn clear_reboot(&mut self) {
        self.arg = ::std::option::Option::None;
    }

    pub fn has_reboot(&self) -> bool {
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::reboot(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_reboot(&mut self, v: reboot_Out) {
        self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::reboot(v))
    }

    // Mutable pointer to the field.
    pub fn mut_reboot(&mut self) -> &mut reboot_Out {
        if let ::std::option::Option::Some(RpcReply_oneof_arg::reboot(_)) = self.arg {
        } else {
            self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::reboot(reboot_Out::new()));
        }
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::reboot(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_reboot(&mut self) -> reboot_Out {
        if self.has_reboot() {
            match self.arg.take() {
                ::std::option::Option::Some(RpcReply_oneof_arg::reboot(v)) => v,
                _ => panic!(),
            }
        } else {
            reboot_Out::new()
        }
    }

    pub fn get_reboot(&self) -> &reboot_Out {
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::reboot(ref v)) => v,
            _ => reboot_Out::default_instance(),
        }
    }

    // optional .linkbot.robot.writeEeprom.Out writeEeprom = 48;

    pub fn clear_writeEeprom(&mut self) {
        self.arg = ::std::option::Option::None;
    }

    pub fn has_writeEeprom(&self) -> bool {
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::writeEeprom(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_writeEeprom(&mut self, v: writeEeprom_Out) {
        self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::writeEeprom(v))
    }

    // Mutable pointer to the field.
    pub fn mut_writeEeprom(&mut self) -> &mut writeEeprom_Out {
        if let ::std::option::Option::Some(RpcReply_oneof_arg::writeEeprom(_)) = self.arg {
        } else {
            self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::writeEeprom(writeEeprom_Out::new()));
        }
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::writeEeprom(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_writeEeprom(&mut self) -> writeEeprom_Out {
        if self.has_writeEeprom() {
            match self.arg.take() {
                ::std::option::Option::Some(RpcReply_oneof_arg::writeEeprom(v)) => v,
                _ => panic!(),
            }
        } else {
            writeEeprom_Out::new()
        }
    }

    pub fn get_writeEeprom(&self) -> &writeEeprom_Out {
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::writeEeprom(ref v)) => v,
            _ => writeEeprom_Out::default_instance(),
        }
    }

    // optional .linkbot.robot.readEeprom.Out readEeprom = 49;

    pub fn clear_readEeprom(&mut self) {
        self.arg = ::std::option::Option::None;
    }

    pub fn has_readEeprom(&self) -> bool {
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::readEeprom(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_readEeprom(&mut self, v: readEeprom_Out) {
        self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::readEeprom(v))
    }

    // Mutable pointer to the field.
    pub fn mut_readEeprom(&mut self) -> &mut readEeprom_Out {
        if let ::std::option::Option::Some(RpcReply_oneof_arg::readEeprom(_)) = self.arg {
        } else {
            self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::readEeprom(readEeprom_Out::new()));
        }
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::readEeprom(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_readEeprom(&mut self) -> readEeprom_Out {
        if self.has_readEeprom() {
            match self.arg.take() {
                ::std::option::Option::Some(RpcReply_oneof_arg::readEeprom(v)) => v,
                _ => panic!(),
            }
        } else {
            readEeprom_Out::new()
        }
    }

    pub fn get_readEeprom(&self) -> &readEeprom_Out {
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::readEeprom(ref v)) => v,
            _ => readEeprom_Out::default_instance(),
        }
    }

    // optional .linkbot.robot.writeTwi.Out writeTwi = 50;

    pub fn clear_writeTwi(&mut self) {
        self.arg = ::std::option::Option::None;
    }

    pub fn has_writeTwi(&self) -> bool {
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::writeTwi(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_writeTwi(&mut self, v: writeTwi_Out) {
        self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::writeTwi(v))
    }

    // Mutable pointer to the field.
    pub fn mut_writeTwi(&mut self) -> &mut writeTwi_Out {
        if let ::std::option::Option::Some(RpcReply_oneof_arg::writeTwi(_)) = self.arg {
        } else {
            self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::writeTwi(writeTwi_Out::new()));
        }
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::writeTwi(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_writeTwi(&mut self) -> writeTwi_Out {
        if self.has_writeTwi() {
            match self.arg.take() {
                ::std::option::Option::Some(RpcReply_oneof_arg::writeTwi(v)) => v,
                _ => panic!(),
            }
        } else {
            writeTwi_Out::new()
        }
    }

    pub fn get_writeTwi(&self) -> &writeTwi_Out {
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::writeTwi(ref v)) => v,
            _ => writeTwi_Out::default_instance(),
        }
    }

    // optional .linkbot.robot.readTwi.Out readTwi = 51;

    pub fn clear_readTwi(&mut self) {
        self.arg = ::std::option::Option::None;
    }

    pub fn has_readTwi(&self) -> bool {
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::readTwi(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_readTwi(&mut self, v: readTwi_Out) {
        self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::readTwi(v))
    }

    // Mutable pointer to the field.
    pub fn mut_readTwi(&mut self) -> &mut readTwi_Out {
        if let ::std::option::Option::Some(RpcReply_oneof_arg::readTwi(_)) = self.arg {
        } else {
            self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::readTwi(readTwi_Out::new()));
        }
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::readTwi(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_readTwi(&mut self) -> readTwi_Out {
        if self.has_readTwi() {
            match self.arg.take() {
                ::std::option::Option::Some(RpcReply_oneof_arg::readTwi(v)) => v,
                _ => panic!(),
            }
        } else {
            readTwi_Out::new()
        }
    }

    pub fn get_readTwi(&self) -> &readTwi_Out {
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::readTwi(ref v)) => v,
            _ => readTwi_Out::default_instance(),
        }
    }

    // optional .linkbot.robot.writeReadTwi.Out writeReadTwi = 52;

    pub fn clear_writeReadTwi(&mut self) {
        self.arg = ::std::option::Option::None;
    }

    pub fn has_writeReadTwi(&self) -> bool {
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::writeReadTwi(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_writeReadTwi(&mut self, v: writeReadTwi_Out) {
        self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::writeReadTwi(v))
    }

    // Mutable pointer to the field.
    pub fn mut_writeReadTwi(&mut self) -> &mut writeReadTwi_Out {
        if let ::std::option::Option::Some(RpcReply_oneof_arg::writeReadTwi(_)) = self.arg {
        } else {
            self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::writeReadTwi(writeReadTwi_Out::new()));
        }
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::writeReadTwi(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_writeReadTwi(&mut self) -> writeReadTwi_Out {
        if self.has_writeReadTwi() {
            match self.arg.take() {
                ::std::option::Option::Some(RpcReply_oneof_arg::writeReadTwi(v)) => v,
                _ => panic!(),
            }
        } else {
            writeReadTwi_Out::new()
        }
    }

    pub fn get_writeReadTwi(&self) -> &writeReadTwi_Out {
        match self.arg {
            ::std::option::Option::Some(RpcReply_oneof_arg::writeReadTwi(ref v)) => v,
            _ => writeReadTwi_Out::default_instance(),
        }
    }
}

impl ::protobuf::Message for RpcReply {
    fn is_initialized(&self) -> bool {
        if let Some(RpcReply_oneof_arg::getFirmwareVersionString(ref v)) = self.arg {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RpcReply_oneof_arg::getFormFactor(ref v)) = self.arg {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RpcReply_oneof_arg::getAdcRaw(ref v)) = self.arg {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RpcReply_oneof_arg::getBatteryVoltage(ref v)) = self.arg {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RpcReply_oneof_arg::getAccelerometerData(ref v)) = self.arg {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RpcReply_oneof_arg::getButtonState(ref v)) = self.arg {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RpcReply_oneof_arg::getEncoderValues(ref v)) = self.arg {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RpcReply_oneof_arg::getJointStates(ref v)) = self.arg {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RpcReply_oneof_arg::enableAccelerometerEvent(ref v)) = self.arg {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RpcReply_oneof_arg::enableButtonEvent(ref v)) = self.arg {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RpcReply_oneof_arg::enableEncoderEvent(ref v)) = self.arg {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RpcReply_oneof_arg::enableJointEvent(ref v)) = self.arg {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RpcReply_oneof_arg::getBuzzerFrequency(ref v)) = self.arg {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RpcReply_oneof_arg::getLedColor(ref v)) = self.arg {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RpcReply_oneof_arg::getMotorControllerOmega(ref v)) = self.arg {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RpcReply_oneof_arg::getMotorControllerAlphaI(ref v)) = self.arg {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RpcReply_oneof_arg::getMotorControllerAlphaF(ref v)) = self.arg {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RpcReply_oneof_arg::getMotorControllerProportionalGain(ref v)) = self.arg {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RpcReply_oneof_arg::getMotorControllerIntegratorGain(ref v)) = self.arg {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RpcReply_oneof_arg::getMotorControllerDerivativeGain(ref v)) = self.arg {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RpcReply_oneof_arg::getMotorControllerSafetyThreshold(ref v)) = self.arg {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RpcReply_oneof_arg::getMotorControllerSafetyAngle(ref v)) = self.arg {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RpcReply_oneof_arg::setBuzzerFrequency(ref v)) = self.arg {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RpcReply_oneof_arg::setLedColor(ref v)) = self.arg {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RpcReply_oneof_arg::setMotorControllerOmega(ref v)) = self.arg {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RpcReply_oneof_arg::setMotorControllerAlphaI(ref v)) = self.arg {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RpcReply_oneof_arg::setMotorControllerAlphaF(ref v)) = self.arg {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RpcReply_oneof_arg::setMotorControllerProportionalGain(ref v)) = self.arg {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RpcReply_oneof_arg::setMotorControllerIntegratorGain(ref v)) = self.arg {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RpcReply_oneof_arg::setMotorControllerDerivativeGain(ref v)) = self.arg {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RpcReply_oneof_arg::setMotorControllerSafetyThreshold(ref v)) = self.arg {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RpcReply_oneof_arg::setMotorControllerSafetyAngle(ref v)) = self.arg {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RpcReply_oneof_arg::setResetOnDisconnect(ref v)) = self.arg {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RpcReply_oneof_arg::resetEncoderRevs(ref v)) = self.arg {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RpcReply_oneof_arg::robotMove(ref v)) = self.arg {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RpcReply_oneof_arg::stop(ref v)) = self.arg {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RpcReply_oneof_arg::reboot(ref v)) = self.arg {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RpcReply_oneof_arg::writeEeprom(ref v)) = self.arg {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RpcReply_oneof_arg::readEeprom(ref v)) = self.arg {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RpcReply_oneof_arg::writeTwi(ref v)) = self.arg {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RpcReply_oneof_arg::readTwi(ref v)) = self.arg {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RpcReply_oneof_arg::writeReadTwi(ref v)) = self.arg {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.requestId = ::std::option::Option::Some(tmp);
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::getFirmwareVersionString(is.read_message()?));
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::getFormFactor(is.read_message()?));
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::getAdcRaw(is.read_message()?));
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::getBatteryVoltage(is.read_message()?));
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::getAccelerometerData(is.read_message()?));
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::getButtonState(is.read_message()?));
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::getEncoderValues(is.read_message()?));
                },
                23 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::getJointStates(is.read_message()?));
                },
                24 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::enableAccelerometerEvent(is.read_message()?));
                },
                25 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::enableButtonEvent(is.read_message()?));
                },
                26 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::enableEncoderEvent(is.read_message()?));
                },
                27 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::enableJointEvent(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::getBuzzerFrequency(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::getLedColor(is.read_message()?));
                },
                28 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::getMotorControllerOmega(is.read_message()?));
                },
                29 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::getMotorControllerAlphaI(is.read_message()?));
                },
                30 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::getMotorControllerAlphaF(is.read_message()?));
                },
                31 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::getMotorControllerProportionalGain(is.read_message()?));
                },
                32 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::getMotorControllerIntegratorGain(is.read_message()?));
                },
                33 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::getMotorControllerDerivativeGain(is.read_message()?));
                },
                34 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::getMotorControllerSafetyThreshold(is.read_message()?));
                },
                35 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::getMotorControllerSafetyAngle(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::setBuzzerFrequency(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::setLedColor(is.read_message()?));
                },
                36 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::setMotorControllerOmega(is.read_message()?));
                },
                37 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::setMotorControllerAlphaI(is.read_message()?));
                },
                38 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::setMotorControllerAlphaF(is.read_message()?));
                },
                39 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::setMotorControllerProportionalGain(is.read_message()?));
                },
                40 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::setMotorControllerIntegratorGain(is.read_message()?));
                },
                41 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::setMotorControllerDerivativeGain(is.read_message()?));
                },
                42 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::setMotorControllerSafetyThreshold(is.read_message()?));
                },
                43 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::setMotorControllerSafetyAngle(is.read_message()?));
                },
                53 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::setResetOnDisconnect(is.read_message()?));
                },
                44 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::resetEncoderRevs(is.read_message()?));
                },
                45 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::robotMove(is.read_message()?));
                },
                46 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::stop(is.read_message()?));
                },
                47 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::reboot(is.read_message()?));
                },
                48 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::writeEeprom(is.read_message()?));
                },
                49 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::readEeprom(is.read_message()?));
                },
                50 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::writeTwi(is.read_message()?));
                },
                51 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::readTwi(is.read_message()?));
                },
                52 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.arg = ::std::option::Option::Some(RpcReply_oneof_arg::writeReadTwi(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.requestId {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let ::std::option::Option::Some(ref v) = self.arg {
            match v {
                &RpcReply_oneof_arg::getFirmwareVersionString(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RpcReply_oneof_arg::getFormFactor(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RpcReply_oneof_arg::getAdcRaw(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RpcReply_oneof_arg::getBatteryVoltage(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RpcReply_oneof_arg::getAccelerometerData(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RpcReply_oneof_arg::getButtonState(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RpcReply_oneof_arg::getEncoderValues(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RpcReply_oneof_arg::getJointStates(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RpcReply_oneof_arg::enableAccelerometerEvent(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RpcReply_oneof_arg::enableButtonEvent(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RpcReply_oneof_arg::enableEncoderEvent(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RpcReply_oneof_arg::enableJointEvent(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RpcReply_oneof_arg::getBuzzerFrequency(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RpcReply_oneof_arg::getLedColor(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RpcReply_oneof_arg::getMotorControllerOmega(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RpcReply_oneof_arg::getMotorControllerAlphaI(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RpcReply_oneof_arg::getMotorControllerAlphaF(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RpcReply_oneof_arg::getMotorControllerProportionalGain(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RpcReply_oneof_arg::getMotorControllerIntegratorGain(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RpcReply_oneof_arg::getMotorControllerDerivativeGain(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RpcReply_oneof_arg::getMotorControllerSafetyThreshold(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RpcReply_oneof_arg::getMotorControllerSafetyAngle(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RpcReply_oneof_arg::setBuzzerFrequency(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RpcReply_oneof_arg::setLedColor(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RpcReply_oneof_arg::setMotorControllerOmega(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RpcReply_oneof_arg::setMotorControllerAlphaI(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RpcReply_oneof_arg::setMotorControllerAlphaF(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RpcReply_oneof_arg::setMotorControllerProportionalGain(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RpcReply_oneof_arg::setMotorControllerIntegratorGain(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RpcReply_oneof_arg::setMotorControllerDerivativeGain(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RpcReply_oneof_arg::setMotorControllerSafetyThreshold(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RpcReply_oneof_arg::setMotorControllerSafetyAngle(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RpcReply_oneof_arg::setResetOnDisconnect(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RpcReply_oneof_arg::resetEncoderRevs(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RpcReply_oneof_arg::robotMove(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RpcReply_oneof_arg::stop(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RpcReply_oneof_arg::reboot(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RpcReply_oneof_arg::writeEeprom(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RpcReply_oneof_arg::readEeprom(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RpcReply_oneof_arg::writeTwi(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RpcReply_oneof_arg::readTwi(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RpcReply_oneof_arg::writeReadTwi(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.requestId {
            os.write_uint32(1, v)?;
        }
        if let ::std::option::Option::Some(ref v) = self.arg {
            match v {
                &RpcReply_oneof_arg::getFirmwareVersionString(ref v) => {
                    os.write_tag(16, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RpcReply_oneof_arg::getFormFactor(ref v) => {
                    os.write_tag(17, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RpcReply_oneof_arg::getAdcRaw(ref v) => {
                    os.write_tag(18, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RpcReply_oneof_arg::getBatteryVoltage(ref v) => {
                    os.write_tag(19, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RpcReply_oneof_arg::getAccelerometerData(ref v) => {
                    os.write_tag(20, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RpcReply_oneof_arg::getButtonState(ref v) => {
                    os.write_tag(21, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RpcReply_oneof_arg::getEncoderValues(ref v) => {
                    os.write_tag(22, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RpcReply_oneof_arg::getJointStates(ref v) => {
                    os.write_tag(23, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RpcReply_oneof_arg::enableAccelerometerEvent(ref v) => {
                    os.write_tag(24, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RpcReply_oneof_arg::enableButtonEvent(ref v) => {
                    os.write_tag(25, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RpcReply_oneof_arg::enableEncoderEvent(ref v) => {
                    os.write_tag(26, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RpcReply_oneof_arg::enableJointEvent(ref v) => {
                    os.write_tag(27, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RpcReply_oneof_arg::getBuzzerFrequency(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RpcReply_oneof_arg::getLedColor(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RpcReply_oneof_arg::getMotorControllerOmega(ref v) => {
                    os.write_tag(28, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RpcReply_oneof_arg::getMotorControllerAlphaI(ref v) => {
                    os.write_tag(29, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RpcReply_oneof_arg::getMotorControllerAlphaF(ref v) => {
                    os.write_tag(30, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RpcReply_oneof_arg::getMotorControllerProportionalGain(ref v) => {
                    os.write_tag(31, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RpcReply_oneof_arg::getMotorControllerIntegratorGain(ref v) => {
                    os.write_tag(32, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RpcReply_oneof_arg::getMotorControllerDerivativeGain(ref v) => {
                    os.write_tag(33, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RpcReply_oneof_arg::getMotorControllerSafetyThreshold(ref v) => {
                    os.write_tag(34, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RpcReply_oneof_arg::getMotorControllerSafetyAngle(ref v) => {
                    os.write_tag(35, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RpcReply_oneof_arg::setBuzzerFrequency(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RpcReply_oneof_arg::setLedColor(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RpcReply_oneof_arg::setMotorControllerOmega(ref v) => {
                    os.write_tag(36, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RpcReply_oneof_arg::setMotorControllerAlphaI(ref v) => {
                    os.write_tag(37, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RpcReply_oneof_arg::setMotorControllerAlphaF(ref v) => {
                    os.write_tag(38, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RpcReply_oneof_arg::setMotorControllerProportionalGain(ref v) => {
                    os.write_tag(39, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RpcReply_oneof_arg::setMotorControllerIntegratorGain(ref v) => {
                    os.write_tag(40, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RpcReply_oneof_arg::setMotorControllerDerivativeGain(ref v) => {
                    os.write_tag(41, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RpcReply_oneof_arg::setMotorControllerSafetyThreshold(ref v) => {
                    os.write_tag(42, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RpcReply_oneof_arg::setMotorControllerSafetyAngle(ref v) => {
                    os.write_tag(43, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RpcReply_oneof_arg::setResetOnDisconnect(ref v) => {
                    os.write_tag(53, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RpcReply_oneof_arg::resetEncoderRevs(ref v) => {
                    os.write_tag(44, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RpcReply_oneof_arg::robotMove(ref v) => {
                    os.write_tag(45, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RpcReply_oneof_arg::stop(ref v) => {
                    os.write_tag(46, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RpcReply_oneof_arg::reboot(ref v) => {
                    os.write_tag(47, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RpcReply_oneof_arg::writeEeprom(ref v) => {
                    os.write_tag(48, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RpcReply_oneof_arg::readEeprom(ref v) => {
                    os.write_tag(49, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RpcReply_oneof_arg::writeTwi(ref v) => {
                    os.write_tag(50, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RpcReply_oneof_arg::readTwi(ref v) => {
                    os.write_tag(51, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RpcReply_oneof_arg::writeReadTwi(ref v) => {
                    os.write_tag(52, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for RpcReply {
    fn new() -> RpcReply {
        RpcReply::new()
    }

    fn descriptor_static(_: ::std::option::Option<RpcReply>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "requestId",
                    RpcReply::get_requestId_for_reflect,
                    RpcReply::mut_requestId_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, getFirmwareVersionString_Out>(
                    "getFirmwareVersionString",
                    RpcReply::has_getFirmwareVersionString,
                    RpcReply::get_getFirmwareVersionString,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, getFormFactor_Out>(
                    "getFormFactor",
                    RpcReply::has_getFormFactor,
                    RpcReply::get_getFormFactor,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, getAdcRaw_Out>(
                    "getAdcRaw",
                    RpcReply::has_getAdcRaw,
                    RpcReply::get_getAdcRaw,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, getBatteryVoltage_Out>(
                    "getBatteryVoltage",
                    RpcReply::has_getBatteryVoltage,
                    RpcReply::get_getBatteryVoltage,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, getAccelerometerData_Out>(
                    "getAccelerometerData",
                    RpcReply::has_getAccelerometerData,
                    RpcReply::get_getAccelerometerData,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, getButtonState_Out>(
                    "getButtonState",
                    RpcReply::has_getButtonState,
                    RpcReply::get_getButtonState,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, getEncoderValues_Out>(
                    "getEncoderValues",
                    RpcReply::has_getEncoderValues,
                    RpcReply::get_getEncoderValues,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, getJointStates_Out>(
                    "getJointStates",
                    RpcReply::has_getJointStates,
                    RpcReply::get_getJointStates,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, enableAccelerometerEvent_Out>(
                    "enableAccelerometerEvent",
                    RpcReply::has_enableAccelerometerEvent,
                    RpcReply::get_enableAccelerometerEvent,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, enableButtonEvent_Out>(
                    "enableButtonEvent",
                    RpcReply::has_enableButtonEvent,
                    RpcReply::get_enableButtonEvent,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, enableEncoderEvent_Out>(
                    "enableEncoderEvent",
                    RpcReply::has_enableEncoderEvent,
                    RpcReply::get_enableEncoderEvent,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, enableJointEvent_Out>(
                    "enableJointEvent",
                    RpcReply::has_enableJointEvent,
                    RpcReply::get_enableJointEvent,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, getBuzzerFrequency_Out>(
                    "getBuzzerFrequency",
                    RpcReply::has_getBuzzerFrequency,
                    RpcReply::get_getBuzzerFrequency,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, getLedColor_Out>(
                    "getLedColor",
                    RpcReply::has_getLedColor,
                    RpcReply::get_getLedColor,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, getMotorControllerOmega_Out>(
                    "getMotorControllerOmega",
                    RpcReply::has_getMotorControllerOmega,
                    RpcReply::get_getMotorControllerOmega,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, getMotorControllerAlphaI_Out>(
                    "getMotorControllerAlphaI",
                    RpcReply::has_getMotorControllerAlphaI,
                    RpcReply::get_getMotorControllerAlphaI,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, getMotorControllerAlphaF_Out>(
                    "getMotorControllerAlphaF",
                    RpcReply::has_getMotorControllerAlphaF,
                    RpcReply::get_getMotorControllerAlphaF,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, getMotorControllerProportionalGain_Out>(
                    "getMotorControllerProportionalGain",
                    RpcReply::has_getMotorControllerProportionalGain,
                    RpcReply::get_getMotorControllerProportionalGain,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, getMotorControllerIntegratorGain_Out>(
                    "getMotorControllerIntegratorGain",
                    RpcReply::has_getMotorControllerIntegratorGain,
                    RpcReply::get_getMotorControllerIntegratorGain,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, getMotorControllerDerivativeGain_Out>(
                    "getMotorControllerDerivativeGain",
                    RpcReply::has_getMotorControllerDerivativeGain,
                    RpcReply::get_getMotorControllerDerivativeGain,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, getMotorControllerSafetyThreshold_Out>(
                    "getMotorControllerSafetyThreshold",
                    RpcReply::has_getMotorControllerSafetyThreshold,
                    RpcReply::get_getMotorControllerSafetyThreshold,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, getMotorControllerSafetyAngle_Out>(
                    "getMotorControllerSafetyAngle",
                    RpcReply::has_getMotorControllerSafetyAngle,
                    RpcReply::get_getMotorControllerSafetyAngle,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, setBuzzerFrequency_Out>(
                    "setBuzzerFrequency",
                    RpcReply::has_setBuzzerFrequency,
                    RpcReply::get_setBuzzerFrequency,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, setLedColor_Out>(
                    "setLedColor",
                    RpcReply::has_setLedColor,
                    RpcReply::get_setLedColor,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, setMotorControllerOmega_Out>(
                    "setMotorControllerOmega",
                    RpcReply::has_setMotorControllerOmega,
                    RpcReply::get_setMotorControllerOmega,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, setMotorControllerAlphaI_Out>(
                    "setMotorControllerAlphaI",
                    RpcReply::has_setMotorControllerAlphaI,
                    RpcReply::get_setMotorControllerAlphaI,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, setMotorControllerAlphaF_Out>(
                    "setMotorControllerAlphaF",
                    RpcReply::has_setMotorControllerAlphaF,
                    RpcReply::get_setMotorControllerAlphaF,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, setMotorControllerProportionalGain_Out>(
                    "setMotorControllerProportionalGain",
                    RpcReply::has_setMotorControllerProportionalGain,
                    RpcReply::get_setMotorControllerProportionalGain,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, setMotorControllerIntegratorGain_Out>(
                    "setMotorControllerIntegratorGain",
                    RpcReply::has_setMotorControllerIntegratorGain,
                    RpcReply::get_setMotorControllerIntegratorGain,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, setMotorControllerDerivativeGain_Out>(
                    "setMotorControllerDerivativeGain",
                    RpcReply::has_setMotorControllerDerivativeGain,
                    RpcReply::get_setMotorControllerDerivativeGain,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, setMotorControllerSafetyThreshold_Out>(
                    "setMotorControllerSafetyThreshold",
                    RpcReply::has_setMotorControllerSafetyThreshold,
                    RpcReply::get_setMotorControllerSafetyThreshold,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, setMotorControllerSafetyAngle_Out>(
                    "setMotorControllerSafetyAngle",
                    RpcReply::has_setMotorControllerSafetyAngle,
                    RpcReply::get_setMotorControllerSafetyAngle,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, setResetOnDisconnect_Out>(
                    "setResetOnDisconnect",
                    RpcReply::has_setResetOnDisconnect,
                    RpcReply::get_setResetOnDisconnect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, resetEncoderRevs_Out>(
                    "resetEncoderRevs",
                    RpcReply::has_resetEncoderRevs,
                    RpcReply::get_resetEncoderRevs,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, robotMove_Out>(
                    "robotMove",
                    RpcReply::has_robotMove,
                    RpcReply::get_robotMove,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, stop_Out>(
                    "stop",
                    RpcReply::has_stop,
                    RpcReply::get_stop,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, reboot_Out>(
                    "reboot",
                    RpcReply::has_reboot,
                    RpcReply::get_reboot,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, writeEeprom_Out>(
                    "writeEeprom",
                    RpcReply::has_writeEeprom,
                    RpcReply::get_writeEeprom,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, readEeprom_Out>(
                    "readEeprom",
                    RpcReply::has_readEeprom,
                    RpcReply::get_readEeprom,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, writeTwi_Out>(
                    "writeTwi",
                    RpcReply::has_writeTwi,
                    RpcReply::get_writeTwi,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, readTwi_Out>(
                    "readTwi",
                    RpcReply::has_readTwi,
                    RpcReply::get_readTwi,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, writeReadTwi_Out>(
                    "writeReadTwi",
                    RpcReply::has_writeReadTwi,
                    RpcReply::get_writeReadTwi,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RpcReply>(
                    "RpcReply",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for RpcReply {
    fn clear(&mut self) {
        self.clear_requestId();
        self.clear_getFirmwareVersionString();
        self.clear_getFormFactor();
        self.clear_getAdcRaw();
        self.clear_getBatteryVoltage();
        self.clear_getAccelerometerData();
        self.clear_getButtonState();
        self.clear_getEncoderValues();
        self.clear_getJointStates();
        self.clear_enableAccelerometerEvent();
        self.clear_enableButtonEvent();
        self.clear_enableEncoderEvent();
        self.clear_enableJointEvent();
        self.clear_getBuzzerFrequency();
        self.clear_getLedColor();
        self.clear_getMotorControllerOmega();
        self.clear_getMotorControllerAlphaI();
        self.clear_getMotorControllerAlphaF();
        self.clear_getMotorControllerProportionalGain();
        self.clear_getMotorControllerIntegratorGain();
        self.clear_getMotorControllerDerivativeGain();
        self.clear_getMotorControllerSafetyThreshold();
        self.clear_getMotorControllerSafetyAngle();
        self.clear_setBuzzerFrequency();
        self.clear_setLedColor();
        self.clear_setMotorControllerOmega();
        self.clear_setMotorControllerAlphaI();
        self.clear_setMotorControllerAlphaF();
        self.clear_setMotorControllerProportionalGain();
        self.clear_setMotorControllerIntegratorGain();
        self.clear_setMotorControllerDerivativeGain();
        self.clear_setMotorControllerSafetyThreshold();
        self.clear_setMotorControllerSafetyAngle();
        self.clear_setResetOnDisconnect();
        self.clear_resetEncoderRevs();
        self.clear_robotMove();
        self.clear_stop();
        self.clear_reboot();
        self.clear_writeEeprom();
        self.clear_readEeprom();
        self.clear_writeTwi();
        self.clear_readTwi();
        self.clear_writeReadTwi();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RpcReply {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RpcReply {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ButtonEvent {
    // message fields
    timestamp: ::std::option::Option<u32>,
    button: ::std::option::Option<Button>,
    state: ::std::option::Option<ButtonState>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ButtonEvent {}

impl ButtonEvent {
    pub fn new() -> ButtonEvent {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ButtonEvent {
        static mut instance: ::protobuf::lazy::Lazy<ButtonEvent> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ButtonEvent,
        };
        unsafe {
            instance.get(ButtonEvent::new)
        }
    }

    // optional uint32 timestamp = 1;

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    pub fn get_timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }

    fn get_timestamp_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.timestamp
    }

    fn mut_timestamp_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.timestamp
    }

    // optional .linkbot.robot.Button button = 2;

    pub fn clear_button(&mut self) {
        self.button = ::std::option::Option::None;
    }

    pub fn has_button(&self) -> bool {
        self.button.is_some()
    }

    // Param is passed by value, moved
    pub fn set_button(&mut self, v: Button) {
        self.button = ::std::option::Option::Some(v);
    }

    pub fn get_button(&self) -> Button {
        self.button.unwrap_or(Button::POWER)
    }

    fn get_button_for_reflect(&self) -> &::std::option::Option<Button> {
        &self.button
    }

    fn mut_button_for_reflect(&mut self) -> &mut ::std::option::Option<Button> {
        &mut self.button
    }

    // optional .linkbot.robot.ButtonState state = 3;

    pub fn clear_state(&mut self) {
        self.state = ::std::option::Option::None;
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: ButtonState) {
        self.state = ::std::option::Option::Some(v);
    }

    pub fn get_state(&self) -> ButtonState {
        self.state.unwrap_or(ButtonState::UP)
    }

    fn get_state_for_reflect(&self) -> &::std::option::Option<ButtonState> {
        &self.state
    }

    fn mut_state_for_reflect(&mut self) -> &mut ::std::option::Option<ButtonState> {
        &mut self.state
    }
}

impl ::protobuf::Message for ButtonEvent {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.timestamp = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.button = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.state = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.button {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        if let Some(v) = self.state {
            my_size += ::protobuf::rt::enum_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.timestamp {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.button {
            os.write_enum(2, v.value())?;
        }
        if let Some(v) = self.state {
            os.write_enum(3, v.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ButtonEvent {
    fn new() -> ButtonEvent {
        ButtonEvent::new()
    }

    fn descriptor_static(_: ::std::option::Option<ButtonEvent>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "timestamp",
                    ButtonEvent::get_timestamp_for_reflect,
                    ButtonEvent::mut_timestamp_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Button>>(
                    "button",
                    ButtonEvent::get_button_for_reflect,
                    ButtonEvent::mut_button_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ButtonState>>(
                    "state",
                    ButtonEvent::get_state_for_reflect,
                    ButtonEvent::mut_state_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ButtonEvent>(
                    "ButtonEvent",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ButtonEvent {
    fn clear(&mut self) {
        self.clear_timestamp();
        self.clear_button();
        self.clear_state();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ButtonEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ButtonEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EncoderEvent {
    // message fields
    timestamp: ::std::option::Option<u32>,
    mask: ::std::option::Option<u32>,
    values: ::std::vec::Vec<f32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for EncoderEvent {}

impl EncoderEvent {
    pub fn new() -> EncoderEvent {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static EncoderEvent {
        static mut instance: ::protobuf::lazy::Lazy<EncoderEvent> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const EncoderEvent,
        };
        unsafe {
            instance.get(EncoderEvent::new)
        }
    }

    // optional uint32 timestamp = 1;

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    pub fn get_timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }

    fn get_timestamp_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.timestamp
    }

    fn mut_timestamp_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.timestamp
    }

    // optional uint32 mask = 2;

    pub fn clear_mask(&mut self) {
        self.mask = ::std::option::Option::None;
    }

    pub fn has_mask(&self) -> bool {
        self.mask.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mask(&mut self, v: u32) {
        self.mask = ::std::option::Option::Some(v);
    }

    pub fn get_mask(&self) -> u32 {
        self.mask.unwrap_or(0)
    }

    fn get_mask_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.mask
    }

    fn mut_mask_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.mask
    }

    // repeated float values = 3;

    pub fn clear_values(&mut self) {
        self.values.clear();
    }

    // Param is passed by value, moved
    pub fn set_values(&mut self, v: ::std::vec::Vec<f32>) {
        self.values = v;
    }

    // Mutable pointer to the field.
    pub fn mut_values(&mut self) -> &mut ::std::vec::Vec<f32> {
        &mut self.values
    }

    // Take field
    pub fn take_values(&mut self) -> ::std::vec::Vec<f32> {
        ::std::mem::replace(&mut self.values, ::std::vec::Vec::new())
    }

    pub fn get_values(&self) -> &[f32] {
        &self.values
    }

    fn get_values_for_reflect(&self) -> &::std::vec::Vec<f32> {
        &self.values
    }

    fn mut_values_for_reflect(&mut self) -> &mut ::std::vec::Vec<f32> {
        &mut self.values
    }
}

impl ::protobuf::Message for EncoderEvent {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.timestamp = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.mask = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_float_into(wire_type, is, &mut self.values)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.mask {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.values.is_empty() {
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(self.values.len() as u32) + (self.values.len() * 4) as u32;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.timestamp {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.mask {
            os.write_uint32(2, v)?;
        }
        if !self.values.is_empty() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32((self.values.len() * 4) as u32)?;
            for v in &self.values {
                os.write_float_no_tag(*v)?;
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for EncoderEvent {
    fn new() -> EncoderEvent {
        EncoderEvent::new()
    }

    fn descriptor_static(_: ::std::option::Option<EncoderEvent>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "timestamp",
                    EncoderEvent::get_timestamp_for_reflect,
                    EncoderEvent::mut_timestamp_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "mask",
                    EncoderEvent::get_mask_for_reflect,
                    EncoderEvent::mut_mask_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "values",
                    EncoderEvent::get_values_for_reflect,
                    EncoderEvent::mut_values_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<EncoderEvent>(
                    "EncoderEvent",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for EncoderEvent {
    fn clear(&mut self) {
        self.clear_timestamp();
        self.clear_mask();
        self.clear_values();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EncoderEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EncoderEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AccelerometerEvent {
    // message fields
    timestamp: ::std::option::Option<u32>,
    x: ::std::option::Option<f32>,
    y: ::std::option::Option<f32>,
    z: ::std::option::Option<f32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for AccelerometerEvent {}

impl AccelerometerEvent {
    pub fn new() -> AccelerometerEvent {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static AccelerometerEvent {
        static mut instance: ::protobuf::lazy::Lazy<AccelerometerEvent> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AccelerometerEvent,
        };
        unsafe {
            instance.get(AccelerometerEvent::new)
        }
    }

    // optional uint32 timestamp = 1;

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    pub fn get_timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }

    fn get_timestamp_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.timestamp
    }

    fn mut_timestamp_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.timestamp
    }

    // optional float x = 2;

    pub fn clear_x(&mut self) {
        self.x = ::std::option::Option::None;
    }

    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: f32) {
        self.x = ::std::option::Option::Some(v);
    }

    pub fn get_x(&self) -> f32 {
        self.x.unwrap_or(0.)
    }

    fn get_x_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.x
    }

    fn mut_x_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.x
    }

    // optional float y = 3;

    pub fn clear_y(&mut self) {
        self.y = ::std::option::Option::None;
    }

    pub fn has_y(&self) -> bool {
        self.y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: f32) {
        self.y = ::std::option::Option::Some(v);
    }

    pub fn get_y(&self) -> f32 {
        self.y.unwrap_or(0.)
    }

    fn get_y_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.y
    }

    fn mut_y_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.y
    }

    // optional float z = 4;

    pub fn clear_z(&mut self) {
        self.z = ::std::option::Option::None;
    }

    pub fn has_z(&self) -> bool {
        self.z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_z(&mut self, v: f32) {
        self.z = ::std::option::Option::Some(v);
    }

    pub fn get_z(&self) -> f32 {
        self.z.unwrap_or(0.)
    }

    fn get_z_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.z
    }

    fn mut_z_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.z
    }
}

impl ::protobuf::Message for AccelerometerEvent {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.timestamp = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.x = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.y = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.z = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.x {
            my_size += 5;
        }
        if let Some(v) = self.y {
            my_size += 5;
        }
        if let Some(v) = self.z {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.timestamp {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.x {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.y {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.z {
            os.write_float(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for AccelerometerEvent {
    fn new() -> AccelerometerEvent {
        AccelerometerEvent::new()
    }

    fn descriptor_static(_: ::std::option::Option<AccelerometerEvent>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "timestamp",
                    AccelerometerEvent::get_timestamp_for_reflect,
                    AccelerometerEvent::mut_timestamp_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "x",
                    AccelerometerEvent::get_x_for_reflect,
                    AccelerometerEvent::mut_x_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "y",
                    AccelerometerEvent::get_y_for_reflect,
                    AccelerometerEvent::mut_y_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "z",
                    AccelerometerEvent::get_z_for_reflect,
                    AccelerometerEvent::mut_z_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AccelerometerEvent>(
                    "AccelerometerEvent",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for AccelerometerEvent {
    fn clear(&mut self) {
        self.clear_timestamp();
        self.clear_x();
        self.clear_y();
        self.clear_z();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AccelerometerEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AccelerometerEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct JointEvent {
    // message fields
    timestamp: ::std::option::Option<u32>,
    joint: ::std::option::Option<u32>,
    event: ::std::option::Option<JointState>,
    angle: ::std::option::Option<f32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for JointEvent {}

impl JointEvent {
    pub fn new() -> JointEvent {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static JointEvent {
        static mut instance: ::protobuf::lazy::Lazy<JointEvent> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const JointEvent,
        };
        unsafe {
            instance.get(JointEvent::new)
        }
    }

    // optional uint32 timestamp = 1;

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    pub fn get_timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }

    fn get_timestamp_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.timestamp
    }

    fn mut_timestamp_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.timestamp
    }

    // optional uint32 joint = 2;

    pub fn clear_joint(&mut self) {
        self.joint = ::std::option::Option::None;
    }

    pub fn has_joint(&self) -> bool {
        self.joint.is_some()
    }

    // Param is passed by value, moved
    pub fn set_joint(&mut self, v: u32) {
        self.joint = ::std::option::Option::Some(v);
    }

    pub fn get_joint(&self) -> u32 {
        self.joint.unwrap_or(0)
    }

    fn get_joint_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.joint
    }

    fn mut_joint_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.joint
    }

    // optional .linkbot.robot.JointState event = 3;

    pub fn clear_event(&mut self) {
        self.event = ::std::option::Option::None;
    }

    pub fn has_event(&self) -> bool {
        self.event.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event(&mut self, v: JointState) {
        self.event = ::std::option::Option::Some(v);
    }

    pub fn get_event(&self) -> JointState {
        self.event.unwrap_or(JointState::COAST)
    }

    fn get_event_for_reflect(&self) -> &::std::option::Option<JointState> {
        &self.event
    }

    fn mut_event_for_reflect(&mut self) -> &mut ::std::option::Option<JointState> {
        &mut self.event
    }

    // optional float angle = 4;

    pub fn clear_angle(&mut self) {
        self.angle = ::std::option::Option::None;
    }

    pub fn has_angle(&self) -> bool {
        self.angle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_angle(&mut self, v: f32) {
        self.angle = ::std::option::Option::Some(v);
    }

    pub fn get_angle(&self) -> f32 {
        self.angle.unwrap_or(0.)
    }

    fn get_angle_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.angle
    }

    fn mut_angle_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.angle
    }
}

impl ::protobuf::Message for JointEvent {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.timestamp = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.joint = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.event = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.angle = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.joint {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.event {
            my_size += ::protobuf::rt::enum_size(3, v);
        }
        if let Some(v) = self.angle {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.timestamp {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.joint {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.event {
            os.write_enum(3, v.value())?;
        }
        if let Some(v) = self.angle {
            os.write_float(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for JointEvent {
    fn new() -> JointEvent {
        JointEvent::new()
    }

    fn descriptor_static(_: ::std::option::Option<JointEvent>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "timestamp",
                    JointEvent::get_timestamp_for_reflect,
                    JointEvent::mut_timestamp_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "joint",
                    JointEvent::get_joint_for_reflect,
                    JointEvent::mut_joint_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<JointState>>(
                    "event",
                    JointEvent::get_event_for_reflect,
                    JointEvent::mut_event_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "angle",
                    JointEvent::get_angle_for_reflect,
                    JointEvent::mut_angle_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<JointEvent>(
                    "JointEvent",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for JointEvent {
    fn clear(&mut self) {
        self.clear_timestamp();
        self.clear_joint();
        self.clear_event();
        self.clear_angle();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for JointEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for JointEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DebugMessageEvent {
    // message fields
    timestamp: ::std::option::Option<u32>,
    bytestring: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for DebugMessageEvent {}

impl DebugMessageEvent {
    pub fn new() -> DebugMessageEvent {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static DebugMessageEvent {
        static mut instance: ::protobuf::lazy::Lazy<DebugMessageEvent> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DebugMessageEvent,
        };
        unsafe {
            instance.get(DebugMessageEvent::new)
        }
    }

    // optional uint32 timestamp = 1;

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    pub fn get_timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }

    fn get_timestamp_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.timestamp
    }

    fn mut_timestamp_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.timestamp
    }

    // optional string bytestring = 2;

    pub fn clear_bytestring(&mut self) {
        self.bytestring.clear();
    }

    pub fn has_bytestring(&self) -> bool {
        self.bytestring.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytestring(&mut self, v: ::std::string::String) {
        self.bytestring = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bytestring(&mut self) -> &mut ::std::string::String {
        if self.bytestring.is_none() {
            self.bytestring.set_default();
        }
        self.bytestring.as_mut().unwrap()
    }

    // Take field
    pub fn take_bytestring(&mut self) -> ::std::string::String {
        self.bytestring.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_bytestring(&self) -> &str {
        match self.bytestring.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_bytestring_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.bytestring
    }

    fn mut_bytestring_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.bytestring
    }
}

impl ::protobuf::Message for DebugMessageEvent {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.timestamp = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.bytestring)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.bytestring.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.timestamp {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.bytestring.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for DebugMessageEvent {
    fn new() -> DebugMessageEvent {
        DebugMessageEvent::new()
    }

    fn descriptor_static(_: ::std::option::Option<DebugMessageEvent>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "timestamp",
                    DebugMessageEvent::get_timestamp_for_reflect,
                    DebugMessageEvent::mut_timestamp_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "bytestring",
                    DebugMessageEvent::get_bytestring_for_reflect,
                    DebugMessageEvent::mut_bytestring_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DebugMessageEvent>(
                    "DebugMessageEvent",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for DebugMessageEvent {
    fn clear(&mut self) {
        self.clear_timestamp();
        self.clear_bytestring();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DebugMessageEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DebugMessageEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConnectEvent {
    // message fields
    timestamp: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ConnectEvent {}

impl ConnectEvent {
    pub fn new() -> ConnectEvent {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ConnectEvent {
        static mut instance: ::protobuf::lazy::Lazy<ConnectEvent> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ConnectEvent,
        };
        unsafe {
            instance.get(ConnectEvent::new)
        }
    }

    // optional uint32 timestamp = 1;

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    pub fn get_timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }

    fn get_timestamp_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.timestamp
    }

    fn mut_timestamp_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.timestamp
    }
}

impl ::protobuf::Message for ConnectEvent {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.timestamp = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.timestamp {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ConnectEvent {
    fn new() -> ConnectEvent {
        ConnectEvent::new()
    }

    fn descriptor_static(_: ::std::option::Option<ConnectEvent>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "timestamp",
                    ConnectEvent::get_timestamp_for_reflect,
                    ConnectEvent::mut_timestamp_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ConnectEvent>(
                    "ConnectEvent",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ConnectEvent {
    fn clear(&mut self) {
        self.clear_timestamp();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConnectEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConnectEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DisconnectEvent {
    // message fields
    timestamp: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for DisconnectEvent {}

impl DisconnectEvent {
    pub fn new() -> DisconnectEvent {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static DisconnectEvent {
        static mut instance: ::protobuf::lazy::Lazy<DisconnectEvent> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DisconnectEvent,
        };
        unsafe {
            instance.get(DisconnectEvent::new)
        }
    }

    // optional uint32 timestamp = 1;

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    pub fn get_timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }

    fn get_timestamp_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.timestamp
    }

    fn mut_timestamp_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.timestamp
    }
}

impl ::protobuf::Message for DisconnectEvent {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.timestamp = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.timestamp {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for DisconnectEvent {
    fn new() -> DisconnectEvent {
        DisconnectEvent::new()
    }

    fn descriptor_static(_: ::std::option::Option<DisconnectEvent>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "timestamp",
                    DisconnectEvent::get_timestamp_for_reflect,
                    DisconnectEvent::mut_timestamp_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DisconnectEvent>(
                    "DisconnectEvent",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for DisconnectEvent {
    fn clear(&mut self) {
        self.clear_timestamp();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DisconnectEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DisconnectEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ResetPeripherals {
    // message fields
    peripheralResetMask: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ResetPeripherals {}

impl ResetPeripherals {
    pub fn new() -> ResetPeripherals {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ResetPeripherals {
        static mut instance: ::protobuf::lazy::Lazy<ResetPeripherals> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ResetPeripherals,
        };
        unsafe {
            instance.get(ResetPeripherals::new)
        }
    }

    // optional uint32 peripheralResetMask = 2;

    pub fn clear_peripheralResetMask(&mut self) {
        self.peripheralResetMask = ::std::option::Option::None;
    }

    pub fn has_peripheralResetMask(&self) -> bool {
        self.peripheralResetMask.is_some()
    }

    // Param is passed by value, moved
    pub fn set_peripheralResetMask(&mut self, v: u32) {
        self.peripheralResetMask = ::std::option::Option::Some(v);
    }

    pub fn get_peripheralResetMask(&self) -> u32 {
        self.peripheralResetMask.unwrap_or(0)
    }

    fn get_peripheralResetMask_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.peripheralResetMask
    }

    fn mut_peripheralResetMask_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.peripheralResetMask
    }
}

impl ::protobuf::Message for ResetPeripherals {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.peripheralResetMask = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.peripheralResetMask {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.peripheralResetMask {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ResetPeripherals {
    fn new() -> ResetPeripherals {
        ResetPeripherals::new()
    }

    fn descriptor_static(_: ::std::option::Option<ResetPeripherals>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "peripheralResetMask",
                    ResetPeripherals::get_peripheralResetMask_for_reflect,
                    ResetPeripherals::mut_peripheralResetMask_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ResetPeripherals>(
                    "ResetPeripherals",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ResetPeripherals {
    fn clear(&mut self) {
        self.clear_peripheralResetMask();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ResetPeripherals {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResetPeripherals {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ClientToRobot {
    // message oneof groups
    arg: ::std::option::Option<ClientToRobot_oneof_arg>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ClientToRobot {}

#[derive(Clone,PartialEq)]
pub enum ClientToRobot_oneof_arg {
    rpcRequest(RpcRequest),
}

impl ClientToRobot {
    pub fn new() -> ClientToRobot {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ClientToRobot {
        static mut instance: ::protobuf::lazy::Lazy<ClientToRobot> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ClientToRobot,
        };
        unsafe {
            instance.get(ClientToRobot::new)
        }
    }

    // optional .linkbot.robot.RpcRequest rpcRequest = 1;

    pub fn clear_rpcRequest(&mut self) {
        self.arg = ::std::option::Option::None;
    }

    pub fn has_rpcRequest(&self) -> bool {
        match self.arg {
            ::std::option::Option::Some(ClientToRobot_oneof_arg::rpcRequest(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_rpcRequest(&mut self, v: RpcRequest) {
        self.arg = ::std::option::Option::Some(ClientToRobot_oneof_arg::rpcRequest(v))
    }

    // Mutable pointer to the field.
    pub fn mut_rpcRequest(&mut self) -> &mut RpcRequest {
        if let ::std::option::Option::Some(ClientToRobot_oneof_arg::rpcRequest(_)) = self.arg {
        } else {
            self.arg = ::std::option::Option::Some(ClientToRobot_oneof_arg::rpcRequest(RpcRequest::new()));
        }
        match self.arg {
            ::std::option::Option::Some(ClientToRobot_oneof_arg::rpcRequest(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_rpcRequest(&mut self) -> RpcRequest {
        if self.has_rpcRequest() {
            match self.arg.take() {
                ::std::option::Option::Some(ClientToRobot_oneof_arg::rpcRequest(v)) => v,
                _ => panic!(),
            }
        } else {
            RpcRequest::new()
        }
    }

    pub fn get_rpcRequest(&self) -> &RpcRequest {
        match self.arg {
            ::std::option::Option::Some(ClientToRobot_oneof_arg::rpcRequest(ref v)) => v,
            _ => RpcRequest::default_instance(),
        }
    }
}

impl ::protobuf::Message for ClientToRobot {
    fn is_initialized(&self) -> bool {
        if let Some(ClientToRobot_oneof_arg::rpcRequest(ref v)) = self.arg {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.arg = ::std::option::Option::Some(ClientToRobot_oneof_arg::rpcRequest(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.arg {
            match v {
                &ClientToRobot_oneof_arg::rpcRequest(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.arg {
            match v {
                &ClientToRobot_oneof_arg::rpcRequest(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ClientToRobot {
    fn new() -> ClientToRobot {
        ClientToRobot::new()
    }

    fn descriptor_static(_: ::std::option::Option<ClientToRobot>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RpcRequest>(
                    "rpcRequest",
                    ClientToRobot::has_rpcRequest,
                    ClientToRobot::get_rpcRequest,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ClientToRobot>(
                    "ClientToRobot",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ClientToRobot {
    fn clear(&mut self) {
        self.clear_rpcRequest();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ClientToRobot {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClientToRobot {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ClientToRobotBroadcast {
    // message oneof groups
    arg: ::std::option::Option<ClientToRobotBroadcast_oneof_arg>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ClientToRobotBroadcast {}

#[derive(Clone,PartialEq)]
pub enum ClientToRobotBroadcast_oneof_arg {
    resetPeripherals(ResetPeripherals),
}

impl ClientToRobotBroadcast {
    pub fn new() -> ClientToRobotBroadcast {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ClientToRobotBroadcast {
        static mut instance: ::protobuf::lazy::Lazy<ClientToRobotBroadcast> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ClientToRobotBroadcast,
        };
        unsafe {
            instance.get(ClientToRobotBroadcast::new)
        }
    }

    // optional .linkbot.robot.ResetPeripherals resetPeripherals = 1;

    pub fn clear_resetPeripherals(&mut self) {
        self.arg = ::std::option::Option::None;
    }

    pub fn has_resetPeripherals(&self) -> bool {
        match self.arg {
            ::std::option::Option::Some(ClientToRobotBroadcast_oneof_arg::resetPeripherals(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_resetPeripherals(&mut self, v: ResetPeripherals) {
        self.arg = ::std::option::Option::Some(ClientToRobotBroadcast_oneof_arg::resetPeripherals(v))
    }

    // Mutable pointer to the field.
    pub fn mut_resetPeripherals(&mut self) -> &mut ResetPeripherals {
        if let ::std::option::Option::Some(ClientToRobotBroadcast_oneof_arg::resetPeripherals(_)) = self.arg {
        } else {
            self.arg = ::std::option::Option::Some(ClientToRobotBroadcast_oneof_arg::resetPeripherals(ResetPeripherals::new()));
        }
        match self.arg {
            ::std::option::Option::Some(ClientToRobotBroadcast_oneof_arg::resetPeripherals(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_resetPeripherals(&mut self) -> ResetPeripherals {
        if self.has_resetPeripherals() {
            match self.arg.take() {
                ::std::option::Option::Some(ClientToRobotBroadcast_oneof_arg::resetPeripherals(v)) => v,
                _ => panic!(),
            }
        } else {
            ResetPeripherals::new()
        }
    }

    pub fn get_resetPeripherals(&self) -> &ResetPeripherals {
        match self.arg {
            ::std::option::Option::Some(ClientToRobotBroadcast_oneof_arg::resetPeripherals(ref v)) => v,
            _ => ResetPeripherals::default_instance(),
        }
    }
}

impl ::protobuf::Message for ClientToRobotBroadcast {
    fn is_initialized(&self) -> bool {
        if let Some(ClientToRobotBroadcast_oneof_arg::resetPeripherals(ref v)) = self.arg {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.arg = ::std::option::Option::Some(ClientToRobotBroadcast_oneof_arg::resetPeripherals(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.arg {
            match v {
                &ClientToRobotBroadcast_oneof_arg::resetPeripherals(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.arg {
            match v {
                &ClientToRobotBroadcast_oneof_arg::resetPeripherals(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ClientToRobotBroadcast {
    fn new() -> ClientToRobotBroadcast {
        ClientToRobotBroadcast::new()
    }

    fn descriptor_static(_: ::std::option::Option<ClientToRobotBroadcast>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ResetPeripherals>(
                    "resetPeripherals",
                    ClientToRobotBroadcast::has_resetPeripherals,
                    ClientToRobotBroadcast::get_resetPeripherals,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ClientToRobotBroadcast>(
                    "ClientToRobotBroadcast",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ClientToRobotBroadcast {
    fn clear(&mut self) {
        self.clear_resetPeripherals();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ClientToRobotBroadcast {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClientToRobotBroadcast {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RobotToClient {
    // message oneof groups
    arg: ::std::option::Option<RobotToClient_oneof_arg>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for RobotToClient {}

#[derive(Clone,PartialEq)]
pub enum RobotToClient_oneof_arg {
    rpcReply(RpcReply),
    accelerometerEvent(AccelerometerEvent),
    buttonEvent(ButtonEvent),
    encoderEvent(EncoderEvent),
    jointEvent(JointEvent),
    debugMessageEvent(DebugMessageEvent),
    connectEvent(ConnectEvent),
    disconnectEvent(DisconnectEvent),
}

impl RobotToClient {
    pub fn new() -> RobotToClient {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static RobotToClient {
        static mut instance: ::protobuf::lazy::Lazy<RobotToClient> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RobotToClient,
        };
        unsafe {
            instance.get(RobotToClient::new)
        }
    }

    // optional .linkbot.robot.RpcReply rpcReply = 1;

    pub fn clear_rpcReply(&mut self) {
        self.arg = ::std::option::Option::None;
    }

    pub fn has_rpcReply(&self) -> bool {
        match self.arg {
            ::std::option::Option::Some(RobotToClient_oneof_arg::rpcReply(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_rpcReply(&mut self, v: RpcReply) {
        self.arg = ::std::option::Option::Some(RobotToClient_oneof_arg::rpcReply(v))
    }

    // Mutable pointer to the field.
    pub fn mut_rpcReply(&mut self) -> &mut RpcReply {
        if let ::std::option::Option::Some(RobotToClient_oneof_arg::rpcReply(_)) = self.arg {
        } else {
            self.arg = ::std::option::Option::Some(RobotToClient_oneof_arg::rpcReply(RpcReply::new()));
        }
        match self.arg {
            ::std::option::Option::Some(RobotToClient_oneof_arg::rpcReply(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_rpcReply(&mut self) -> RpcReply {
        if self.has_rpcReply() {
            match self.arg.take() {
                ::std::option::Option::Some(RobotToClient_oneof_arg::rpcReply(v)) => v,
                _ => panic!(),
            }
        } else {
            RpcReply::new()
        }
    }

    pub fn get_rpcReply(&self) -> &RpcReply {
        match self.arg {
            ::std::option::Option::Some(RobotToClient_oneof_arg::rpcReply(ref v)) => v,
            _ => RpcReply::default_instance(),
        }
    }

    // optional .linkbot.robot.AccelerometerEvent accelerometerEvent = 2;

    pub fn clear_accelerometerEvent(&mut self) {
        self.arg = ::std::option::Option::None;
    }

    pub fn has_accelerometerEvent(&self) -> bool {
        match self.arg {
            ::std::option::Option::Some(RobotToClient_oneof_arg::accelerometerEvent(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_accelerometerEvent(&mut self, v: AccelerometerEvent) {
        self.arg = ::std::option::Option::Some(RobotToClient_oneof_arg::accelerometerEvent(v))
    }

    // Mutable pointer to the field.
    pub fn mut_accelerometerEvent(&mut self) -> &mut AccelerometerEvent {
        if let ::std::option::Option::Some(RobotToClient_oneof_arg::accelerometerEvent(_)) = self.arg {
        } else {
            self.arg = ::std::option::Option::Some(RobotToClient_oneof_arg::accelerometerEvent(AccelerometerEvent::new()));
        }
        match self.arg {
            ::std::option::Option::Some(RobotToClient_oneof_arg::accelerometerEvent(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_accelerometerEvent(&mut self) -> AccelerometerEvent {
        if self.has_accelerometerEvent() {
            match self.arg.take() {
                ::std::option::Option::Some(RobotToClient_oneof_arg::accelerometerEvent(v)) => v,
                _ => panic!(),
            }
        } else {
            AccelerometerEvent::new()
        }
    }

    pub fn get_accelerometerEvent(&self) -> &AccelerometerEvent {
        match self.arg {
            ::std::option::Option::Some(RobotToClient_oneof_arg::accelerometerEvent(ref v)) => v,
            _ => AccelerometerEvent::default_instance(),
        }
    }

    // optional .linkbot.robot.ButtonEvent buttonEvent = 3;

    pub fn clear_buttonEvent(&mut self) {
        self.arg = ::std::option::Option::None;
    }

    pub fn has_buttonEvent(&self) -> bool {
        match self.arg {
            ::std::option::Option::Some(RobotToClient_oneof_arg::buttonEvent(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_buttonEvent(&mut self, v: ButtonEvent) {
        self.arg = ::std::option::Option::Some(RobotToClient_oneof_arg::buttonEvent(v))
    }

    // Mutable pointer to the field.
    pub fn mut_buttonEvent(&mut self) -> &mut ButtonEvent {
        if let ::std::option::Option::Some(RobotToClient_oneof_arg::buttonEvent(_)) = self.arg {
        } else {
            self.arg = ::std::option::Option::Some(RobotToClient_oneof_arg::buttonEvent(ButtonEvent::new()));
        }
        match self.arg {
            ::std::option::Option::Some(RobotToClient_oneof_arg::buttonEvent(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_buttonEvent(&mut self) -> ButtonEvent {
        if self.has_buttonEvent() {
            match self.arg.take() {
                ::std::option::Option::Some(RobotToClient_oneof_arg::buttonEvent(v)) => v,
                _ => panic!(),
            }
        } else {
            ButtonEvent::new()
        }
    }

    pub fn get_buttonEvent(&self) -> &ButtonEvent {
        match self.arg {
            ::std::option::Option::Some(RobotToClient_oneof_arg::buttonEvent(ref v)) => v,
            _ => ButtonEvent::default_instance(),
        }
    }

    // optional .linkbot.robot.EncoderEvent encoderEvent = 4;

    pub fn clear_encoderEvent(&mut self) {
        self.arg = ::std::option::Option::None;
    }

    pub fn has_encoderEvent(&self) -> bool {
        match self.arg {
            ::std::option::Option::Some(RobotToClient_oneof_arg::encoderEvent(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_encoderEvent(&mut self, v: EncoderEvent) {
        self.arg = ::std::option::Option::Some(RobotToClient_oneof_arg::encoderEvent(v))
    }

    // Mutable pointer to the field.
    pub fn mut_encoderEvent(&mut self) -> &mut EncoderEvent {
        if let ::std::option::Option::Some(RobotToClient_oneof_arg::encoderEvent(_)) = self.arg {
        } else {
            self.arg = ::std::option::Option::Some(RobotToClient_oneof_arg::encoderEvent(EncoderEvent::new()));
        }
        match self.arg {
            ::std::option::Option::Some(RobotToClient_oneof_arg::encoderEvent(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_encoderEvent(&mut self) -> EncoderEvent {
        if self.has_encoderEvent() {
            match self.arg.take() {
                ::std::option::Option::Some(RobotToClient_oneof_arg::encoderEvent(v)) => v,
                _ => panic!(),
            }
        } else {
            EncoderEvent::new()
        }
    }

    pub fn get_encoderEvent(&self) -> &EncoderEvent {
        match self.arg {
            ::std::option::Option::Some(RobotToClient_oneof_arg::encoderEvent(ref v)) => v,
            _ => EncoderEvent::default_instance(),
        }
    }

    // optional .linkbot.robot.JointEvent jointEvent = 5;

    pub fn clear_jointEvent(&mut self) {
        self.arg = ::std::option::Option::None;
    }

    pub fn has_jointEvent(&self) -> bool {
        match self.arg {
            ::std::option::Option::Some(RobotToClient_oneof_arg::jointEvent(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_jointEvent(&mut self, v: JointEvent) {
        self.arg = ::std::option::Option::Some(RobotToClient_oneof_arg::jointEvent(v))
    }

    // Mutable pointer to the field.
    pub fn mut_jointEvent(&mut self) -> &mut JointEvent {
        if let ::std::option::Option::Some(RobotToClient_oneof_arg::jointEvent(_)) = self.arg {
        } else {
            self.arg = ::std::option::Option::Some(RobotToClient_oneof_arg::jointEvent(JointEvent::new()));
        }
        match self.arg {
            ::std::option::Option::Some(RobotToClient_oneof_arg::jointEvent(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_jointEvent(&mut self) -> JointEvent {
        if self.has_jointEvent() {
            match self.arg.take() {
                ::std::option::Option::Some(RobotToClient_oneof_arg::jointEvent(v)) => v,
                _ => panic!(),
            }
        } else {
            JointEvent::new()
        }
    }

    pub fn get_jointEvent(&self) -> &JointEvent {
        match self.arg {
            ::std::option::Option::Some(RobotToClient_oneof_arg::jointEvent(ref v)) => v,
            _ => JointEvent::default_instance(),
        }
    }

    // optional .linkbot.robot.DebugMessageEvent debugMessageEvent = 6;

    pub fn clear_debugMessageEvent(&mut self) {
        self.arg = ::std::option::Option::None;
    }

    pub fn has_debugMessageEvent(&self) -> bool {
        match self.arg {
            ::std::option::Option::Some(RobotToClient_oneof_arg::debugMessageEvent(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_debugMessageEvent(&mut self, v: DebugMessageEvent) {
        self.arg = ::std::option::Option::Some(RobotToClient_oneof_arg::debugMessageEvent(v))
    }

    // Mutable pointer to the field.
    pub fn mut_debugMessageEvent(&mut self) -> &mut DebugMessageEvent {
        if let ::std::option::Option::Some(RobotToClient_oneof_arg::debugMessageEvent(_)) = self.arg {
        } else {
            self.arg = ::std::option::Option::Some(RobotToClient_oneof_arg::debugMessageEvent(DebugMessageEvent::new()));
        }
        match self.arg {
            ::std::option::Option::Some(RobotToClient_oneof_arg::debugMessageEvent(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_debugMessageEvent(&mut self) -> DebugMessageEvent {
        if self.has_debugMessageEvent() {
            match self.arg.take() {
                ::std::option::Option::Some(RobotToClient_oneof_arg::debugMessageEvent(v)) => v,
                _ => panic!(),
            }
        } else {
            DebugMessageEvent::new()
        }
    }

    pub fn get_debugMessageEvent(&self) -> &DebugMessageEvent {
        match self.arg {
            ::std::option::Option::Some(RobotToClient_oneof_arg::debugMessageEvent(ref v)) => v,
            _ => DebugMessageEvent::default_instance(),
        }
    }

    // optional .linkbot.robot.ConnectEvent connectEvent = 7;

    pub fn clear_connectEvent(&mut self) {
        self.arg = ::std::option::Option::None;
    }

    pub fn has_connectEvent(&self) -> bool {
        match self.arg {
            ::std::option::Option::Some(RobotToClient_oneof_arg::connectEvent(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_connectEvent(&mut self, v: ConnectEvent) {
        self.arg = ::std::option::Option::Some(RobotToClient_oneof_arg::connectEvent(v))
    }

    // Mutable pointer to the field.
    pub fn mut_connectEvent(&mut self) -> &mut ConnectEvent {
        if let ::std::option::Option::Some(RobotToClient_oneof_arg::connectEvent(_)) = self.arg {
        } else {
            self.arg = ::std::option::Option::Some(RobotToClient_oneof_arg::connectEvent(ConnectEvent::new()));
        }
        match self.arg {
            ::std::option::Option::Some(RobotToClient_oneof_arg::connectEvent(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_connectEvent(&mut self) -> ConnectEvent {
        if self.has_connectEvent() {
            match self.arg.take() {
                ::std::option::Option::Some(RobotToClient_oneof_arg::connectEvent(v)) => v,
                _ => panic!(),
            }
        } else {
            ConnectEvent::new()
        }
    }

    pub fn get_connectEvent(&self) -> &ConnectEvent {
        match self.arg {
            ::std::option::Option::Some(RobotToClient_oneof_arg::connectEvent(ref v)) => v,
            _ => ConnectEvent::default_instance(),
        }
    }

    // optional .linkbot.robot.DisconnectEvent disconnectEvent = 8;

    pub fn clear_disconnectEvent(&mut self) {
        self.arg = ::std::option::Option::None;
    }

    pub fn has_disconnectEvent(&self) -> bool {
        match self.arg {
            ::std::option::Option::Some(RobotToClient_oneof_arg::disconnectEvent(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_disconnectEvent(&mut self, v: DisconnectEvent) {
        self.arg = ::std::option::Option::Some(RobotToClient_oneof_arg::disconnectEvent(v))
    }

    // Mutable pointer to the field.
    pub fn mut_disconnectEvent(&mut self) -> &mut DisconnectEvent {
        if let ::std::option::Option::Some(RobotToClient_oneof_arg::disconnectEvent(_)) = self.arg {
        } else {
            self.arg = ::std::option::Option::Some(RobotToClient_oneof_arg::disconnectEvent(DisconnectEvent::new()));
        }
        match self.arg {
            ::std::option::Option::Some(RobotToClient_oneof_arg::disconnectEvent(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_disconnectEvent(&mut self) -> DisconnectEvent {
        if self.has_disconnectEvent() {
            match self.arg.take() {
                ::std::option::Option::Some(RobotToClient_oneof_arg::disconnectEvent(v)) => v,
                _ => panic!(),
            }
        } else {
            DisconnectEvent::new()
        }
    }

    pub fn get_disconnectEvent(&self) -> &DisconnectEvent {
        match self.arg {
            ::std::option::Option::Some(RobotToClient_oneof_arg::disconnectEvent(ref v)) => v,
            _ => DisconnectEvent::default_instance(),
        }
    }
}

impl ::protobuf::Message for RobotToClient {
    fn is_initialized(&self) -> bool {
        if let Some(RobotToClient_oneof_arg::rpcReply(ref v)) = self.arg {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RobotToClient_oneof_arg::accelerometerEvent(ref v)) = self.arg {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RobotToClient_oneof_arg::buttonEvent(ref v)) = self.arg {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RobotToClient_oneof_arg::encoderEvent(ref v)) = self.arg {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RobotToClient_oneof_arg::jointEvent(ref v)) = self.arg {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RobotToClient_oneof_arg::debugMessageEvent(ref v)) = self.arg {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RobotToClient_oneof_arg::connectEvent(ref v)) = self.arg {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RobotToClient_oneof_arg::disconnectEvent(ref v)) = self.arg {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.arg = ::std::option::Option::Some(RobotToClient_oneof_arg::rpcReply(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.arg = ::std::option::Option::Some(RobotToClient_oneof_arg::accelerometerEvent(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.arg = ::std::option::Option::Some(RobotToClient_oneof_arg::buttonEvent(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.arg = ::std::option::Option::Some(RobotToClient_oneof_arg::encoderEvent(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.arg = ::std::option::Option::Some(RobotToClient_oneof_arg::jointEvent(is.read_message()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.arg = ::std::option::Option::Some(RobotToClient_oneof_arg::debugMessageEvent(is.read_message()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.arg = ::std::option::Option::Some(RobotToClient_oneof_arg::connectEvent(is.read_message()?));
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.arg = ::std::option::Option::Some(RobotToClient_oneof_arg::disconnectEvent(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.arg {
            match v {
                &RobotToClient_oneof_arg::rpcReply(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RobotToClient_oneof_arg::accelerometerEvent(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RobotToClient_oneof_arg::buttonEvent(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RobotToClient_oneof_arg::encoderEvent(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RobotToClient_oneof_arg::jointEvent(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RobotToClient_oneof_arg::debugMessageEvent(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RobotToClient_oneof_arg::connectEvent(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RobotToClient_oneof_arg::disconnectEvent(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.arg {
            match v {
                &RobotToClient_oneof_arg::rpcReply(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RobotToClient_oneof_arg::accelerometerEvent(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RobotToClient_oneof_arg::buttonEvent(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RobotToClient_oneof_arg::encoderEvent(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RobotToClient_oneof_arg::jointEvent(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RobotToClient_oneof_arg::debugMessageEvent(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RobotToClient_oneof_arg::connectEvent(ref v) => {
                    os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RobotToClient_oneof_arg::disconnectEvent(ref v) => {
                    os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for RobotToClient {
    fn new() -> RobotToClient {
        RobotToClient::new()
    }

    fn descriptor_static(_: ::std::option::Option<RobotToClient>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RpcReply>(
                    "rpcReply",
                    RobotToClient::has_rpcReply,
                    RobotToClient::get_rpcReply,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, AccelerometerEvent>(
                    "accelerometerEvent",
                    RobotToClient::has_accelerometerEvent,
                    RobotToClient::get_accelerometerEvent,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ButtonEvent>(
                    "buttonEvent",
                    RobotToClient::has_buttonEvent,
                    RobotToClient::get_buttonEvent,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, EncoderEvent>(
                    "encoderEvent",
                    RobotToClient::has_encoderEvent,
                    RobotToClient::get_encoderEvent,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, JointEvent>(
                    "jointEvent",
                    RobotToClient::has_jointEvent,
                    RobotToClient::get_jointEvent,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, DebugMessageEvent>(
                    "debugMessageEvent",
                    RobotToClient::has_debugMessageEvent,
                    RobotToClient::get_debugMessageEvent,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ConnectEvent>(
                    "connectEvent",
                    RobotToClient::has_connectEvent,
                    RobotToClient::get_connectEvent,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, DisconnectEvent>(
                    "disconnectEvent",
                    RobotToClient::has_disconnectEvent,
                    RobotToClient::get_disconnectEvent,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RobotToClient>(
                    "RobotToClient",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for RobotToClient {
    fn clear(&mut self) {
        self.clear_rpcReply();
        self.clear_accelerometerEvent();
        self.clear_buttonEvent();
        self.clear_encoderEvent();
        self.clear_jointEvent();
        self.clear_debugMessageEvent();
        self.clear_connectEvent();
        self.clear_disconnectEvent();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RobotToClient {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RobotToClient {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum FormFactor {
    I = 0,
    L = 1,
    T = 2,
    DONGLE = 3,
}

impl ::protobuf::ProtobufEnum for FormFactor {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<FormFactor> {
        match value {
            0 => ::std::option::Option::Some(FormFactor::I),
            1 => ::std::option::Option::Some(FormFactor::L),
            2 => ::std::option::Option::Some(FormFactor::T),
            3 => ::std::option::Option::Some(FormFactor::DONGLE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [FormFactor] = &[
            FormFactor::I,
            FormFactor::L,
            FormFactor::T,
            FormFactor::DONGLE,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<FormFactor>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("FormFactor", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for FormFactor {
}

impl ::protobuf::reflect::ProtobufValue for FormFactor {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum JointState {
    COAST = 0,
    HOLD = 1,
    MOVING = 2,
    ERROR = 4,
}

impl ::protobuf::ProtobufEnum for JointState {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<JointState> {
        match value {
            0 => ::std::option::Option::Some(JointState::COAST),
            1 => ::std::option::Option::Some(JointState::HOLD),
            2 => ::std::option::Option::Some(JointState::MOVING),
            4 => ::std::option::Option::Some(JointState::ERROR),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [JointState] = &[
            JointState::COAST,
            JointState::HOLD,
            JointState::MOVING,
            JointState::ERROR,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<JointState>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("JointState", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for JointState {
}

impl ::protobuf::reflect::ProtobufValue for JointState {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Button {
    POWER = 0,
    A = 1,
    B = 2,
}

impl ::protobuf::ProtobufEnum for Button {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Button> {
        match value {
            0 => ::std::option::Option::Some(Button::POWER),
            1 => ::std::option::Option::Some(Button::A),
            2 => ::std::option::Option::Some(Button::B),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Button] = &[
            Button::POWER,
            Button::A,
            Button::B,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<Button>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Button", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Button {
}

impl ::protobuf::reflect::ProtobufValue for Button {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ButtonState {
    UP = 0,
    DOWN = 1,
}

impl ::protobuf::ProtobufEnum for ButtonState {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ButtonState> {
        match value {
            0 => ::std::option::Option::Some(ButtonState::UP),
            1 => ::std::option::Option::Some(ButtonState::DOWN),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ButtonState] = &[
            ButtonState::UP,
            ButtonState::DOWN,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<ButtonState>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ButtonState", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ButtonState {
}

impl ::protobuf::reflect::ProtobufValue for ButtonState {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Peripheral {
    MOTOR1 = 0,
    MOTOR2 = 1,
    MOTOR3 = 2,
    LED = 3,
    BUZZER = 4,
}

impl ::protobuf::ProtobufEnum for Peripheral {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Peripheral> {
        match value {
            0 => ::std::option::Option::Some(Peripheral::MOTOR1),
            1 => ::std::option::Option::Some(Peripheral::MOTOR2),
            2 => ::std::option::Option::Some(Peripheral::MOTOR3),
            3 => ::std::option::Option::Some(Peripheral::LED),
            4 => ::std::option::Option::Some(Peripheral::BUZZER),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Peripheral] = &[
            Peripheral::MOTOR1,
            Peripheral::MOTOR2,
            Peripheral::MOTOR3,
            Peripheral::LED,
            Peripheral::BUZZER,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<Peripheral>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Peripheral", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Peripheral {
}

impl ::protobuf::reflect::ProtobufValue for Peripheral {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0brobot.proto\x12\rlinkbot.robot\x1a\x0cnanopb.proto\"M\n\x14getAcce\
    lerometerData\x1a\x04\n\x02In\x1a/\n\x03Out\x12\x0c\n\x01x\x18\x01\x20\
    \x01(\x02R\x01x\x12\x0c\n\x01y\x18\x02\x20\x01(\x02R\x01y\x12\x0c\n\x01z\
    \x18\x03\x20\x01(\x02R\x01z\".\n\x11getBatteryVoltage\x1a\x04\n\x02In\
    \x1a\x13\n\x03Out\x12\x0c\n\x01v\x18\x01\x20\x01(\x02R\x01v\"9\n\tgetAdc\
    Raw\x1a\x04\n\x02In\x1a&\n\x03Out\x12\x1f\n\x06values\x18\x01\x20\x03(\r\
    R\x06valuesB\x07\x10\x01\x92?\x02\x10\x20\"1\n\x0egetButtonState\x1a\x04\
    \n\x02In\x1a\x19\n\x03Out\x12\x12\n\x04mask\x18\x01\x20\x01(\rR\x04mask\
    \"7\n\x12getBuzzerFrequency\x1a\x04\n\x02In\x1a\x1b\n\x03Out\x12\x14\n\
    \x05value\x18\x01\x20\x01(\x02R\x05value\"^\n\x10getEncoderValues\x1a\
    \x04\n\x02In\x1aD\n\x03Out\x12\x1c\n\ttimestamp\x18\x01\x20\x01(\rR\ttim\
    estamp\x12\x1f\n\x06values\x18\x02\x20\x03(\x02R\x06valuesB\x07\x10\x01\
    \x92?\x02\x10\x20\"E\n\x18getFirmwareVersionString\x1a\x04\n\x02In\x1a#\
    \n\x03Out\x12\x1c\n\x05value\x18\x01\x20\x01(\tR\x05valueB\x06\x92?\x03\
    \x08\x80\x01\"M\n\rgetFormFactor\x1a\x04\n\x02In\x1a6\n\x03Out\x12/\n\
    \x05value\x18\x01\x20\x01(\x0e2\x19.linkbot.robot.FormFactorR\x05value\"\
    w\n\x0egetJointStates\x1a\x04\n\x02In\x1a_\n\x03Out\x12\x1c\n\ttimestamp\
    \x18\x01\x20\x01(\rR\ttimestamp\x12:\n\x06values\x18\x02\x20\x03(\x0e2\
    \x19.linkbot.robot.JointStateR\x06valuesB\x07\x10\x01\x92?\x02\x10\x20\"\
    0\n\x0bgetLedColor\x1a\x04\n\x02In\x1a\x1b\n\x03Out\x12\x14\n\x05value\
    \x18\x01\x20\x01(\rR\x05value\"G\n\x17getMotorControllerOmega\x1a\x04\n\
    \x02In\x1a&\n\x03Out\x12\x1f\n\x06values\x18\x01\x20\x03(\x02R\x06values\
    B\x07\x10\x01\x92?\x02\x10\x20\"H\n\x18getMotorControllerAlphaI\x1a\x04\
    \n\x02In\x1a&\n\x03Out\x12\x1f\n\x06values\x18\x01\x20\x03(\x02R\x06valu\
    esB\x07\x10\x01\x92?\x02\x10\x20\"H\n\x18getMotorControllerAlphaF\x1a\
    \x04\n\x02In\x1a&\n\x03Out\x12\x1f\n\x06values\x18\x01\x20\x03(\x02R\x06\
    valuesB\x07\x10\x01\x92?\x02\x10\x20\"R\n\"getMotorControllerProportiona\
    lGain\x1a\x04\n\x02In\x1a&\n\x03Out\x12\x1f\n\x06values\x18\x01\x20\x03(\
    \x02R\x06valuesB\x07\x10\x01\x92?\x02\x10\x20\"P\n\x20getMotorController\
    IntegratorGain\x1a\x04\n\x02In\x1a&\n\x03Out\x12\x1f\n\x06values\x18\x01\
    \x20\x03(\x02R\x06valuesB\x07\x10\x01\x92?\x02\x10\x20\"P\n\x20getMotorC\
    ontrollerDerivativeGain\x1a\x04\n\x02In\x1a&\n\x03Out\x12\x1f\n\x06value\
    s\x18\x01\x20\x03(\x02R\x06valuesB\x07\x10\x01\x92?\x02\x10\x20\"Q\n!get\
    MotorControllerSafetyThreshold\x1a\x04\n\x02In\x1a&\n\x03Out\x12\x1f\n\
    \x06values\x18\x01\x20\x03(\rR\x06valuesB\x07\x10\x01\x92?\x02\x10\x20\"\
    M\n\x1dgetMotorControllerSafetyAngle\x1a\x04\n\x02In\x1a&\n\x03Out\x12\
    \x1f\n\x06values\x18\x01\x20\x03(\x02R\x06valuesB\x07\x10\x01\x92?\x02\
    \x10\x20\"[\n\x17setMotorControllerOmega\x1a9\n\x02In\x12\x12\n\x04mask\
    \x18\x01\x20\x01(\rR\x04mask\x12\x1f\n\x06values\x18\x02\x20\x03(\x02R\
    \x06valuesB\x07\x10\x01\x92?\x02\x10\x20\x1a\x05\n\x03Out\"\\\n\x18setMo\
    torControllerAlphaI\x1a9\n\x02In\x12\x12\n\x04mask\x18\x01\x20\x01(\rR\
    \x04mask\x12\x1f\n\x06values\x18\x02\x20\x03(\x02R\x06valuesB\x07\x10\
    \x01\x92?\x02\x10\x20\x1a\x05\n\x03Out\"\\\n\x18setMotorControllerAlphaF\
    \x1a9\n\x02In\x12\x12\n\x04mask\x18\x01\x20\x01(\rR\x04mask\x12\x1f\n\
    \x06values\x18\x02\x20\x03(\x02R\x06valuesB\x07\x10\x01\x92?\x02\x10\x20\
    \x1a\x05\n\x03Out\"f\n\"setMotorControllerProportionalGain\x1a9\n\x02In\
    \x12\x12\n\x04mask\x18\x01\x20\x01(\rR\x04mask\x12\x1f\n\x06values\x18\
    \x02\x20\x03(\x02R\x06valuesB\x07\x10\x01\x92?\x02\x10\x20\x1a\x05\n\x03\
    Out\"d\n\x20setMotorControllerIntegratorGain\x1a9\n\x02In\x12\x12\n\x04m\
    ask\x18\x01\x20\x01(\rR\x04mask\x12\x1f\n\x06values\x18\x02\x20\x03(\x02\
    R\x06valuesB\x07\x10\x01\x92?\x02\x10\x20\x1a\x05\n\x03Out\"d\n\x20setMo\
    torControllerDerivativeGain\x1a9\n\x02In\x12\x12\n\x04mask\x18\x01\x20\
    \x01(\rR\x04mask\x12\x1f\n\x06values\x18\x02\x20\x03(\x02R\x06valuesB\
    \x07\x10\x01\x92?\x02\x10\x20\x1a\x05\n\x03Out\"e\n!setMotorControllerSa\
    fetyThreshold\x1a9\n\x02In\x12\x12\n\x04mask\x18\x01\x20\x01(\rR\x04mask\
    \x12\x1f\n\x06values\x18\x02\x20\x03(\rR\x06valuesB\x07\x10\x01\x92?\x02\
    \x10\x20\x1a\x05\n\x03Out\"a\n\x1dsetMotorControllerSafetyAngle\x1a9\n\
    \x02In\x12\x12\n\x04mask\x18\x01\x20\x01(\rR\x04mask\x12\x1f\n\x06values\
    \x18\x02\x20\x03(\x02R\x06valuesB\x07\x10\x01\x92?\x02\x10\x20\x1a\x05\n\
    \x03Out\"i\n\x14setResetOnDisconnect\x1aJ\n\x02In\x12\x12\n\x04mask\x18\
    \x01\x20\x01(\rR\x04mask\x120\n\x13peripheralResetMask\x18\x02\x20\x01(\
    \rR\x13peripheralResetMask\x1a\x05\n\x03Out\"\x1f\n\x10resetEncoderRevs\
    \x1a\x04\n\x02In\x1a\x05\n\x03Out\"7\n\x12setBuzzerFrequency\x1a\x1a\n\
    \x02In\x12\x14\n\x05value\x18\x01\x20\x01(\x02R\x05value\x1a\x05\n\x03Ou\
    t\"0\n\x0bsetLedColor\x1a\x1a\n\x02In\x12\x14\n\x05value\x18\x01\x20\x01\
    (\rR\x05value\x1a\x05\n\x03Out\"'\n\x04stop\x1a\x18\n\x02In\x12\x12\n\
    \x04mask\x18\x01\x20\x01(\rR\x04mask\x1a\x05\n\x03Out\"\xee\x02\n\x04Goa\
    l\x12,\n\x04type\x18\x01\x20\x01(\x0e2\x18.linkbot.robot.Goal.TypeR\x04t\
    ype\x12\x12\n\x04goal\x18\x02\x20\x01(\x02R\x04goal\x12>\n\ncontroller\
    \x18\x03\x20\x01(\x0e2\x1e.linkbot.robot.Goal.ControllerR\ncontroller\
    \x12\x18\n\x07timeout\x18\x04\x20\x01(\x02R\x07timeout\x12?\n\rmodeOnTim\
    eout\x18\x05\x20\x01(\x0e2\x19.linkbot.robot.JointStateR\rmodeOnTimeout\
    \"0\n\x04Type\x12\x0c\n\x08ABSOLUTE\x10\x01\x12\x0c\n\x08RELATIVE\x10\
    \x02\x12\x0c\n\x08INFINITE\x10\x03\"W\n\nController\x12\x07\n\x03PID\x10\
    \x01\x12\x0c\n\x08CONSTVEL\x10\x02\x12\n\n\x06SMOOTH\x10\x03\x12\t\n\x05\
    ACCEL\x10\x04\x12\r\n\tCYCLOIDAL\x10\x05\x12\x0c\n\x08HARMONIC\x10\x06\"\
    \xc8\x01\n\trobotMove\x1a\xb3\x01\n\x02In\x127\n\x0cmotorOneGoal\x18\x01\
    \x20\x01(\x0b2\x13.linkbot.robot.GoalR\x0cmotorOneGoal\x127\n\x0cmotorTw\
    oGoal\x18\x02\x20\x01(\x0b2\x13.linkbot.robot.GoalR\x0cmotorTwoGoal\x12;\
    \n\x0emotorThreeGoal\x18\x03\x20\x01(\x0b2\x13.linkbot.robot.GoalR\x0emo\
    torThreeGoal\x1a\x05\n\x03Out\"a\n\x18enableAccelerometerEvent\x1a>\n\
    \x02In\x12\x16\n\x06enable\x18\x01\x20\x01(\x08R\x06enable\x12\x20\n\x0b\
    granularity\x18\x02\x20\x01(\x02R\x0bgranularity\x1a\x05\n\x03Out\"8\n\
    \x11enableButtonEvent\x1a\x1c\n\x02In\x12\x16\n\x06enable\x18\x01\x20\
    \x01(\x08R\x06enable\x1a\x05\n\x03Out\"\xe5\x02\n\x12enableEncoderEvent\
    \x1a\xc7\x02\n\x02In\x12P\n\nencoderOne\x18\x01\x20\x01(\x0b20.linkbot.r\
    obot.enableEncoderEvent.In.SignalStateR\nencoderOne\x12P\n\nencoderTwo\
    \x18\x02\x20\x01(\x0b20.linkbot.robot.enableEncoderEvent.In.SignalStateR\
    \nencoderTwo\x12T\n\x0cencoderThree\x18\x03\x20\x01(\x0b20.linkbot.robot\
    .enableEncoderEvent.In.SignalStateR\x0cencoderThree\x1aG\n\x0bSignalStat\
    e\x12\x16\n\x06enable\x18\x01\x20\x01(\x08R\x06enable\x12\x20\n\x0bgranu\
    larity\x18\x02\x20\x01(\x02R\x0bgranularity\x1a\x05\n\x03Out\"7\n\x10ena\
    bleJointEvent\x1a\x1c\n\x02In\x12\x16\n\x06enable\x18\x01\x20\x01(\x08R\
    \x06enable\x1a\x05\n\x03Out\"P\n\x0bwriteEeprom\x1a:\n\x02In\x12\x18\n\
    \x07address\x18\x01\x20\x01(\rR\x07address\x12\x1a\n\x04data\x18\x02\x20\
    \x01(\x0cR\x04dataB\x06\x92?\x03\x08\x80\x01\x1a\x05\n\x03Out\"c\n\nread\
    Eeprom\x1a2\n\x02In\x12\x18\n\x07address\x18\x01\x20\x01(\rR\x07address\
    \x12\x12\n\x04size\x18\x02\x20\x01(\rR\x04size\x1a!\n\x03Out\x12\x1a\n\
    \x04data\x18\x01\x20\x01(\x0cR\x04dataB\x06\x92?\x03\x08\x80\x01\"M\n\
    \x08writeTwi\x1a:\n\x02In\x12\x18\n\x07address\x18\x01\x20\x01(\rR\x07ad\
    dress\x12\x1a\n\x04data\x18\x02\x20\x01(\x0cR\x04dataB\x06\x92?\x03\x08\
    \x80\x01\x1a\x05\n\x03Out\"h\n\x07readTwi\x1a:\n\x02In\x12\x18\n\x07addr\
    ess\x18\x01\x20\x01(\rR\x07address\x12\x1a\n\x08recvsize\x18\x02\x20\x01\
    (\rR\x08recvsize\x1a!\n\x03Out\x12\x1a\n\x04data\x18\x02\x20\x01(\x0cR\
    \x04dataB\x06\x92?\x03\x08\x80\x01\"\x89\x01\n\x0cwriteReadTwi\x1aV\n\
    \x02In\x12\x18\n\x07address\x18\x01\x20\x01(\rR\x07address\x12\x1a\n\x08\
    recvsize\x18\x02\x20\x01(\rR\x08recvsize\x12\x1a\n\x04data\x18\x03\x20\
    \x01(\x0cR\x04dataB\x06\x92?\x03\x08\x80\x01\x1a!\n\x03Out\x12\x1a\n\x04\
    data\x18\x02\x20\x01(\x0cR\x04dataB\x06\x92?\x03\x08\x80\x01\"\x15\n\x06\
    reboot\x1a\x04\n\x02In\x1a\x05\n\x03Out\"\xf8\x1e\n\nRpcRequest\x12\x1c\
    \n\trequestId\x18\x01\x20\x01(\rR\trequestId\x12h\n\x18getFirmwareVersio\
    nString\x18\x10\x20\x01(\x0b2*.linkbot.robot.getFirmwareVersionString.In\
    H\0R\x18getFirmwareVersionString\x12G\n\rgetFormFactor\x18\x11\x20\x01(\
    \x0b2\x1f.linkbot.robot.getFormFactor.InH\0R\rgetFormFactor\x12;\n\tgetA\
    dcRaw\x18\x12\x20\x01(\x0b2\x1b.linkbot.robot.getAdcRaw.InH\0R\tgetAdcRa\
    w\x12S\n\x11getBatteryVoltage\x18\x13\x20\x01(\x0b2#.linkbot.robot.getBa\
    tteryVoltage.InH\0R\x11getBatteryVoltage\x12\\\n\x14getAccelerometerData\
    \x18\x14\x20\x01(\x0b2&.linkbot.robot.getAccelerometerData.InH\0R\x14get\
    AccelerometerData\x12J\n\x0egetButtonState\x18\x15\x20\x01(\x0b2\x20.lin\
    kbot.robot.getButtonState.InH\0R\x0egetButtonState\x12P\n\x10getEncoderV\
    alues\x18\x16\x20\x01(\x0b2\".linkbot.robot.getEncoderValues.InH\0R\x10g\
    etEncoderValues\x12J\n\x0egetJointStates\x18\x17\x20\x01(\x0b2\x20.linkb\
    ot.robot.getJointStates.InH\0R\x0egetJointStates\x12h\n\x18enableAcceler\
    ometerEvent\x18\x18\x20\x01(\x0b2*.linkbot.robot.enableAccelerometerEven\
    t.InH\0R\x18enableAccelerometerEvent\x12S\n\x11enableButtonEvent\x18\x19\
    \x20\x01(\x0b2#.linkbot.robot.enableButtonEvent.InH\0R\x11enableButtonEv\
    ent\x12V\n\x12enableEncoderEvent\x18\x1a\x20\x01(\x0b2$.linkbot.robot.en\
    ableEncoderEvent.InH\0R\x12enableEncoderEvent\x12P\n\x10enableJointEvent\
    \x18\x1b\x20\x01(\x0b2\".linkbot.robot.enableJointEvent.InH\0R\x10enable\
    JointEvent\x12V\n\x12getBuzzerFrequency\x18\x02\x20\x01(\x0b2$.linkbot.r\
    obot.getBuzzerFrequency.InH\0R\x12getBuzzerFrequency\x12A\n\x0bgetLedCol\
    or\x18\x03\x20\x01(\x0b2\x1d.linkbot.robot.getLedColor.InH\0R\x0bgetLedC\
    olor\x12e\n\x17getMotorControllerOmega\x18\x1c\x20\x01(\x0b2).linkbot.ro\
    bot.getMotorControllerOmega.InH\0R\x17getMotorControllerOmega\x12h\n\x18\
    getMotorControllerAlphaI\x18\x1d\x20\x01(\x0b2*.linkbot.robot.getMotorCo\
    ntrollerAlphaI.InH\0R\x18getMotorControllerAlphaI\x12h\n\x18getMotorCont\
    rollerAlphaF\x18\x1e\x20\x01(\x0b2*.linkbot.robot.getMotorControllerAlph\
    aF.InH\0R\x18getMotorControllerAlphaF\x12\x86\x01\n\"getMotorControllerP\
    roportionalGain\x18\x1f\x20\x01(\x0b24.linkbot.robot.getMotorControllerP\
    roportionalGain.InH\0R\"getMotorControllerProportionalGain\x12\x80\x01\n\
    \x20getMotorControllerIntegratorGain\x18\x20\x20\x01(\x0b22.linkbot.robo\
    t.getMotorControllerIntegratorGain.InH\0R\x20getMotorControllerIntegrato\
    rGain\x12\x80\x01\n\x20getMotorControllerDerivativeGain\x18!\x20\x01(\
    \x0b22.linkbot.robot.getMotorControllerDerivativeGain.InH\0R\x20getMotor\
    ControllerDerivativeGain\x12\x83\x01\n!getMotorControllerSafetyThreshold\
    \x18\"\x20\x01(\x0b23.linkbot.robot.getMotorControllerSafetyThreshold.In\
    H\0R!getMotorControllerSafetyThreshold\x12w\n\x1dgetMotorControllerSafet\
    yAngle\x18#\x20\x01(\x0b2/.linkbot.robot.getMotorControllerSafetyAngle.I\
    nH\0R\x1dgetMotorControllerSafetyAngle\x12V\n\x12setBuzzerFrequency\x18\
    \x04\x20\x01(\x0b2$.linkbot.robot.setBuzzerFrequency.InH\0R\x12setBuzzer\
    Frequency\x12A\n\x0bsetLedColor\x18\x05\x20\x01(\x0b2\x1d.linkbot.robot.\
    setLedColor.InH\0R\x0bsetLedColor\x12e\n\x17setMotorControllerOmega\x18$\
    \x20\x01(\x0b2).linkbot.robot.setMotorControllerOmega.InH\0R\x17setMotor\
    ControllerOmega\x12h\n\x18setMotorControllerAlphaI\x18%\x20\x01(\x0b2*.l\
    inkbot.robot.setMotorControllerAlphaI.InH\0R\x18setMotorControllerAlphaI\
    \x12h\n\x18setMotorControllerAlphaF\x18&\x20\x01(\x0b2*.linkbot.robot.se\
    tMotorControllerAlphaF.InH\0R\x18setMotorControllerAlphaF\x12\x86\x01\n\
    \"setMotorControllerProportionalGain\x18'\x20\x01(\x0b24.linkbot.robot.s\
    etMotorControllerProportionalGain.InH\0R\"setMotorControllerProportional\
    Gain\x12\x80\x01\n\x20setMotorControllerIntegratorGain\x18(\x20\x01(\x0b\
    22.linkbot.robot.setMotorControllerIntegratorGain.InH\0R\x20setMotorCont\
    rollerIntegratorGain\x12\x80\x01\n\x20setMotorControllerDerivativeGain\
    \x18)\x20\x01(\x0b22.linkbot.robot.setMotorControllerDerivativeGain.InH\
    \0R\x20setMotorControllerDerivativeGain\x12\x83\x01\n!setMotorController\
    SafetyThreshold\x18*\x20\x01(\x0b23.linkbot.robot.setMotorControllerSafe\
    tyThreshold.InH\0R!setMotorControllerSafetyThreshold\x12w\n\x1dsetMotorC\
    ontrollerSafetyAngle\x18+\x20\x01(\x0b2/.linkbot.robot.setMotorControlle\
    rSafetyAngle.InH\0R\x1dsetMotorControllerSafetyAngle\x12\\\n\x14setReset\
    OnDisconnect\x185\x20\x01(\x0b2&.linkbot.robot.setResetOnDisconnect.InH\
    \0R\x14setResetOnDisconnect\x12P\n\x10resetEncoderRevs\x18,\x20\x01(\x0b\
    2\".linkbot.robot.resetEncoderRevs.InH\0R\x10resetEncoderRevs\x12;\n\tro\
    botMove\x18-\x20\x01(\x0b2\x1b.linkbot.robot.robotMove.InH\0R\trobotMove\
    \x12,\n\x04stop\x18.\x20\x01(\x0b2\x16.linkbot.robot.stop.InH\0R\x04stop\
    \x122\n\x06reboot\x18/\x20\x01(\x0b2\x18.linkbot.robot.reboot.InH\0R\x06\
    reboot\x12A\n\x0bwriteEeprom\x180\x20\x01(\x0b2\x1d.linkbot.robot.writeE\
    eprom.InH\0R\x0bwriteEeprom\x12>\n\nreadEeprom\x181\x20\x01(\x0b2\x1c.li\
    nkbot.robot.readEeprom.InH\0R\nreadEeprom\x128\n\x08writeTwi\x182\x20\
    \x01(\x0b2\x1a.linkbot.robot.writeTwi.InH\0R\x08writeTwi\x125\n\x07readT\
    wi\x183\x20\x01(\x0b2\x19.linkbot.robot.readTwi.InH\0R\x07readTwi\x12D\n\
    \x0cwriteReadTwi\x184\x20\x01(\x0b2\x1e.linkbot.robot.writeReadTwi.InH\0\
    R\x0cwriteReadTwiB\x05\n\x03arg\"\xa0\x1f\n\x08RpcReply\x12\x1c\n\treque\
    stId\x18\x01\x20\x01(\rR\trequestId\x12i\n\x18getFirmwareVersionString\
    \x18\x10\x20\x01(\x0b2+.linkbot.robot.getFirmwareVersionString.OutH\0R\
    \x18getFirmwareVersionString\x12H\n\rgetFormFactor\x18\x11\x20\x01(\x0b2\
    \x20.linkbot.robot.getFormFactor.OutH\0R\rgetFormFactor\x12<\n\tgetAdcRa\
    w\x18\x12\x20\x01(\x0b2\x1c.linkbot.robot.getAdcRaw.OutH\0R\tgetAdcRaw\
    \x12T\n\x11getBatteryVoltage\x18\x13\x20\x01(\x0b2$.linkbot.robot.getBat\
    teryVoltage.OutH\0R\x11getBatteryVoltage\x12]\n\x14getAccelerometerData\
    \x18\x14\x20\x01(\x0b2'.linkbot.robot.getAccelerometerData.OutH\0R\x14ge\
    tAccelerometerData\x12K\n\x0egetButtonState\x18\x15\x20\x01(\x0b2!.linkb\
    ot.robot.getButtonState.OutH\0R\x0egetButtonState\x12Q\n\x10getEncoderVa\
    lues\x18\x16\x20\x01(\x0b2#.linkbot.robot.getEncoderValues.OutH\0R\x10ge\
    tEncoderValues\x12K\n\x0egetJointStates\x18\x17\x20\x01(\x0b2!.linkbot.r\
    obot.getJointStates.OutH\0R\x0egetJointStates\x12i\n\x18enableAccelerome\
    terEvent\x18\x18\x20\x01(\x0b2+.linkbot.robot.enableAccelerometerEvent.O\
    utH\0R\x18enableAccelerometerEvent\x12T\n\x11enableButtonEvent\x18\x19\
    \x20\x01(\x0b2$.linkbot.robot.enableButtonEvent.OutH\0R\x11enableButtonE\
    vent\x12W\n\x12enableEncoderEvent\x18\x1a\x20\x01(\x0b2%.linkbot.robot.e\
    nableEncoderEvent.OutH\0R\x12enableEncoderEvent\x12Q\n\x10enableJointEve\
    nt\x18\x1b\x20\x01(\x0b2#.linkbot.robot.enableJointEvent.OutH\0R\x10enab\
    leJointEvent\x12W\n\x12getBuzzerFrequency\x18\x02\x20\x01(\x0b2%.linkbot\
    .robot.getBuzzerFrequency.OutH\0R\x12getBuzzerFrequency\x12B\n\x0bgetLed\
    Color\x18\x03\x20\x01(\x0b2\x1e.linkbot.robot.getLedColor.OutH\0R\x0bget\
    LedColor\x12f\n\x17getMotorControllerOmega\x18\x1c\x20\x01(\x0b2*.linkbo\
    t.robot.getMotorControllerOmega.OutH\0R\x17getMotorControllerOmega\x12i\
    \n\x18getMotorControllerAlphaI\x18\x1d\x20\x01(\x0b2+.linkbot.robot.getM\
    otorControllerAlphaI.OutH\0R\x18getMotorControllerAlphaI\x12i\n\x18getMo\
    torControllerAlphaF\x18\x1e\x20\x01(\x0b2+.linkbot.robot.getMotorControl\
    lerAlphaF.OutH\0R\x18getMotorControllerAlphaF\x12\x87\x01\n\"getMotorCon\
    trollerProportionalGain\x18\x1f\x20\x01(\x0b25.linkbot.robot.getMotorCon\
    trollerProportionalGain.OutH\0R\"getMotorControllerProportionalGain\x12\
    \x81\x01\n\x20getMotorControllerIntegratorGain\x18\x20\x20\x01(\x0b23.li\
    nkbot.robot.getMotorControllerIntegratorGain.OutH\0R\x20getMotorControll\
    erIntegratorGain\x12\x81\x01\n\x20getMotorControllerDerivativeGain\x18!\
    \x20\x01(\x0b23.linkbot.robot.getMotorControllerDerivativeGain.OutH\0R\
    \x20getMotorControllerDerivativeGain\x12\x84\x01\n!getMotorControllerSaf\
    etyThreshold\x18\"\x20\x01(\x0b24.linkbot.robot.getMotorControllerSafety\
    Threshold.OutH\0R!getMotorControllerSafetyThreshold\x12x\n\x1dgetMotorCo\
    ntrollerSafetyAngle\x18#\x20\x01(\x0b20.linkbot.robot.getMotorController\
    SafetyAngle.OutH\0R\x1dgetMotorControllerSafetyAngle\x12W\n\x12setBuzzer\
    Frequency\x18\x04\x20\x01(\x0b2%.linkbot.robot.setBuzzerFrequency.OutH\0\
    R\x12setBuzzerFrequency\x12B\n\x0bsetLedColor\x18\x05\x20\x01(\x0b2\x1e.\
    linkbot.robot.setLedColor.OutH\0R\x0bsetLedColor\x12f\n\x17setMotorContr\
    ollerOmega\x18$\x20\x01(\x0b2*.linkbot.robot.setMotorControllerOmega.Out\
    H\0R\x17setMotorControllerOmega\x12i\n\x18setMotorControllerAlphaI\x18%\
    \x20\x01(\x0b2+.linkbot.robot.setMotorControllerAlphaI.OutH\0R\x18setMot\
    orControllerAlphaI\x12i\n\x18setMotorControllerAlphaF\x18&\x20\x01(\x0b2\
    +.linkbot.robot.setMotorControllerAlphaF.OutH\0R\x18setMotorControllerAl\
    phaF\x12\x87\x01\n\"setMotorControllerProportionalGain\x18'\x20\x01(\x0b\
    25.linkbot.robot.setMotorControllerProportionalGain.OutH\0R\"setMotorCon\
    trollerProportionalGain\x12\x81\x01\n\x20setMotorControllerIntegratorGai\
    n\x18(\x20\x01(\x0b23.linkbot.robot.setMotorControllerIntegratorGain.Out\
    H\0R\x20setMotorControllerIntegratorGain\x12\x81\x01\n\x20setMotorContro\
    llerDerivativeGain\x18)\x20\x01(\x0b23.linkbot.robot.setMotorControllerD\
    erivativeGain.OutH\0R\x20setMotorControllerDerivativeGain\x12\x84\x01\n!\
    setMotorControllerSafetyThreshold\x18*\x20\x01(\x0b24.linkbot.robot.setM\
    otorControllerSafetyThreshold.OutH\0R!setMotorControllerSafetyThreshold\
    \x12x\n\x1dsetMotorControllerSafetyAngle\x18+\x20\x01(\x0b20.linkbot.rob\
    ot.setMotorControllerSafetyAngle.OutH\0R\x1dsetMotorControllerSafetyAngl\
    e\x12]\n\x14setResetOnDisconnect\x185\x20\x01(\x0b2'.linkbot.robot.setRe\
    setOnDisconnect.OutH\0R\x14setResetOnDisconnect\x12Q\n\x10resetEncoderRe\
    vs\x18,\x20\x01(\x0b2#.linkbot.robot.resetEncoderRevs.OutH\0R\x10resetEn\
    coderRevs\x12<\n\trobotMove\x18-\x20\x01(\x0b2\x1c.linkbot.robot.robotMo\
    ve.OutH\0R\trobotMove\x12-\n\x04stop\x18.\x20\x01(\x0b2\x17.linkbot.robo\
    t.stop.OutH\0R\x04stop\x123\n\x06reboot\x18/\x20\x01(\x0b2\x19.linkbot.r\
    obot.reboot.OutH\0R\x06reboot\x12B\n\x0bwriteEeprom\x180\x20\x01(\x0b2\
    \x1e.linkbot.robot.writeEeprom.OutH\0R\x0bwriteEeprom\x12?\n\nreadEeprom\
    \x181\x20\x01(\x0b2\x1d.linkbot.robot.readEeprom.OutH\0R\nreadEeprom\x12\
    9\n\x08writeTwi\x182\x20\x01(\x0b2\x1b.linkbot.robot.writeTwi.OutH\0R\
    \x08writeTwi\x126\n\x07readTwi\x183\x20\x01(\x0b2\x1a.linkbot.robot.read\
    Twi.OutH\0R\x07readTwi\x12E\n\x0cwriteReadTwi\x184\x20\x01(\x0b2\x1f.lin\
    kbot.robot.writeReadTwi.OutH\0R\x0cwriteReadTwiB\x05\n\x03arg\"\x8c\x01\
    \n\x0bButtonEvent\x12\x1c\n\ttimestamp\x18\x01\x20\x01(\rR\ttimestamp\
    \x12-\n\x06button\x18\x02\x20\x01(\x0e2\x15.linkbot.robot.ButtonR\x06but\
    ton\x120\n\x05state\x18\x03\x20\x01(\x0e2\x1a.linkbot.robot.ButtonStateR\
    \x05state\"a\n\x0cEncoderEvent\x12\x1c\n\ttimestamp\x18\x01\x20\x01(\rR\
    \ttimestamp\x12\x12\n\x04mask\x18\x02\x20\x01(\rR\x04mask\x12\x1f\n\x06v\
    alues\x18\x03\x20\x03(\x02R\x06valuesB\x07\x10\x01\x92?\x02\x10\x04\"\\\
    \n\x12AccelerometerEvent\x12\x1c\n\ttimestamp\x18\x01\x20\x01(\rR\ttimes\
    tamp\x12\x0c\n\x01x\x18\x02\x20\x01(\x02R\x01x\x12\x0c\n\x01y\x18\x03\
    \x20\x01(\x02R\x01y\x12\x0c\n\x01z\x18\x04\x20\x01(\x02R\x01z\"\x87\x01\
    \n\nJointEvent\x12\x1c\n\ttimestamp\x18\x01\x20\x01(\rR\ttimestamp\x12\
    \x14\n\x05joint\x18\x02\x20\x01(\rR\x05joint\x12/\n\x05event\x18\x03\x20\
    \x01(\x0e2\x19.linkbot.robot.JointStateR\x05event\x12\x14\n\x05angle\x18\
    \x04\x20\x01(\x02R\x05angle\"Y\n\x11DebugMessageEvent\x12\x1c\n\ttimesta\
    mp\x18\x01\x20\x01(\rR\ttimestamp\x12&\n\nbytestring\x18\x02\x20\x01(\tR\
    \nbytestringB\x06\x92?\x03\x08\x80\x01\",\n\x0cConnectEvent\x12\x1c\n\tt\
    imestamp\x18\x01\x20\x01(\rR\ttimestamp\"/\n\x0fDisconnectEvent\x12\x1c\
    \n\ttimestamp\x18\x01\x20\x01(\rR\ttimestamp\"D\n\x10ResetPeripherals\
    \x120\n\x13peripheralResetMask\x18\x02\x20\x01(\rR\x13peripheralResetMas\
    k\"S\n\rClientToRobot\x12;\n\nrpcRequest\x18\x01\x20\x01(\x0b2\x19.linkb\
    ot.robot.RpcRequestH\0R\nrpcRequestB\x05\n\x03arg\"n\n\x16ClientToRobotB\
    roadcast\x12M\n\x10resetPeripherals\x18\x01\x20\x01(\x0b2\x1f.linkbot.ro\
    bot.ResetPeripheralsH\0R\x10resetPeripheralsB\x05\n\x03arg\"\xc3\x04\n\r\
    RobotToClient\x125\n\x08rpcReply\x18\x01\x20\x01(\x0b2\x17.linkbot.robot\
    .RpcReplyH\0R\x08rpcReply\x12S\n\x12accelerometerEvent\x18\x02\x20\x01(\
    \x0b2!.linkbot.robot.AccelerometerEventH\0R\x12accelerometerEvent\x12>\n\
    \x0bbuttonEvent\x18\x03\x20\x01(\x0b2\x1a.linkbot.robot.ButtonEventH\0R\
    \x0bbuttonEvent\x12A\n\x0cencoderEvent\x18\x04\x20\x01(\x0b2\x1b.linkbot\
    .robot.EncoderEventH\0R\x0cencoderEvent\x12;\n\njointEvent\x18\x05\x20\
    \x01(\x0b2\x19.linkbot.robot.JointEventH\0R\njointEvent\x12P\n\x11debugM\
    essageEvent\x18\x06\x20\x01(\x0b2\x20.linkbot.robot.DebugMessageEventH\0\
    R\x11debugMessageEvent\x12A\n\x0cconnectEvent\x18\x07\x20\x01(\x0b2\x1b.\
    linkbot.robot.ConnectEventH\0R\x0cconnectEvent\x12J\n\x0fdisconnectEvent\
    \x18\x08\x20\x01(\x0b2\x1e.linkbot.robot.DisconnectEventH\0R\x0fdisconne\
    ctEventB\x05\n\x03arg*-\n\nFormFactor\x12\x05\n\x01I\x10\0\x12\x05\n\x01\
    L\x10\x01\x12\x05\n\x01T\x10\x02\x12\n\n\x06DONGLE\x10\x03*8\n\nJointSta\
    te\x12\t\n\x05COAST\x10\0\x12\x08\n\x04HOLD\x10\x01\x12\n\n\x06MOVING\
    \x10\x02\x12\t\n\x05ERROR\x10\x04*!\n\x06Button\x12\t\n\x05POWER\x10\0\
    \x12\x05\n\x01A\x10\x01\x12\x05\n\x01B\x10\x02*\x1f\n\x0bButtonState\x12\
    \x06\n\x02UP\x10\0\x12\x08\n\x04DOWN\x10\x01*E\n\nPeripheral\x12\n\n\x06\
    MOTOR1\x10\0\x12\n\n\x06MOTOR2\x10\x01\x12\n\n\x06MOTOR3\x10\x02\x12\x07\
    \n\x03LED\x10\x03\x12\n\n\x06BUZZER\x10\x04\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
